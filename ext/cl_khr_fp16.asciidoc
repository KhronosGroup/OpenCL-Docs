// Copyright 2017-2023 The Khronos Group. This work is licensed under a
// Creative Commons Attribution 4.0 International License; see
// http://creativecommons.org/licenses/by/4.0/

[[cl_khr_fp16]]
== Half Precision Floating-Point

This section describes the *cl_khr_fp16* extension.
This extension adds support for half scalar and vector types as built-in
types that can be used for arithmetic operations, conversions etc.

=== General information

==== Version history

[cols="1,1,3",options="header",]
|====
| *Date*     | *Version* | *Description*
| 2020-04-21 | 1.0.0     | First assigned version.
|====

[[cl_khr_fp16-additions-to-chapter-6-of-the-opencl-2.0-specification]]
=== Additions to Chapter 6 of the OpenCL 2.0 C Specification

The list of built-in scalar, and vector data types defined in _tables 6.1_,
and _6.2_ are extended to include the following:

[cols="1,3",options="header",]
|====
| *Type*   | *Description*
| *half2*  | A 2-component half-precision floating-point vector.
| *half3*  | A 3-component half-precision floating-point vector.
| *half4*  | A 4-component half-precision floating-point vector.
| *half8*  | A 8-component half-precision floating-point vector.
| *half16* | A 16-component half-precision floating-point vector.
|====

The built-in vector data types for `halfn` are also declared as appropriate
types in the OpenCL API (and header files) that can be used by an
application.
The following table describes the built-in vector data types for `halfn` as
defined in the OpenCL C programming language and the corresponding data type
available to the application:

[cols=",",options="header",]
|====
| *Type in OpenCL Language* | *API type for application*
| *half2*                   | *cl_half2*
| *half3*                   | *cl_half3*
| *half4*                   | *cl_half4*
| *half8*                   | *cl_half8*
| *half16*                  | *cl_half16*
|====

The relational, equality, logical and logical unary operators described in
_section 6.3_ can be used with `half` scalar and `halfn` vector types and
shall produce a scalar `int` and vector `shortn` result respectively.

The OpenCL compiler accepts an h and H suffix on floating-point literals,
indicating the literal is typed as a half.

[[cl_khr_fp16-conversions]]
==== Conversions

The implicit conversion rules specified in _section 6.2.1_ now include the
`half` scalar and `halfn` vector data types.

The explicit casts described in _section 6.2.2_ are extended to take a
`half` scalar data type and a `halfn` vector data type.

The explicit conversion functions described in _section 6.2.3_ are extended
to take a `half` scalar data type and a `halfn` vector data type.

The `as_typen()` function for re-interpreting types as described in _section
6.2.4.2_ is extended to allow conversion-free casts between `shortn`,
`ushortn`, and `halfn` scalar and vector data types.

[[cl_khr_fp16-math-functions]]
==== Math Functions

The built-in math functions defined in _table 6.8_ (also listed below) are
extended to include appropriate versions of functions that take `half` and
`half{2|3|4|8|16}` as arguments and return values.
`gentype` now also includes `half`, `half2`, `half3`, `half4`, `half8`, and
`half16`.

For any specific use of a function, the actual type has to be the same for
all arguments and the return type.

._Half Precision Built-in Math Functions_
[cols=",",options="header",]
|====
| *Function*
| *Description*

| gentype *acos* (gentype _x_)
| Arc cosine function.

| gentype *acosh* (gentype _x_)
| Inverse hyperbolic cosine.

| gentype *acospi* (gentype _x_)
| Compute *acos* (_x_) / {pi}.

| gentype *asin* (gentype _x_)
| Arc sine function.

| gentype *asinh* (gentype _x_)
| Inverse hyperbolic sine.

| gentype *asinpi* (gentype _x_)
| Compute *asin* (_x_) / {pi}.

| gentype *atan* (gentype _y_over_x_)
| Arc tangent function.

| gentype *atan2* (gentype _y_, gentype _x_)
| Arc tangent of _y_ / _x_.

| gentype *atanh* (gentype _x_)
| Hyperbolic arc tangent.

| gentype *atanpi* (gentype _x_)
| Compute *atan* (_x_) / {pi}.

| gentype *atan2pi* (gentype _y_, gentype _x_)
| Compute *atan2* (_y_, _x_) / {pi}.

| gentype *cbrt* (gentype _x_)
| Compute cube-root.

| gentype *ceil* (gentype _x_)
| Round to integral value using the round to positive infinity rounding
  mode.

| gentype *copysign* (gentype _x_, gentype _y_)
| Returns _x_ with its sign changed to match the sign of _y_.

| gentype *cos* (gentype _x_)
| Compute cosine.

| gentype *cosh* (gentype _x_)
| Compute hyperbolic cosine.

| gentype *cospi* (gentype _x_)
| Compute *cos* ({pi} _x_).

| gentype *erfc* (gentype _x_)
| Complementary error function.

| gentype *erf* (gentype _x_)
| Error function encountered in integrating the normal distribution.

| gentype *exp* (gentype _x_)
| Compute the base- e exponential of _x_.

| gentype *exp2* (gentype _x_)
| Exponential base 2 function.

| gentype *exp10* (gentype _x_)
| Exponential base 10 function.

| gentype *expm1* (gentype _x_)
| Compute _e^x^_- 1.0.

| gentype *fabs* (gentype _x_)
| Compute absolute value of a floating-point number.

| gentype *fdim* (gentype _x_, gentype _y_)
| _x_ - _y_ if _x_ > _y_, +0 if x is less than or equal to y.

| gentype *floor* (gentype _x_)
| Round to integral value using the round to negative infinity rounding
  mode.

| gentype *fma* (gentype _a_, gentype _b_, gentype _c_)
| Returns the correctly rounded floating-point representation of the sum of
  _c_ with the infinitely precise product of _a_ and _b_.
  Rounding of intermediate products shall not occur.
  Edge case behavior is per the IEEE 754-2008 standard.

| gentype *fmax* (gentype _x_, gentype _y_) +
  gentype *fmax* (gentype _x_, half _y_)
| Returns _y_ if _x_ < _y_, otherwise it returns _x_.
  If one argument is a NaN, *fmax()* returns the other argument.
  If both arguments are NaNs, *fmax()* returns a NaN.

| gentype *fmin* (gentype _x_, gentype _y_) +
  gentype *fmin* (gentype _x_, half _y_)
| Returns _y_ if _y_ < _x_, otherwise it returns _x_.
  If one argument is a NaN, *fmin()* returns the other argument.
  If both arguments are NaNs, *fmin()* returns a NaN.

| gentype *fmod* (gentype _x_, gentype _y_)
| Modulus.
  Returns _x_ - _y_ * *trunc* (_x_/_y_) .

| gentype **fract** (gentype _x_, {global} gentype *_iptr_) +
  gentype **fract** (gentype _x_, {local} gentype *_iptr_) +
  gentype **fract** (gentype _x_, {private} gentype *_iptr_) +

  For OpenCL C 2.0 or with the `+__opencl_c_generic_address_space+`
  feature macro: +

  gentype **fract** (gentype _x_, gentype *_iptr_)
| Returns *fmin*( _x_ - *floor* (_x_), 0x1.ffcp-1f ).

  *floor*(x) is returned in _iptr_.

| half__n__ **frexp** (half__n x__, {global} int__n__ *exp) +
  half **frexp** (half _x_, {global} int *exp) +

  half__n__ **frexp** (half__n x__, {local} int__n__ *exp) +
  half **frexp** (half _x_, {local} int *exp) +

  half__n__ **frexp** (half__n x__, {private} int__n__ *exp) +
  half **frexp** (half _x_, {private} int *exp) +

  For OpenCL C 2.0 or with the `+__opencl_c_generic_address_space+`
  feature macro: +

  half__n__ **frexp** (half__n__ _x_, int__n__ *exp) +
  half **frexp** (half _x_, int *exp)
| Extract mantissa and exponent from _x_.
  For each component the mantissa returned is a `half` with magnitude
  in the interval [1/2, 1) or 0.
  Each component of _x_ equals mantissa returned * 2__^exp^__.

| gentype *hypot* (gentype _x_, gentype _y_)
| Compute the value of the square root of __x__^2^+ __y__^2^ without undue
  overflow or underflow.

| int__n__ *ilogb* (half__n__ _x_) +
  int *ilogb* (half _x_)
| Return the exponent as an integer value.

| half__n__ *ldexp* (half__n__ _x_, int__n__ _k_) +
  half__n__ *ldexp* (half__n__ _x_, int _k_) +
  half *ldexp* (half _x_, int _k_)
| Multiply _x_ by 2 to the power _k_.

| gentype **lgamma** (gentype _x_) +

  half__n__ **lgamma_r** (half__n__ _x_, {global} int__n__ *_signp_) +
  half **lgamma_r** (half _x_, {global} int *_signp_) +

  half__n__ **lgamma_r** (half__n__ _x_, {local} int__n__ *_signp_) +
  half **lgamma_r** (half _x_, {local} int *_signp_) +

  half__n__ **lgamma_r** (half__n__ _x_, {private} int__n__ *_signp_) +
  half **lgamma_r** (half _x_, {private} int *_signp_) +

  For OpenCL C 2.0 or with the `+__opencl_c_generic_address_space+`
  feature macro: +

  half__n__ **lgamma_r** (half__n__ _x_, int__n__ *_signp_) +
  half **lgamma_r** (half _x_, int *_signp_)
| Log gamma function.
  Returns the natural logarithm of the absolute value of the gamma function.
  The sign of the gamma function is returned in the _signp_ argument of
  *lgamma_r*.

| gentype *log* (gentype _x_)
| Compute natural logarithm.

| gentype *log2* (gentype _x_)
| Compute a base 2 logarithm.

| gentype *log10* (gentype _x_)
| Compute a base 10 logarithm.

| gentype *log1p* (gentype _x_)
| Compute log~e~(1.0 + _x_) .

| gentype *logb* (gentype _x_)
| Compute the exponent of _x_, which is the integral part of
  log__~r~__\|_x_\|.

| gentype *mad* (gentype _a_, gentype _b_, gentype _c_)
| *mad* computes _a_ * _b_ + _c_.
  The function may compute _a_ * _b_ + _c_ with reduced accuracy
  in the embedded profile.  See the OpenCL SPIR-V Environment Specification
  for details. On some hardware the mad instruction may provide better
  performance than expanded computation of _a_ * _b_ + _c_.

  Note: For some usages, e.g. *mad*(a, b, -a*b), the half precision
  definition of *mad*() is loose enough that almost any result is allowed
  from *mad*() for some values of a and b.

| gentype *maxmag* (gentype _x_, gentype _y_)
| Returns _x_ if \|_x_\| > \|_y_\|, _y_ if \|_y_\| > \|_x_\|, otherwise
  *fmax*(_x_, _y_).

| gentype *minmag* (gentype _x_, gentype _y_)
| Returns _x_ if \|_x_\| < \|_y_\|, _y_ if \|_y_\| < \|_x_\|, otherwise
  *fmin*(_x_, _y_).

| gentype **modf** (gentype _x_, {global} gentype *_iptr_) +
  gentype **modf** (gentype _x_, {local} gentype *_iptr_) +
  gentype **modf** (gentype _x_, {private} gentype *_iptr_) +

  For OpenCL C 2.0 or with the `+__opencl_c_generic_address_space+`
  feature macro: +

  gentype **modf** (gentype _x_, gentype *_iptr_)
| Decompose a floating-point number.
  The *modf* function breaks the argument _x_ into integral and fractional
  parts, each of which has the same sign as the argument.
  It stores the integral part in the object pointed to by _iptr_.

| half__n__ *nan* (ushort__n__ _nancode_) +
  half *nan* (ushort _nancode_)
| Returns a quiet NaN.
  The _nancode_ may be placed in the significand of the resulting NaN.

| gentype *nextafter* (gentype _x_, gentype _y_)
| Computes the next representable half-precision floating-point value
  following _x_ in the direction of _y_.
  Thus, if _y_ is less than _x_, *nextafter*() returns the largest
  representable floating-point number less than _x_.

| gentype *pow* (gentype _x_, gentype _y_)
| Compute _x_ to the power _y_.

| half__n__ *pown* (half__n__ _x_, int__n__ _y_) +
  half *pown* (half _x_, int _y_)
| Compute _x_ to the power _y_, where _y_ is an integer.

| gentype *powr* (gentype _x_, gentype _y_)
| Compute _x_ to the power _y_, where _x_ is >= 0.

| gentype *remainder* (gentype _x_, gentype _y_)
| Compute the value _r_ such that _r_ = _x_ - _n_*_y_, where _n_ is the
  integer nearest the exact value of _x_/_y_.
  If there are two integers closest to _x_/_y_, _n_ shall be the even one.
  If _r_ is zero, it is given the same sign as _x_.

| half__n__ **remquo** (half__n__ _x_, half__n__ _y_, {global} int__n__ *_quo_) +
  half **remquo** (half _x_, half _y_, {global} int *_quo_) +

  half__n__ **remquo** (half__n__ _x_, half__n__ _y_, {local} int__n__ *_quo_) +
  half **remquo** (half _x_, half _y_, {local} int *_quo_) +

  half__n__ **remquo** (half__n__ _x_, half__n__ _y_, {private} int__n__ *_quo_) +
  half **remquo** (half _x_, half _y_, {private} int *_quo_) +

  For OpenCL C 2.0 or with the `+__opencl_c_generic_address_space+`
  feature macro: +

  half__n__ **remquo** (half__n__ _x_, half__n__ _y_, int__n__ *_quo_) +
  half **remquo** (half _x_, half _y_, int *_quo_)
| The *remquo* function computes the value r such that _r_ = _x_ - _k_*_y_,
  where _k_ is the integer nearest the exact value of _x_/_y_.
  If there are two integers closest to _x_/_y_, _k_ shall be the even one.
  If _r_ is zero, it is given the same sign as _x_.
  This is the same value that is returned by the *remainder* function.
  *remquo* also calculates the lower seven bits of the integral quotient
  _x_/_y_, and gives that value the same sign as _x_/_y_.
  It stores this signed value in the object pointed to by _quo_.

| gentype *rint* (gentype _x_)
| Round to integral value (using round to nearest even rounding mode) in
  floating-point format.
  Refer to section 7.1 for description of rounding modes.

| half__n__ *rootn* (half__n__ _x_, int__n__ _y_) +
  half *rootn* (half _x_, int _y_)
| Compute _x_ to the power 1/_y_.

| gentype *round* (gentype _x_)
| Return the integral value nearest to _x_ rounding halfway cases away from
  zero, regardless of the current rounding direction.

| gentype *rsqrt* (gentype _x_)
| Compute inverse square root.

| gentype *sin* (gentype _x_)
| Compute sine.

| gentype **sincos** (gentype _x_, {global} gentype *_cosval_) +
  gentype **sincos** (gentype _x_, {local} gentype *_cosval_) +
  gentype **sincos** (gentype _x_, {private} gentype *_cosval_) +

  For OpenCL C 2.0 or with the `+__opencl_c_generic_address_space+`
  feature macro: +

  gentype **sincos** (gentype _x_, gentype *_cosval_)
| Compute sine and cosine of x.
  The computed sine is the return value and computed cosine is returned in
  _cosval_.

| gentype *sinh* (gentype _x_)
| Compute hyperbolic sine.

| gentype *sinpi* (gentype _x_)
| Compute *sin* ({pi} _x_).

| gentype *sqrt* (gentype _x_)
| Compute square root.

| gentype *tan* (gentype _x_)
| Compute tangent.

| gentype *tanh* (gentype _x_)
| Compute hyperbolic tangent.

| gentype *tanpi* (gentype _x_)
| Compute *tan* ({pi} _x_).

| gentype *tgamma* (gentype _x_)
| Compute the gamma function.

| gentype *trunc* (gentype _x_)
| Round to integral value using the round to zero rounding mode.
|====

The *FP_FAST_FMA_HALF* macro indicates whether the *fma()* family of
functions are fast compared with direct code for half precision
floating-point.
If defined, the *FP_FAST_FMA_HALF* macro shall indicate that the *fma()*
function generally executes about as fast as, or faster than, a multiply and
an add of *half* operands.

The macro names given in the following list must use the values specified.
These constant expressions are suitable for use in #if preprocessing
directives.

[source,opencl_c]
----
#define HALF_DIG            3
#define HALF_MANT_DIG       11
#define HALF_MAX_10_EXP     +4
#define HALF_MAX_EXP        +16
#define HALF_MIN_10_EXP     -4
#define HALF_MIN_EXP        -13
#define HALF_RADIX          2
#define HALF_MAX            0x1.ffcp15h
#define HALF_MIN            0x1.0p-14h
#define HALF_EPSILON        0x1.0p-10h
----

The following table describes the built-in macro names given above in the
OpenCL C programming language and the corresponding macro names available to
the application.

[cols=",",options="header",]
|====
| *Macro in OpenCL Language* | *Macro for application*
| `HALF_DIG`                 | {CL_HALF_DIG}
| `HALF_MANT_DIG`            | {CL_HALF_MANT_DIG}
| `HALF_MAX_10_EXP`          | {CL_HALF_MAX_10_EXP}
| `HALF_MAX_EXP`             | {CL_HALF_MAX_EXP}
| `HALF_MIN_10_EXP`          | {CL_HALF_MIN_10_EXP}
| `HALF_MIN_EXP`             | {CL_HALF_MIN_EXP}
| `HALF_RADIX`               | {CL_HALF_RADIX}
| `HALF_MAX`                 | {CL_HALF_MAX}
| `HALF_MIN`                 | {CL_HALF_MIN}
| `HALF_EPSILSON`            | {CL_HALF_EPSILON}
|====

The following constants are also available.
They are of type `half` and are accurate within the precision of the `half`
type.

[cols=",",options="header",]
|====
| *Constant*     | *Description*
| `M_E_H`        | Value of e
| `M_LOG2E_H`    | Value of log~2~e
| `M_LOG10E_H`   | Value of log~10~e
| `M_LN2_H`      | Value of log~e~2
| `M_LN10_H`     | Value of log~e~10
| `M_PI_H`       | Value of {pi}
| `M_PI_2_H`     | Value of {pi} / 2
| `M_PI_4_H`     | Value of {pi} / 4
| `M_1_PI_H`     | Value of 1 / {pi}
| `M_2_PI_H`     | Value of 2 / {pi}
| `M_2_SQRTPI_H` | Value of 2 / {sqrt}{pi}
| `M_SQRT2_H`    | Value of {sqrt}2
| `M_SQRT1_2_H`  | Value of 1 / {sqrt}2
|====

[[cl_khr_fp16-common-functions]]
==== Common Functions

The built-in common functions defined in _table 6.12_ (also listed below)
are extended to include appropriate versions of functions that take `half`
and `half{2|3|4|8|16}` as arguments and return values.
gentype now also includes `half`, `half2`, `half3`, `half4`, `half8` and
`half16`.
These are described below.

._Half Precision Built-in Common Functions_
[cols=",",options="header",]
|====
| *Function*
| *Description*

| gentype *clamp* ( +
  gentype _x_, gentype _minval_, gentype _maxval_)

  gentype *clamp* ( +
  gentype _x_, half _minval_, half _maxval_)
| Returns *fmin*(*fmax*(_x_, _minval_), _maxval_).

  Results are undefined if _minval_ > _maxval_.

| gentype *degrees* (gentype _radians_)
| Converts _radians_ to degrees, +
  i.e. (180 / {pi}) * _radians_.

| gentype *max* (gentype _x_, gentype _y_) +
  gentype *max* (gentype _x_, half _y_)
| Returns _y_ if _x_ < _y_, otherwise it returns _x_.
  If _x_ and _y_ are infinite or NaN, the return values are undefined.

| gentype *min* (gentype _x_, gentype _y_) +
  gentype *min* (gentype _x_, half _y_)
| Returns _y_ if _y_ < _x_, otherwise it returns _x_.
  If _x_ and _y_ are infinite or NaN, the return values are undefined.

| gentype *mix* (gentype _x_, gentype _y_, gentype _a_) +
  gentype *mix* (gentype _x_, gentype _y_, half _a_)
| Returns the linear blend of _x_ and _y_ implemented as:

  _x_ + (_y_ - _x)_ * _a_

  _a_ must be a value in the range 0.0 ... 1.0.
  If _a_ is not in the range 0.0 ... 1.0, the return values are undefined.

  Note: The half precision *mix* function can be implemented using contractions such as *mad* or *fma*.

| gentype *radians* (gentype _degrees_)
| Converts _degrees_ to radians, i.e. ({pi} / 180) * _degrees_.

| gentype *step* (gentype _edge_, gentype _x_) +
  gentype *step* (half _edge_, gentype _x_)
| Returns 0.0 if _x_ < _edge_, otherwise it returns 1.0.

| gentype *smoothstep* ( +
  gentype _edge0_, gentype _edge1_, gentype _x_)

  gentype *smoothstep* ( +
  half _edge0_, half _edge1_, gentype _x_)
| Returns 0.0 if _x_ \<= _edge0_ and 1.0 if _x_ >= _edge1_ and performs
  smooth Hermite interpolation between 0 and 1 when _edge0_ < _x_ < _edge1_.
  This is useful in cases where you would want a threshold function with a
  smooth transition.

  This is equivalent to:

  gentype _t_; +
  _t_ = clamp ((_x_ - _edge0_) / (_edge1_ - _edge0_), 0, 1); +
  return _t_ * _t_ * (3 - 2 * _t_); +

  Results are undefined if _edge0_ >= _edge1_.

  Note: The half precision *smoothstep* function can be implemented using contractions such as *mad* or *fma*.

| gentype *sign* (gentype _x_)
| Returns 1.0 if _x_ > 0, -0.0 if _x_ = -0.0, +0.0 if _x_ = +0.0, or -1.0 if
  _x_ < 0.
  Returns 0.0 if _x_ is a NaN.

|====

[[cl_khr_fp16-geometric-functions]]
==== Geometric Functions

The built-in geometric functions defined in _table 6.13_ (also listed below)
are extended to include appropriate versions of functions that take `half`
and `half{2|3|4}` as arguments and return values.
gentype now also includes `half`, `half2`, `half3` and `half4`.
These are described below.

Note: The half precision geometric functions can be implemented using
contractions such as *mad* or *fma*.

._Half Precision Built-in Geometric Functions_
[cols=",",options="header",]
|====
| *Function*
| *Description*

| half4 *cross* (half4 _p0_, half4 _p1_) +
  half3 *cross* (half3 _p0_, half3 _p1_)
| Returns the cross product of _p0.xyz_ and _p1.xyz_.
  The _w_ component of the result will be 0.0.

| half *dot* (gentype _p0_, gentype _p1_)
| Compute the dot product of _p0_ and _p1_.

| half *distance* (gentype _p0_, gentype _p1_)
| Returns the distance between _p0_ and _p1_.
  This is calculated as *length*(_p0_ - _p1_).

| half *length* (gentype _p_)
| Return the length of vector x, i.e., +
  sqrt( __p.x__^2^ + __p.y__^2^ + ... )

| gentype *normalize* (gentype _p_)
| Returns a vector in the same direction as _p_ but with a length of 1.

|====

[[cl_khr_fp16-relational-functions]]
==== Relational Functions

The scalar and vector relational functions described in _table 6.14_ are
extended to include versions that take `half`, `half2`, `half3`, `half4`,
`half8` and `half16` as arguments.

The relational and equality operators (<, \<=, >, >=, !=, ==) can be used
with `halfn` vector types and shall produce a vector `shortn` result as
described in _section 6.3_.

The functions *isequal*, *isnotequal*, *isgreater*, *isgreaterequal*,
*isless*, *islessequal*, *islessgreater*, *isfinite*, *isinf*, *isnan*,
*isnormal*, *isordered*, *isunordered* and *signbit* shall return a 0 if the
specified relation is _false_ and a 1 if the specified relation is true for
scalar argument types.
These functions shall return a 0 if the specified relation is _false_ and a
-1 (i.e. all bits set) if the specified relation is _true_ for vector
argument types.

The relational functions *isequal*, *isgreater*, *isgreaterequal*, *isless*,
*islessequal*, and *islessgreater* always return 0 if either argument is not
a number (NaN).
*isnotequal* returns 1 if one or both arguments are not a number (NaN) and
the argument type is a scalar and returns -1 if one or both arguments are
not a number (NaN) and the argument type is a vector.

The functions described in _table 6.14_ are extended to include the `halfn`
vector types.

._Half Precision Relational Functions_
[cols=",",options="header",]
|====
| *Function*
| *Description*

| int *isequal* (half _x_, half _y_) +
  short__n__ *isequal* (half__n x__, half__n y__)
| Returns the component-wise compare of _x_ == _y_.

| int *isnotequal* (half _x_, half _y_) +
  short__n__ *isnotequal* (half__n x__, half__n y__)
| Returns the component-wise compare of _x_ != _y_.

| int *isgreater* (half _x_, half _y_) +
  short__n__ *isgreater* (half__n x__, half__n y__)
| Returns the component-wise compare of _x_ > _y_.

| int *isgreaterequal* (half _x_, half _y_) +
  short__n__ *isgreaterequal* (half__n x__, half__n y__)
| Returns the component-wise compare of _x_ >= _y_.

| int *isless* (half _x_, half _y_) +
  short__n__ *isless* (half__n x__, half__n y__)
| Returns the component-wise compare of _x_ < _y_.

| int *islessequal* (half _x_, half _y_) +
  short__n__ *islessequal* (half__n x__, half__n y__)
| Returns the component-wise compare of _x_ \<= _y_.

| int *islessgreater* (half _x_, half _y_) +
  short__n__ *islessgreater* (half__n x__, half__n y__)
| Returns the component-wise compare of (_x_ < _y_) \|\| (_x_ > _y_) .

| |

| int *isfinite* (half) +
  short__n__ *isfinite* (half__n__)
| Test for finite value.

| int *isinf* (half) +
  short__n__ *isinf* (half__n__)
| Test for infinity value (positive or negative) .

| int *isnan* (half) +
  short__n__ *isnan* (half__n__)
| Test for a NaN.

| int *isnormal* (half) +
  short__n__ *isnormal* (half__n__)
| Test for a normal value.

| int *isordered* (half _x_, half _y_) +
  short__n__ *isordered* (half__n x__, half__n y__)
| Test if arguments are ordered.
  *isordered*() takes arguments _x_ and _y_, and returns the result
  *isequal*(_x_, _x_) && *isequal*(_y_, _y_).

| int *isunordered* (half _x_, half _y_) +
  short__n__ *isunordered* (half__n x__, half__n y__)
| Test if arguments are unordered.
  *isunordered*() takes arguments _x_ and _y_, returning non-zero if _x_ or
  _y_ is a NaN, and zero otherwise.

| int *signbit* (half) +
  short__n__ *signbit* (half__n__)
| Test for sign bit.
  The scalar version of the function returns a 1 if the sign bit in the half
  is set else returns 0.
  The vector version of the function returns the following for each
  component in half__n__: -1 (i.e all bits set) if the sign bit in the half
  is set else returns 0.

| |

| half__n__ *bitselect* (half__n a__, half__n b__, half__n c__)
| Each bit of the result is the corresponding bit of _a_ if the
  corresponding bit of _c_ is 0.
  Otherwise it is the corresponding bit of _b_.

| half__n__ *select* (half__n a__, half__n b__, short__n__ _c_) +
  half__n__ *select* (half__n a__, half__n b__, ushort__n__ _c_)
| For each component, +
  _result[i]_ = if MSB of _c[i]_ is set ? _b[i]_ : _a[i]_. +

|====

[[cl_khr_fp16-vector-data-load-and-store-functions]]
==== Vector Data Load and Store Functions

The vector data load (*vload__n__*) and store (*vstore__n__*) functions
described in _table 6.13_ (also listed below) are extended to include
versions that read or write half vector values.
The generic type `gentype` is extended to include `half`.
The generic type `gentypen` is extended to include `half2`, `half3`,
`half4`, `half8`, and `half16`.

Note: *vload3* reads _x_, _y_, _z_ components from address 
(_p_ + (_offset_ * 3)) into a 3-component vector and *vstore3* writes _x_, _y_, _z_
components from a 3-component vector to address (_p_ + (_offset_ * 3)).

._Half Precision Vector Data Load and Store Functions_
[cols=",",options="header",]
|====
| *Function*
| *Description*

| gentype__n__ **vload__n__**(size_t _offset_, const {global} gentype *_p_) +
  gentype__n__ **vload__n__**(size_t _offset_, const {local} gentype *_p_) +
  gentype__n__ **vload__n__**(size_t _offset_, const {constant} gentype *_p_) +
  gentype__n__ **vload__n__**(size_t _offset_, const {private} gentype *_p_) +

  For OpenCL C 2.0 or with the `+__opencl_c_generic_address_space+`
  feature macro: +

  gentype__n__ **vload__n__**(size_t _offset_, const gentype *_p_)
| Return sizeof (gentype__n__) bytes of data read from address
  (_p_ + (_offset * n_)).
  If gentype is half, the read address computed as (_p_ + (_offset * n_))
  must be 16-bit aligned.

| void **vstore__n__**(gentype__n__ _data_, size_t _offset_, {global} gentype *_p_) +
  void **vstore__n__**(gentype__n__ _data_, size_t _offset_, {local} gentype *_p_) +
  void **vstore__n__**(gentype__n__ _data_, size_t _offset_, {private} gentype *_p_) +

  For OpenCL C 2.0 or with the `+__opencl_c_generic_address_space+`
  feature macro: +

  void **vstore__n__**(gentype__n__ _data_, size_t _offset_, gentype *_p_)
| Write sizeof (gentype__n__) bytes given by _data_ to address
  (_p_ + (_offset * n_)).
  If gentype is half, the write address computed as (_p_ + (_offset * n_))
  must be 16-bit aligned.

|====

[[cl_khr_fp16-async-copies-from-global-to-local-memory-local-to-global-memory-and-prefetch]]
==== Async Copies from Global to Local Memory, Local to Global Memory, and Prefetch

The OpenCL C programming language implements the following functions that
provide asynchronous copies between global and local memory and a prefetch
from global memory.

The generic type `gentype` is extended to include `half`, `half2`, `half3`,
`half4`, `half8`, and `half16`.

._Half Precision Built-in Async Copy and Prefetch Functions_
[cols=",",options="header",]
|====
| *Function*
| *Description*

| event_t **async_work_group_copy** ( +
  {local} gentype *_dst_, +
  const {global} gentype *_src_, +
  size_t _num_gentypes_, event_t _event_)

  event_t **async_work_group_copy** ( +
  {global} gentype _*dst_, +
  const {local} gentype *_src_, +
  size_t _num_gentypes_, event_t _event_)
| Perform an async copy of _num_gentypes_ gentype elements from _src_ to
  _dst_.
  The async copy is performed by all work-items in a work-group and this
  built-in function must therefore be encountered by all work-items in a
  work-group executing the kernel with the same argument values; otherwise
  the results are undefined.

  Returns an event object that can be used by *wait_group_events* to wait
  for the async copy to finish.
  The _event_ argument can also be used to associate the
  *async_work_group_copy* with a previous async copy allowing an event to be
  shared by multiple async copies; otherwise _event_ should be zero.

  If _event_ argument is not zero, the event object supplied in _event_
  argument will be returned.

  This function does not perform any implicit synchronization of source data
  such as using a *barrier* before performing the copy.

| |

| event_t **async_work_group_strided_copy** ( +
  {local} gentype _*dst_, +
  const {global} gentype *_src_, +
  size_t _num_gentypes_, +
  size_t _src_stride_, event_t _event_)

  event_t **async_work_group_strided_copy** ( +
  {global} gentype _*dst_, +
  const {local} gentype *_src_, +
  size_t _num_gentypes_, +
  size_t _dst_stride_, event_t _event_)
| Perform an async gather of _num_gentypes_ gentype elements from _src_ to
  _dst_.
  The _src_stride_ is the stride in elements for each gentype element read
  from _src_.
  The async gather is performed by all work-items in a work-group and this
  built-in function must therefore be encountered by all work-items in a
  work-group executing the kernel with the same argument values; otherwise
  the results are undefined.

  Returns an event object that can be used by *wait_group_events* to wait
  for the async copy to finish.
  The _event_ argument can also be used to associate the
  *async_work_group_strided_copy* with a previous async copy allowing an
  event to be shared by multiple async copies; otherwise _event_ should be
  zero.

  If _event_ argument is not zero, the event object supplied in _event_
  argument will be returned.

  This function does not perform any implicit synchronization of source data
  such as using a *barrier* before performing the copy.

  The behavior of *async_work_group_strided_copy* is undefined if
  _src_stride_ or _dst_stride_ is 0, or if the _src_stride_ or _dst_stride_
  values cause the _src_ or _dst_ pointers to exceed the upper bounds of the
  address space during the copy.

| |

| void *wait_group_events* ( +
  int _num_events_, event_t *_event_list_)
| Wait for events that identify the *async_work_group_copy* operations to
  complete.
  The event objects specified in _event_list_ will be released after the
  wait is performed.

  This function must be encountered by all work-items in a work-group
  executing the kernel with the same _num_events_ and event objects
  specified in _event_list_; otherwise the results are undefined.

| void *prefetch* ( +
  const {global} gentype *__p__, size_t _num_gentypes_)
| Prefetch _num_gentypes_ * sizeof(gentype) bytes into the global cache.
  The prefetch instruction is applied to a work-item in a work-group and
  does not affect the functional behavior of the kernel.

|====

[[cl_khr_fp16-image-read-and-write-functions]]
==== Image Read and Write Functions

The image read and write functions defined in _tables 6.23_, _6.24_ and
_6.25_ are extended to support image color values that are a `half` type.

==== Built-in Image Read Functions

._Half Precision Built-in Image Read Functions_
[cols=",",options="header",]
|====
| *Function*
| *Description*

| half4 *read_imageh* ( +
  read_only image2d_t _image_, +
  sampler_t _sampler_, +
  int2 _coord_)

  half4 *read_imageh* ( +
  read_only image2d_t _image_, +
  sampler_t _sampler_, +
  float2 _coord_)
| Use the coordinate _(coord.x, coord.y)_ to do an element lookup in the 2D
  image object specified by _image_.

  *read_imageh* returns half precision floating-point values in the range
  [0.0 ... 1.0] for image objects created with _image_channel_data_type_ set
  to one of the pre-defined packed formats, {CL_UNORM_INT8}, or
  {CL_UNORM_INT16}.

  *read_imageh* returns half precision floating-point values in the range
  [-1.0 ... 1.0] for image objects created with _image_channel_data_type_
  set to {CL_SNORM_INT8}, or {CL_SNORM_INT16}.

  *read_imageh* returns half precision floating-point values for image
  objects created with _image_channel_data_type_ set to {CL_HALF_FLOAT}.

  The *read_imageh* calls that take integer coordinates must use a sampler
  with filter mode set to `CLK_FILTER_NEAREST`, normalized coordinates set to
  `CLK_NORMALIZED_COORDS_FALSE` and addressing mode set to
  `CLK_ADDRESS_CLAMP_TO_EDGE`, `CLK_ADDRESS_CLAMP` or `CLK_ADDRESS_NONE`;
  otherwise the values returned are undefined.

  Values returned by *read_imageh* for image objects with
  _image_channel_data_type_ values not specified in the description above
  are undefined.

| |

| half4 *read_imageh* ( +
  read_only image3d_t _image_, +
  sampler_t _sampler_, +
  int4 _coord_ )

  half4 *read_imageh* ( +
  read_only image3d_t _image_, +
  sampler_t _sampler_, +
  float4 _coord_)
| Use the coordinate _(coord.x_, _coord.y_, _coord.z)_ to do an
  elementlookup in the 3D image object specified by _image_. _coord.w_ is
  ignored.

  *read_imageh* returns half precision floating-point values in the range
  [0.0 ... 1.0] for image objects created with _image_channel_data_type_ set
  to one of the pre-defined packed formats or {CL_UNORM_INT8}, or
  {CL_UNORM_INT16}.

  *read_imageh* returns half precision floating-point values in the range
  [-1.0 ... 1.0] for image objects created with _image_channel_data_type_
  set to {CL_SNORM_INT8}, or {CL_SNORM_INT16}.

  **read_imageh**returns half precision floating-point values for image
  objects created with _image_channel_data_type_ set to {CL_HALF_FLOAT}.

  The *read_imageh* calls that take integer coordinates must use a sampler
  with filter mode set to `CLK_FILTER_NEAREST`, normalized coordinates set to
  `CLK_NORMALIZED_COORDS_FALSE` and addressing mode set to
  `CLK_ADDRESS_CLAMP_TO_EDGE`, `CLK_ADDRESS_CLAMP` or `CLK_ADDRESS_NONE`;
  otherwise the values returned are undefined.

  Values returned by *read_imageh* for image objects with
  _image_channel_data_type_ values not specified in the description are
  undefined.

| |

| half4 *read_imageh* ( +
  read_only image2d_array_t _image_, +
  sampler_t _sampler_, +
  int4 _coord_)

  half4 *read_imageh* ( +
  read_only image2d_array_t _image_, +
  sampler_t _sampler_, +
  float4 _coord_)
| Use _coord.xy_ to do an element lookup in the 2D image identified by
  _coord.z_ in the 2D image array specified by _image_.

  *read_imageh* returns half precision floating-point values in the range
  [0.0 ... 1.0] for image objects created with image_channel_data_type set
  to one of the pre-defined packed formats or {CL_UNORM_INT8}, or
  {CL_UNORM_INT16}.

  *read_imageh* returns half precision floating-point values in the range
  [-1.0 ... 1.0] for image objects created with image_channel_data_type set
  to {CL_SNORM_INT8}, or {CL_SNORM_INT16}.

  *read_imageh* returns half precision floating-point values for image
  objects created with image_channel_data_type set to {CL_HALF_FLOAT}.

  The *read_imageh* calls that take integer coordinates must use a sampler
  with filter mode set to `CLK_FILTER_NEAREST`, normalized coordinates set to
  `CLK_NORMALIZED_COORDS_FALSE` and addressing mode set to
  `CLK_ADDRESS_CLAMP_TO_EDGE`, `CLK_ADDRESS_CLAMP` or `CLK_ADDRESS_NONE`;
  otherwise the values returned are undefined.

  Values returned by *read_imageh* for image objects with
  image_channel_data_type values not specified in the description above are
  undefined.

| |

| half4 *read_imageh* ( +
  read_only image1d_t _image_, +
  sampler_t _sampler_, +
  int _coord_)

  half4 *read_imageh* ( +
  read_only image1d_t _image_, +
  sampler_t _sampler_, +
  float _coord_)
| Use _coord_ to do an element lookup in the 1D image object specified by
  _image_.

  *read_imageh* returns half precision floating-point values in the range
  [0.0 ... 1.0] for image objects created with _image_channel_data_type_ set
  to one of the pre-defined packed formats or {CL_UNORM_INT8}, or
  {CL_UNORM_INT16}.

  *read_imageh* returns half precision floating-point values in the range
  [-1.0 ... 1.0] for image objects created with _image_channel_data_type_
  set to {CL_SNORM_INT8}, or {CL_SNORM_INT16}.

  *read_imageh* returns half precision floating-point values for image
  objects created with _image_channel_data_type_ set to {CL_HALF_FLOAT}.

  The *read_imageh* calls that take integer coordinates must use a sampler
  with filter mode set to `CLK_FILTER_NEAREST`, normalized coordinates set to
  `CLK_NORMALIZED_COORDS_FALSE` and addressing mode set to
  `CLK_ADDRESS_CLAMP_TO_EDGE`, `CLK_ADDRESS_CLAMP` or `CLK_ADDRESS_NONE`;
  otherwise the values returned are undefined.

  Values returned by *read_imageh* for image objects with
  _image_channel_data_type_ values not specified in the description above
  are undefined.

| |

| half4 *read_imageh* ( +
  read_only image1d_array_t _image_, +
  sampler_t _sampler_, +
  int2 _coord_)

  half4 *read_imageh* ( +
  read_only image1d_array_t _image_, +
  sampler_t _sampler_, +
  float2 _coord_)
| Use _coord.x_ to do an element lookup in the 1D image identified by
  _coord.y_ in the 1D image array specified by _image_.

  *read_imageh* returns half precision floating-point values in the range
  [0.0 ... 1.0] for image objects created with image_channel_data_type set
  to one of the pre-defined packed formats or {CL_UNORM_INT8}, or
  {CL_UNORM_INT16}.

  *read_imageh* returns half precision floating-point values in the range
  [-1.0 ... 1.0] for image objects created with image_channel_data_type set
  to {CL_SNORM_INT8}, or {CL_SNORM_INT16}.

  *read_imageh* returns half precision floating-point values for image
  objects created with image_channel_data_type set to {CL_HALF_FLOAT}.

  The *read_imageh* calls that take integer coordinates must use a sampler
  with filter mode set to `CLK_FILTER_NEAREST`, normalized coordinates set to
  `CLK_NORMALIZED_COORDS_FALSE` and addressing mode set to
  `CLK_ADDRESS_CLAMP_TO_EDGE`, `CLK_ADDRESS_CLAMP` or `CLK_ADDRESS_NONE`;
  otherwise the values returned are undefined.

  Values returned by *read_imageh* for image objects with
  image_channel_data_type values not specified in the description above are
  undefined.

|====

==== Built-in Image Sampler-less Read Functions

_aQual_ in Table 6.24 refers to one of the access qualifiers.
For sampler-less read functions this may be _read_only_ or _read_write_.

._Half Precision Built-in Image Sampler-less Read Functions_
[cols=",",options="header",]
|====
| *Function*
| *Description*

|  half4 *read_imageh* ( +
  _aQual_ image2d_t _image_, +
  int2 _coord_)
| Use the coordinate _(coord.x, coord.y)_ to do an element lookup in the 2D
  image object specified by _image_.

  *read_imageh* returns half precision floating-point values in the range
  [0.0 ... 1.0] for image objects created with _image_channel_data_type_ set
  to one of the pre-defined packed formats or {CL_UNORM_INT8}, or
  {CL_UNORM_INT16}.

  *read_imageh* returns half precision floating-point values in the range
  [-1.0 ... 1.0] for image objects created with _image_channel_data_type_
  set to {CL_SNORM_INT8}, or {CL_SNORM_INT16}.

  *read_imageh* returns half precision floating-point values for image
  objects created with _image_channel_data_type_ set to {CL_HALF_FLOAT}.

  Values returned by *read_imageh* for image objects with
  _image_channel_data_type_ values not specified in the description above
  are undefined.

| half4 *read_imageh* ( +
  _aQual_ image3d_t _image_, +
  int4 _coord_ )
| Use the coordinate _(coord.x_, _coord.y_, _coord.z)_ to do an element
  lookup in the 3D image object specified by _image_. _coord.w_ is ignored.

  *read_imageh* returns half precision floating-point values in the range
  [0.0 ... 1.0] for image objects created with _image_channel_data_type_ set
  to one of the pre-defined packed formats or {CL_UNORM_INT8}, or
  {CL_UNORM_INT16}.

  *read_imageh* returns half precision floating-point values in the range
  [-1.0 ... 1.0] for image objects created with _image_channel_data_type_
  set to {CL_SNORM_INT8}, or {CL_SNORM_INT16}.

  *read_imageh* returns half precision floating-point values for image
  objects created with _image_channel_data_type_ set to {CL_HALF_FLOAT}.

  Values returned by *read_imageh* for image objects with
  _image_channel_data_type_ values not specified in the description are
  undefined.

| half4 *read_imageh* ( +
  _aQual_ image2d_array_t _image_, +
  int4 _coord_)
| Use _coord.xy_ to do an element lookup in the 2D image identified by
  _coord.z_ in the 2D image array specified by _image_.

  *read_imageh* returns half precision floating-point values in the range
  [0.0 ... 1.0] for image objects created with _image_channel_data_type_ set
  to one of the pre-defined packed formats or {CL_UNORM_INT8}, or
  {CL_UNORM_INT16}.

  *read_imageh* returns half precision floating-point values in the range
  [-1.0 ... 1.0] for image objects created with _image_channel_data_type_
  set to {CL_SNORM_INT8}, or {CL_SNORM_INT16}.

  *read_imageh* returns half precision floating-point values for image
  objects created with _image_channel_data_type_ set to {CL_HALF_FLOAT}.

  Values returned by *read_imageh* for image objects with
  _image_channel_data_type_ values not specified in the description above
  are undefined.

| half4 *read_imageh* ( +
  _aQual_ image1d_t _image_, +
  int _coord_)

  half4 *read_imageh* ( +
  _aQual_ image1d_buffer_t _image_, +
  int _coord_)
| Use _coord_ to do an element lookup in the 1D image or 1D image buffer
  object specified by _image_.

  *read_imageh* returns half precision floating-point values in the range
  [0.0 ... 1.0] for image objects created with _image_channel_data_type_ set
  to one of the pre-defined packed formats or {CL_UNORM_INT8}, or
  {CL_UNORM_INT16}.

  *read_imageh* returns half precision floating-point values in the range
  [-1.0 ... 1.0] for image objects created with _image_channel_data_type_
  set to {CL_SNORM_INT8}, or {CL_SNORM_INT16}.

  *read_imageh* returns half precision floating-point values for image
  objects created with _image_channel_data_type_ set to {CL_HALF_FLOAT}.

  Values returned by *read_imageh* for image objects with
  _image_channel_data_type_ values not specified in the description above
  are undefined.

| half4 *read_imageh* ( +
  _aQual_ image1d_array_t _image_, +
  int2 _coord_)
| Use _coord.x_ to do an element lookup in the 2D image identified by
  _coord.y_ in the 2D image array specified by _image_.

  *read_imageh* returns half precision floating-point values in the range
  [0.0 ... 1.0] for image objects created with _image_channel_data_type_ set
  to one of the pre-defined packed formats or {CL_UNORM_INT8}, or
  {CL_UNORM_INT16}.

  *read_imageh* returns half precision floating-point values in the range
  [-1.0 ... 1.0] for image objects created with _image_channel_data_type_
  set to {CL_SNORM_INT8}, or {CL_SNORM_INT16}.

  *read_imageh* returns half precision floating-point values for image
  objects created with _image_channel_data_type_ set to {CL_HALF_FLOAT}.

  Values returned by *read_imageh* for image objects with
  _image_channel_data_type_ values not specified in the description above
  are undefined.

|====

==== Built-in Image Write Functions

_aQual_ in Table 6.25 refers to one of the access qualifiers.
For write functions this may be _write_only_ or _read_write_.

._Half Precision Built-in Image Write Functions_
[cols=",",options="header",]
|====
| *Function*
| *Description*

| void *write_imageh* ( +
  _aQual_ image2d_t _image_, +
  int2 _coord_, +
  half4 _color_)
| Write _color_ value to location specified by _coord.xy_ in the 2D image
  specified by _image_.

  Appropriate data format conversion to the specified image format is done
  before writing the color value. _x_ & _y_ are considered to be
  unnormalized coordinates and must be in the range 0 ... width - 1, and 0
  ... height - 1.

  *write_imageh* can only be used with image objects created with
  _image_channel_data_type_ set to one of the pre-defined packed formats or
  set to {CL_SNORM_INT8}, {CL_UNORM_INT8}, {CL_SNORM_INT16}, {CL_UNORM_INT16} or
  {CL_HALF_FLOAT}.

  The behavior of *write_imageh* for image objects created with
  _image_channel_data_type_ values not specified in the description above or
  with (_x_, _y_) coordinate values that are not in the range (0 ... width -
  1, 0 ... height - 1) respectively, is undefined.

| void *write_imageh* ( +
  _aQual_ image2d_array_t _image_, +
  int4 _coord_, +
  half4 _color_)
| Write _color_ value to location specified by _coord.xy_ in the 2D image
  identified by _coord.z_ in the 2D image array specified by _image_.

  Appropriate data format conversion to the specified image format is done
  before writing the color value. _coord.x_, _coord.y_ and _coord.z_ are
  considered to be unnormalized coordinates and must be in the range 0 ...
  image width - 1, 0 ... image height - 1 and 0 ... image number of layers -
  1.

  *write_imageh* can only be used with image objects created with
  _image_channel_data_type_ set to one of the pre-defined packed formats or
  set to {CL_SNORM_INT8}, {CL_UNORM_INT8}, {CL_SNORM_INT16}, {CL_UNORM_INT16} or
  {CL_HALF_FLOAT}.

  The behavior of *write_imageh* for image objects created with
  _image_channel_data_type_ values not specified in the description above or
  with (_x_, _y, z_) coordinate values that are not in the range (0 ...
  image width - 1, 0 ... image height - 1, 0 ... image number of layers -
  1), respectively, is undefined.

| void *write_imageh* ( +
  _aQual_ image1d_t _image_, +
  int _coord_, +
  half4 _color_)

  void *write_imageh* ( +
  _aQual_ image1d_buffer_t _image_, +
  int _coord_, +
  half4 _color_)
| Write _color_ value to location specified by _coord_ in the 1D image or 1D
  image buffer object specified by _image_.
  Appropriate data format conversion to the specified image format is done
  before writing the color value.
  _coord_ is considered to be unnormalized coordinates and must be in the
  range 0 ... image width - 1.

  *write_imageh* can only be used with image objects created with
  _image_channel_data_type_ set to one of the pre-defined packed formats or
  set to {CL_SNORM_INT8}, {CL_UNORM_INT8}, {CL_SNORM_INT16}, {CL_UNORM_INT16} or
  {CL_HALF_FLOAT}.
  Appropriate data format conversion will be done to convert channel data
  from a floating-point value to actual data format in which the channels
  are stored.

  The behavior of *write_imageh* for image objects created with
  _image_channel_data_type_ values not specified in the description above or
  with coordinate values that is not in the range (0 ... image width - 1),
  is undefined.

| void *write_imageh* ( +
  _aQual_ image1d_array_t _image_, +
  int2 _coord_, +
  half4 _color_)
| Write _color_ value to location specified by _coord.x_ in the 1D image
  identified by _coord.y_ in the 1D image array specified by _image_.
  Appropriate data format conversion to the specified image format is done
  before writing the color value. _coord.x_ and _coord.y_ are considered to
  be unnormalized coordinates and must be in the range 0 ... image width - 1
  and 0 ... image number of layers - 1.

  *write_imageh* can only be used with image objects created with
  _image_channel_data_type_ set to one of the pre-defined packed formats or
  set to {CL_SNORM_INT8}, {CL_UNORM_INT8}, {CL_SNORM_INT16}, {CL_UNORM_INT16} or
  {CL_HALF_FLOAT}.
  Appropriate data format conversion will be done to convert channel data
  from a floating-point value to actual data format in which the channels
  are stored.

  The behavior of *write_imageh* for image objects created with
  _image_channel_data_type_ values not specified in the description above or
  with (_x_, _y_) coordinate values that are not in the range (0 ... image
  width - 1, 0 ... image number of layers - 1), respectively, is undefined.

| void *write_imageh* ( +
  _aQual_ image3d_t _image_, +
  int4 _coord_, +
  half4 _color_)
| Write color value to location specified by coord.xyz in the 3D image
  object specified by _image_.

  Appropriate data format conversion to the specified image format is done
  before writing the color value.
  coord.x, coord.y and coord.z are considered to be unnormalized coordinates
  and must be in the range 0 ... image width - 1, 0 ... image height - 1 and
  0 ... image depth - 1.

  *write_imageh* can only be used with image objects created with
  image_channel_data_type set to one of the pre-defined packed formats or
  set to {CL_SNORM_INT8}, {CL_UNORM_INT8}, {CL_SNORM_INT16}, {CL_UNORM_INT16} or
  {CL_HALF_FLOAT}.

  The behavior of *write_imageh* for image objects created with
  image_channel_data_type values not specified in the description above or
  with (x, y, z) coordinate values that are not in the range (0 ... image
  width - 1, 0 ... image height - 1, 0 ... image depth - 1), respectively,
  is undefined.

  Note: This built-in function is only available if the
  cl_khr_3d_image_writes extension is also supported by the device.

|====

[[cl_khr_fp16-ieee754-compliance]]
==== IEEE754 Compliance

The following table entry describes the additions to _table 4.3,_ which
allows applications to query the configuration information using
{clGetDeviceInfo} for an OpenCL device that supports half precision
floating-point.

[cols="1,1,2",options="header",]
|====
| *Op-code*
| *Return Type*
| *Description*

| {CL_DEVICE_HALF_FP_CONFIG}
| {cl_device_fp_config_TYPE}
| Describes half precision floating-point capability of the OpenCL device.
  This is a bit-field that describes one or more of the following values:

  {CL_FP_DENORM} -- denorms are supported

  {CL_FP_INF_NAN} -- INF and NaNs are supported

  {CL_FP_ROUND_TO_NEAREST} -- round to nearest even rounding mode supported

  {CL_FP_ROUND_TO_ZERO} -- round to zero rounding mode supported

  {CL_FP_ROUND_TO_INF} -- round to positive and negative infinity rounding
  modes supported

  {CL_FP_FMA} -- IEEE754-2008 fused multiply-add is supported

  {CL_FP_SOFT_FLOAT} -- Basic floating-point operations (such as addition,
  subtraction, multiplication) are implemented in software.

  The required minimum half precision floating-point capability as
  implemented by this extension is:

  {CL_FP_ROUND_TO_ZERO}, or {CL_FP_ROUND_TO_NEAREST} \| {CL_FP_INF_NAN}.

|====

[[cl_khr_fp16-rounding-modes]]
==== Rounding Modes

If {CL_FP_ROUND_TO_NEAREST} is supported, the default rounding mode for
half-precision floating-point operations will be round to nearest even;
otherwise the default rounding mode will be round to zero.

Conversions to half floating-point format must be correctly rounded using
the indicated `convert` operator rounding mode or the default rounding mode
for half-precision floating-point operations if no rounding mode is
specified by the operator, or a C-style cast is used.

Conversions from half to integer format shall correctly round using the
indicated `convert` operator rounding mode, or towards zero if no rounding
mode is specified by the operator or a C-style cast is used.
All conversions from half to floating-point formats are exact.

[[cl_khr_fp16-relative-error-as-ulps]]
==== Relative Error as ULPs

In this section we discuss the maximum relative error defined as _ulp_
(units in the last place).

Addition, subtraction, multiplication, fused multiply-add operations on half
types are required to be correctly rounded using the default rounding mode
for half-precision floating-point operations.

The following table describes the minimum accuracy of half precision
floating-point arithmetic operations given as ULP values.
0 ULP is used for math functions that do not require rounding.
The reference value used to compute the ULP value of an arithmetic operation
is the infinitely precise result.

._ULP Values for Half Precision Floating-Point Arithmetic Operations_
[cols=",,",options="header",]
|====
| *Function*
| *Min Accuracy - Full Profile*
| *Min Accuracy - Embedded Profile*

| *_x_ + _y_*
| Correctly rounded
| Correctly rounded

| *_x_ - _y_*
| Correctly rounded
| Correctly rounded

| *_x_ * _y_*
| Correctly rounded
| Correctly rounded

| *1.0 / _x_*
| Correctly rounded
| \<= 1 ulp

| *_x_ / _y_*
| Correctly rounded
| \<= 1 ulp

| | |

| *acos*
| \<= 2 ulp
| \<= 3 ulp

| *acosh*
| \<= 2 ulp
| \<= 3 ulp

| *acospi*
| \<= 2 ulp
| \<= 3 ulp

| *asin*
| \<= 2 ulp
| \<= 3 ulp

| *asinh*
| \<= 2 ulp
| \<= 3 ulp

| *asinpi*
| \<= 2 ulp
| \<= 3 ulp

| *atan*
| \<= 2 ulp
| \<= 3 ulp

| *atanh*
| \<= 2 ulp
| \<= 3 ulp

| *atanpi*
| \<= 2 ulp
| \<= 3 ulp

| *atan2*
| \<= 2 ulp
| \<= 3 ulp

| *atan2pi*
| \<= 2 ulp
| \<= 3 ulp

| *cbrt*
| \<= 2 ulp
| \<= 2 ulp

| *ceil*
| Correctly rounded
| Correctly rounded

| *clamp*
| 0 ulp
| 0 ulp

| *copysign*
| 0 ulp
| 0 ulp

| *cos*
| \<= 2 ulp
| \<= 2 ulp

| *cosh*
| \<= 2 ulp
| \<= 3 ulp

| *cospi*
| \<= 2 ulp
| \<= 2 ulp

// 3 operations from the 2 multiplications and 1 subtraction per component
| *cross*
| absolute error tolerance of 'max * max * (3 * HALF_EPSILON)' per vector component, where _max_ is the maximum input operand magnitude
| Implementation-defined

| *degrees*
| \<= 2 ulp
| \<= 2 ulp

// 0.5         ULP error in sqrt
// 1.5 * n     cumulative error for multiplications
// 0.5 * (n-1) cumulative error for additions
//
// = 0.5 + (1.5 * n) + (0.5 * (n - 1))
// = 0.5 + 1.5n + (0.5n - 0.5)
// = 2n
| *distance*
| \<= 2n ulp, for gentype with vector width _n_
| Implementation-defined

// n + n-1  Number of operations from n multiples and (n-1) additions
// 2n - 1
| *dot*
| absolute error tolerance of 'max * max * (2n - 1) * HALF_EPSILON', for vector width _n_ and maximum input operand magnitude _max_ across all vector components
| Implementation-defined

| *erfc*
| \<= 4 ulp
| \<= 4 ulp

| *erf*
| \<= 4 ulp
| \<= 4 ulp

| *exp*
| \<= 2 ulp
| \<= 3 ulp

| *exp2*
| \<= 2 ulp
| \<= 3 ulp

| *exp10*
| \<= 2 ulp
| \<= 3 ulp

| *expm1*
| \<= 2 ulp
| \<= 3 ulp

| *fabs*
| 0 ulp
| 0 ulp

| *fdim*
| Correctly rounded
| Correctly rounded

| *floor*
| Correctly rounded
| Correctly rounded

| *fma*
| Correctly rounded
| Correctly rounded

| *fmax*
| 0 ulp
| 0 ulp

| *fmin*
| 0 ulp
| 0 ulp

| *fmod*
| 0 ulp
| 0 ulp

| *fract*
| Correctly rounded
| Correctly rounded

| *frexp*
| 0 ulp
| 0 ulp

| *hypot*
| \<= 2 ulp
| \<= 3 ulp

| *ilogb*
| 0 ulp
| 0 ulp

| *ldexp*
| Correctly rounded
| Correctly rounded

// 0.5         ULP error in sqrt
// 0.5         effect on e of taking sqrt(x + e)
// 0.5 * n     cumulative error for multiplications
// 0.5 * (n-1) cumulative error for additions
//
// = (0.5 + 0.5 * ((0.5 * n) + (0.5 * (n - 1))))
// = 0.5 + 0.5 * (n - 0.5)
// = 0.25 + 0.5n
| *length*
| \<= 0.25 + 0.5n ulp, for gentype with vector width _n_
| Implementation-defined

| *log*
| \<= 2 ulp
| \<= 3 ulp

| *log2*
| \<= 2 ulp
| \<= 3 ulp

| *log10*
| \<= 2 ulp
| \<= 3 ulp

| *log1p*
| \<= 2 ulp
| \<= 3 ulp

| *logb*
| 0 ulp
| 0 ulp

| *mad*
| Implementation-defined
| Implementation-defined

| *max*
| 0 ulp
| 0 ulp

| *maxmag*
| 0 ulp
| 0 ulp

| *min*
| 0 ulp
| 0 ulp

| *minmag*
| 0 ulp
| 0 ulp

| *mix*
| Implementation-defined
| Implementation-defined

| *modf*
| 0 ulp
| 0 ulp

| *nan*
| 0 ulp
| 0 ulp

| *nextafter*
| 0 ulp
| 0 ulp

// 1.5         error in rsqrt + error in multiply
// 0.5 * n     cumulative error for multiplications
// 0.5 * (n-1) cumulative error for additions
//
// = 1.5 + (0.5 * n) + (0.5 * (n - 1))
// = 1.5 + 0.5n + (0.5n - 0.5)
// = 1.0 + n
| *normalize*
| \<= 1 + n ulp, for gentype with vector width _n_
| Implementation-defined

| *pow(x, y)*
| \<= 4 ulp
| \<= 5 ulp

| *pown(x, y)*
| \<= 4 ulp
| \<= 5 ulp

| *powr(x, y)*
| \<= 4 ulp
| \<= 5 ulp

| *radians*
| \<= 2 ulp
| \<= 2 ulp

| *remainder*
| 0 ulp
| 0 ulp

| *remquo*
| 0 ulp for the remainder, at least the lower 7 bits of the integral quotient
| 0 ulp for the remainder, at least the lower 7 bits of the integral quotient

| *rint*
| Correctly rounded
| Correctly rounded

| *rootn*
| \<= 4 ulp
| \<= 5 ulp

| *round*
| Correctly rounded
| Correctly rounded

| *rsqrt*
| \<=1 ulp
| \<=1 ulp

| *sign*
| 0 ulp
| 0 ulp

| *sin*
| \<= 2 ulp
| \<= 2 ulp

| *sincos*
| \<= 2 ulp for sine and cosine values
| \<= 2 ulp for sine and cosine values

| *sinh*
| \<= 2 ulp
| \<= 3 ulp

| *sinpi*
| \<= 2 ulp
| \<= 2 ulp

| *smoothstep*
| Implementation-defined
| Implementation-defined

| *sqrt*
| Correctly rounded
| \<= 1 ulp

| *step*
| 0 ulp
| 0 ulp

| *tan*
| \<= 2 ulp
| \<= 3 ulp

| *tanh*
| \<= 2 ulp
| \<= 3 ulp

| *tanpi*
| \<= 2 ulp
| \<= 3 ulp

| *tgamma*
| \<= 4 ulp
| \<= 4 ulp

| *trunc*
| Correctly rounded
| Correctly rounded

|====

Note: _Implementations may perform floating-point operations on_ `half`
_scalar or vector data types by converting the_ `half` _values to single
precision floating-point values and performing the operation in single
precision floating-point.
In this case, the implementation will use the_ `half` _scalar or vector data
type as a storage only format_.

[[cl_khr_fp16-additions-to-chapter-8-of-the-opencl-2.0-specification]]
=== Additions to Chapter 8 of the OpenCL 2.0 C Specification

Add new sub-sections to _section 8.3.1. Conversion rules for normalized integer channel data types_:

[[cl_khr_fp16-converting-normalized-integer-channel-data-types-to-floating-point-values]]
==== Converting normalized integer channel data types to half precision floating-point values

For images created with image channel data type of {CL_UNORM_INT8} and
{CL_UNORM_INT16}, *read_imagef* will convert the channel values from an
8-bit or 16-bit unsigned integer to normalized half precision
floating-point values in the range [`0.0h`, `1.0h`].

For images created with image channel data type of {CL_SNORM_INT8} and
{CL_SNORM_INT16}, *read_imagef* will convert the channel values from an
8-bit or 16-bit signed integer to normalized half precision floating-point
values in the range [`-1.0h`, `1.0h`].

These conversions are performed as follows:

{CL_UNORM_INT8} (8-bit unsigned integer) {rightarrow} `half`

[none]
* normalized `half` value = `round_to_half(c / 255)`

{CL_UNORM_INT_101010} (10-bit unsigned integer) {rightarrow} `half`

[none]
* normalized `half` value = `round_to_half(c / 1023)`

{CL_UNORM_INT16} (16-bit unsigned integer) {rightarrow} `half`

[none]
* normalized `half` value = `round_to_half(c / 65535)`

{CL_SNORM_INT8} (8-bit signed integer) {rightarrow} `half`

[none]
* normalized `half` value = `max(-1.0h, round_to_half(c / 127))`

{CL_SNORM_INT16} (16-bit signed integer) {rightarrow} `half`

[none]
* normalized `half` value = `max(-1.0h, round_to_half(c / 32767))`

The accuracy of the above conversions must be \<= 1.5 ulp except for the
following cases.

For {CL_UNORM_INT8}

[none]
* 0 must convert to `0.0h` and
* 255 must convert to `1.0h`

For {CL_UNORM_INT_101010}

[none]
* 0 must convert to `0.0h` and
* 1023 must convert to `1.0h`

For {CL_UNORM_INT16}

[none]
* 0 must convert to `0.0h` and
* 65535 must convert to `1.0h`

For {CL_SNORM_INT8}

[none]
* -128 and -127 must convert to `-1.0h`,
* 0 must convert to `0.0h` and
* 127 must convert to `1.0h`

For {CL_SNORM_INT16}

[none]
* -32768 and -32767 must convert to `-1.0h`,
* 0 must convert to `0.0h` and
* 32767 must convert to `1.0h`


[[cl_khr_fp16-converting-floating-point-values-to-normalized-integer-channel-data-types]]
==== Converting half precision floating-point values to normalized integer channel data types

For images created with image channel data type of {CL_UNORM_INT8} and
{CL_UNORM_INT16}, *write_imagef* will convert the floating-point color value
to an 8-bit or 16-bit unsigned integer.

For images created with image channel data type of {CL_SNORM_INT8} and
{CL_SNORM_INT16}, *write_imagef* will convert the floating-point color value
to an 8-bit or 16-bit signed integer.

The preferred conversion uses the round to nearest even (`_rte`) rounding
mode, but OpenCL implementations may choose to approximate the rounding mode
used in the conversions described below.
When approximate rounding is used instead of the preferred rounding,
the result of the conversion must satisfy the bound given below.

`half` {rightarrow} {CL_UNORM_INT8} (8-bit unsigned integer)

[none]
* Let f~exact~ = *max*(`0`, *min*(`f * 255`, `255`))
* Let f~preferred~ = *convert_uchar_sat_rte*(`f * 255.0f`)
* Let f~approx~ = *convert_uchar_sat_<impl-rounding-mode>*(`f * 255.0f`)
* *fabs*(f~exact~ - f~approx~) must be \<= 0.6

`half` {rightarrow} {CL_UNORM_INT_101010} (10-bit unsigned integer)

[none]
* Let f~exact~ = *max*(`0`, *min*(`f * 1023`, `1023`))
* Let f~preferred~ = *min*(*convert_ushort_sat_rte*(`f * 1023.0f`), `1023`)
* Let f~approx~ = *convert_ushort_sat_<impl-rounding-mode>*(`f * 1023.0f`)
* *fabs*(f~exact~ - f~approx~) must be \<= 0.6

`half` {rightarrow} {CL_UNORM_INT16} (16-bit unsigned integer)

[none]
* Let f~exact~ = *max*(`0`, *min*(`f * 65535`, `65535`))
* Let f~preferred~ = *convert_ushort_sat_rte*(`f * 65535.0f`)
* Let f~approx~ = *convert_ushort_sat_<impl-rounding-mode>*(`f * 65535.0f`)
* *fabs*(f~exact~ - f~approx~) must be \<= 0.6

`half` {rightarrow} {CL_SNORM_INT8} (8-bit signed integer)

[none]
* Let f~exact~ = *max*(`-128`, *min*(`f * 127`, `127`))
* Let f~preferred~ = *convert_char_sat_rte*(`f * 127.0f`)
* Let f~approx~ = *convert_char_sat_<impl_rounding_mode>*(`f * 127.0f`)
* *fabs*(f~exact~ - f~approx~) must be \<= 0.6

`half` {rightarrow} {CL_SNORM_INT16} (16-bit signed integer)

[none]
* Let f~exact~ = *max*(`-32768`, *min*(`f * 32767`, `32767`))
* Let f~preferred~ = *convert_short_sat_rte*(`f * 32767.0f`)
* Let f~approx~ = *convert_short_sat_<impl-rounding-mode>*(`f * 32767.0f`)
* *fabs*(f~exact~ - f~approx~) must be \<= 0.6
