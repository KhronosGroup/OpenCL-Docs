== Extended Subgroup Functions

[[extended-subgroups]]
=== Overview

This section describes a family of extensions that provide extended subgroup functionality.
The extensions in this family are:

* `cl_khr_subgroup_extended_types`
* `cl_khr_subgroup_non_uniform_vote`
* `cl_khr_subgroup_ballot`
* `cl_khr_subgroup_non_uniform_arithmetic`
* `cl_khr_subgroup_shuffle`
* `cl_khr_subgroup_shuffle_relative`
* `cl_khr_subgroup_clustered_reduce`

The functionality added by these extensions includes:

* Additional data type support for subgroup broadcast, scan, and reduction functions;
* The ability to elect a single work item from a subgroup to perform a task;
* The ability to hold votes among work items in a subgroup;
* The ability to collect and operate on ballots from work items in the subgroup;
* The ability to use some subgroup functions, such as any, all, broadcasts, scans, and reductions within non-uniform flow control;
* Additional scan and reduction operators;
* Additional ways to exchange data among work items in a subgroup;
* Clustered reductions, that operate on a subset of work items in the subgroup.

This section describes changes to the OpenCL C Language for these extensions.
There are no new API functions or enums added by these extensions.

=== General information

==== Version history

For all of the extensions described in this section:

[cols="1,1,3",options="header",]
|====
| *Date*     | *Version* | *Description*
| 2020-12-15 | 1.0.0     | First assigned version.
|====

[[extended-subgroups-summary]]
=== Summary of New OpenCL C Functions

[source,opencl_c]
----
// These functions are available to devices supporting
// cl_khr_subgroup_extended_types:

// Note: Existing functions supporting additional data types.

gentype sub_group_broadcast( gentype value, uint index )

gentype sub_group_reduce_add( gentype value )
gentype sub_group_reduce_min( gentype value )
gentype sub_group_reduce_max( gentype value )

gentype sub_group_scan_inclusive_add( gentype value )
gentype sub_group_scan_inclusive_min( gentype value )
gentype sub_group_scan_inclusive_max( gentype value )

gentype sub_group_scan_exclusive_add( gentype value )
gentype sub_group_scan_exclusive_min( gentype value )
gentype sub_group_scan_exclusive_max( gentype value )

// These functions are available to devices supporting
// cl_khr_subgroup_non_uniform_vote:

int sub_group_elect()

int sub_group_non_uniform_all( int predicate )
int sub_group_non_uniform_any( int predicate )
int sub_group_non_uniform_all_equal( gentype value )

// These functions are available to devices supporting
// cl_khr_subgroup_ballot:

gentype sub_group_non_uniform_broadcast( gentype value, uint index )
gentype sub_group_broadcast_first( gentype value )

uint4 sub_group_ballot( int predicate )
int   sub_group_inverse_ballot( uint4 value )
int   sub_group_ballot_bit_extract( uint4 value, uint index )
uint  sub_group_ballot_bit_count( uint4 value )
uint  sub_group_ballot_inclusive_scan( uint4 value )
uint  sub_group_ballot_exclusive_scan( uint4 value )
uint  sub_group_ballot_find_lsb( uint4 value )
uint  sub_group_ballot_find_msb( uint4 value )

uint4 get_sub_group_eq_mask()
uint4 get_sub_group_ge_mask()
uint4 get_sub_group_gt_mask()
uint4 get_sub_group_le_mask()
uint4 get_sub_group_lt_mask()

// These functions are available to devices supporting
// cl_khr_subgroup_non_uniform_arithmetic:

gentype sub_group_non_uniform_reduce_add( gentype value )
gentype sub_group_non_uniform_reduce_mul( gentype value )
gentype sub_group_non_uniform_reduce_min( gentype value )
gentype sub_group_non_uniform_reduce_max( gentype value )
gentype sub_group_non_uniform_reduce_and( gentype value )
gentype sub_group_non_uniform_reduce_or( gentype value )
gentype sub_group_non_uniform_reduce_xor( gentype value )
int     sub_group_non_uniform_reduce_logical_and( int predicate )
int     sub_group_non_uniform_reduce_logical_or( int predicate )
int     sub_group_non_uniform_reduce_logical_xor( int predicate )

gentype sub_group_non_uniform_scan_inclusive_add( gentype value )
gentype sub_group_non_uniform_scan_inclusive_mul( gentype value )
gentype sub_group_non_uniform_scan_inclusive_min( gentype value )
gentype sub_group_non_uniform_scan_inclusive_max( gentype value )
gentype sub_group_non_uniform_scan_inclusive_and( gentype value )
gentype sub_group_non_uniform_scan_inclusive_or( gentype value )
gentype sub_group_non_uniform_scan_inclusive_xor( gentype value )
int     sub_group_non_uniform_scan_inclusive_logical_and( int predicate )
int     sub_group_non_uniform_scan_inclusive_logical_or( int predicate )
int     sub_group_non_uniform_scan_inclusive_logical_xor( int predicate )

gentype sub_group_non_uniform_scan_exclusive_add( gentype value )
gentype sub_group_non_uniform_scan_exclusive_mul( gentype value )
gentype sub_group_non_uniform_scan_exclusive_min( gentype value )
gentype sub_group_non_uniform_scan_exclusive_max( gentype value )
gentype sub_group_non_uniform_scan_exclusive_and( gentype value )
gentype sub_group_non_uniform_scan_exclusive_or( gentype value )
gentype sub_group_non_uniform_scan_exclusive_xor( gentype value )
int     sub_group_non_uniform_scan_exclusive_logical_and( int predicate )
int     sub_group_non_uniform_scan_exclusive_logical_or( int predicate )
int     sub_group_non_uniform_scan_exclusive_logical_xor( int predicate )

// These functions are available to devices supporting
// cl_khr_subgroup_shuffle:

gentype sub_group_shuffle( gentype value, uint index )
gentype sub_group_shuffle_xor( gentype value, uint mask )

// These functions are available to devices supporting
// cl_khr_subgroup_shuffle_relative:

gentype sub_group_shuffle_up( gentype value, uint delta )
gentype sub_group_shuffle_down( gentype value, uint delta )

// These functions are available to devices supporting
// cl_khr_subgroup_clustered_reduce:

gentype sub_group_clustered_reduce_add( gentype value, uint clustersize )
gentype sub_group_clustered_reduce_mul( gentype value, uint clustersize )
gentype sub_group_clustered_reduce_min( gentype value, uint clustersize )
gentype sub_group_clustered_reduce_max( gentype value, uint clustersize )
gentype sub_group_clustered_reduce_and( gentype value, uint clustersize )
gentype sub_group_clustered_reduce_or( gentype value, uint clustersize )
gentype sub_group_clustered_reduce_xor( gentype value, uint clustersize )
int     sub_group_clustered_reduce_logical_and( int predicate, uint clustersize )
int     sub_group_clustered_reduce_logical_or( int predicate, uint clustersize )
int     sub_group_clustered_reduce_logical_xor( int predicate, uint clustersize )
----

[[cl_khr_subgroup_extended_types]]
=== Extended Types

This section describes functionality added by `cl_khr_subgroup_extended_types`.
This extension adds additional supported data types to the existing subgroup broadcast, scan, and reduction functions.

==== Modify the Existing Section Describing Subgroup Functions

Modify the first paragraph in this section that describes `gentype` type support for the subgroup `broadcast`, `scan`, and `reduction` functions to add scalar `char`, `uchar`, `short`, and `ushort` support, and to additionally add built-in vector type support for `broadcast` specifically.
The functions in the table and their descriptions remain unchanged by this extension:

The table below describes OpenCL C programming language built-in functions that operate on a subgroup level.
These built-in functions must be encountered by all work items in the subgroup executing the kernel.
We use the generic type name `gentype` to indicate the built-in scalar data types `char`, `uchar`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double` (if double precision is supported), or `half` (if half precision is supported).

For the `sub_group_broadcast` function, the generic type name `gentype` may additionally be one of the supported built-in vector data types `char__n__`, `uchar__n__`, `short__n__`, `ushort__n__`, `int__n__`, `uint__n__`, `long__n__`, `ulong__n__`, `float__n__`, `double__n__` (if double precision is supported), or `half__n__` (if half precision is supported).

[[cl_khr_subgroup_non_uniform_vote]]
=== Votes and Elections

This section describes functionality added by `cl_khr_subgroup_non_uniform_vote`.
This extension adds the ability to elect a single work item from a subgroup to perform a task and to hold votes among work items in a subgroup.

==== Add a new Section 6.15.X - Subgroup Vote and Elect Built-in Functions

The table below describes the OpenCL C programming language built-in functions to elect a single work item in a subgroup to perform a task and to collectively vote to determine a boolean condition for the subgroup.
These functions need not be encountered by all work items in a subgroup executing the kernel.
For the functions below, the generic type name `gentype` may be the one of the supported built-in scalar data types `char`, `uchar`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double` (if double precision is supported), or `half` (if half precision is supported).

[cols="1a,1",options="header",]
|=======================================================================
|*Function*
|*Description*

|[source,opencl_c]
----
int sub_group_elect()
----
| Elects a single work item in the subgroup to perform a task.
This function will return true (nonzero) for the active work item in the subgroup with the smallest subgroup local ID, and false (zero) for all other active work items in the subgroup.

|[source,opencl_c]
----
int sub_group_non_uniform_all(
    int predicate )
----
| Examines _predicate_ for all active work items in the subgroup and returns a non-zero value if _predicate_ is non-zero for all active work items in the subgroup and zero otherwise.

Note: This behavior is the same as `sub_group_all` from `cl_khr_subgroups` and OpenCL 2.1, except this function need not be encountered by all work items in the subgroup executing the kernel.

|[source,opencl_c]
----
int sub_group_non_uniform_any(
    int predicate )
----
| Examines _predicate_ for all active work items in the subgroup and returns a non-zero value if _predicate_ is non-zero for any active work item in the subgroup and zero otherwise.

Note: This behavior is the same as `sub_group_any` from `cl_khr_subgroups` and OpenCL 2.1, except this function need not be encountered by all work items in the subgroup executing the kernel.

|[source,opencl_c]
----
int sub_group_non_uniform_all_equal(
    gentype value )
----
| Examines _value_ for all active work items in the subgroup and returns a non-zero value if _value_ is equivalent for all active invocations in the subgroup and zero otherwise.

Integer types use a bitwise test for equality.  Floating-point types use an ordered floating-point test for equality.

|=======================================================================

[[cl_khr_subgroup_ballot]]
=== Ballots

This section describes functionality added by `cl_khr_subgroup_ballot`.
This extension adds the ability to collect and operate on ballots from work items in the subgroup.

==== Add a new Section 6.15.X - Subgroup Ballot Built-in Functions

The table below describes the OpenCL C programming language built-in functions to allow work items in a subgroup to collect and operate on ballots from work items in the subgroup.
These functions need not be encountered by all work items in a subgroup executing the kernel.

For the `sub_group_non_uniform_broadcast` and `sub_group_broadcast_first` functions, the generic type name `gentype` may be one of the supported built-in scalar data types `char`, `uchar`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double` (if double precision is supported), or `half` (if half precision is supported).

For the `sub_group_non_uniform_broadcast` function, the generic type name `gentype` may additionally be one of the supported built-in vector data types `char__n__`, `uchar__n__`, `short__n__`, `ushort__n__`, `int__n__`, `uint__n__`, `long__n__`, `ulong__n__`, `float__n__`, `double__n__` (if double precision is supported), or `half__n__` (if half precision is supported).

[cols="1a,1",options="header",]
|=======================================================================
|*Function*
|*Description*

|[source,opencl_c]
----
gentype sub_group_non_uniform_broadcast(
    gentype value,
    uint index )
----
| Returns _value_ for the work item with subgroup local ID equal to _index_.

Behavior is undefined when the value of _index_ is not equivalent for all active work items in the subgroup.

The return value is undefined if the work item with subgroup local ID equal to _index_ is inactive or if _index_ is greater than or equal to the size of the subgroup.

|[source,opencl_c]
----
gentype sub_group_broadcast_first(
    gentype value )
----
| Returns _value_ for the work item with the smallest subgroup local ID among active work items in the subgroup.

|[source,opencl_c]
----
uint4 sub_group_ballot(
    int predicate )
----
| Returns a bitfield combining the _predicate_ values from all work items in the subgroup.
Bit zero of the first vector component represents the subgroup local ID zero, with higher-order bits and subsequent vector components representing, in order, increasing subgroup local IDs.
The representative bit in the bitfield is set if the work item is active and the _predicate_ is non-zero, and is unset otherwise.

|[source,opencl_c]
----
int sub_group_inverse_ballot(
    uint4 value )
----
| Returns the predicate value for this work item in the subgroup from the bitfield _value_ representing predicate values from all work items in the subgroup.
The predicate return value will be non-zero if the bit in the bitfield _value_ for this work item is set, and zero otherwise.

Behavior is undefined when _value_ is not equivalent for all active work items in the subgroup.

This is a specialized function that may perform better than the equivalent `sub_group_ballot_bit_extract` on some implementations.

|[source,opencl_c]
----
int sub_group_ballot_bit_extract(
    uint4 value,
    uint index )
----
| Returns the predicate value for the work item with subgroup local ID equal to _index_ from the bitfield _value_ representing predicate values from all work items in the subgroup.
The predicate return value will be non-zero if the bit in the bitfield _value_ for the work item with subgroup local ID equal to _index_ is set, and zero otherwise.

The predicate return value is undefined if the work item with subgroup local ID equal to _index_ is greater than or equal to the size of the subgroup.

|[source,opencl_c]
----
uint sub_group_ballot_bit_count(
    uint4 value )
----
| Returns the number of bits that are set in the bitfield _value_, only considering the bits in _value_ that represent predicate values corresponding to subgroup local IDs less than the maximum subgroup size within the dispatch (as returned by `get_max_sub_group_size`).

|[source,opencl_c]
----
uint sub_group_ballot_inclusive_scan(
    uint4 value )
----
| Returns the number of bits that are set in the bitfield _value_, only considering the bits in _value_ representing work items with a subgroup local ID less than or equal to this work item's subgroup local ID.

|[source,opencl_c]
----
uint sub_group_ballot_exclusive_scan(
    uint4 value )
----
| Returns the number of bits that are set in the bitfield _value_, only considering the bits in _value_ representing work items with a subgroup local ID less than this work item's subgroup local ID.

|[source,opencl_c]
----
uint sub_group_ballot_find_lsb(
    uint4 value )
----
| Returns the smallest subgroup local ID with a bit set in the bitfield _value_, only considering the bits in _value_ that represent predicate values corresponding to subgroup local IDs less than the maximum subgroup size within the dispatch (as returned by `get_max_sub_group_size`).
If no bits representing predicate values from all work items in the subgroup are set in the bitfield _value_ then the return value is undefined.

|[source,opencl_c]
----
uint sub_group_ballot_find_msb(
    uint4 value )
----
| Returns the largest subgroup local ID with a bit set in the bitfield _value_, only considering the bits in _value_ that represent predicate values corresponding to subgroup local IDs less than the maximum subgroup size within the dispatch (as returned by `get_max_sub_group_size`).
If no bits representing predicate values from all work items in the subgroup are set in the bitfield _value_ then the return value is undefined.

|[source,opencl_c]
----
uint4 get_sub_group_eq_mask()
----
| Generates a bitmask where the bit is set in the bitmask if the bit index equals the subgroup local ID and unset otherwise.
Bit zero of the first vector component represents the subgroup local ID zero, with higher-order bits and subsequent vector components representing, in order, increasing subgroup local IDs.

|[source,opencl_c]
----
uint4 get_sub_group_ge_mask()
----
| Generates a bitmask where the bit is set in the bitmask if the bit index is greater than or equal to the subgroup local ID and less than the maximum subgroup size, and unset otherwise.
Bit zero of the first vector component represents the subgroup local ID zero, with higher-order bits and subsequent vector components representing, in order, increasing subgroup local IDs.

|[source,opencl_c]
----
uint4 get_sub_group_gt_mask()
----
| Generates a bitmask where the bit is set in the bitmask if the bit index is greater than the subgroup local ID and less than the maximum subgroup size, and unset otherwise.
Bit zero of the first vector component represents the subgroup local ID zero, with higher-order bits and subsequent vector components representing, in order, increasing subgroup local IDs.

|[source,opencl_c]
----
uint4 get_sub_group_le_mask()
----
| Generates a bitmask where the bit is set in the bitmask if the bit index is less than or equal to the subgroup local ID and unset otherwise.
Bit zero of the first vector component represents the subgroup local ID zero, with higher-order bits and subsequent vector components representing, in order, increasing subgroup local IDs.

|[source,opencl_c]
----
uint4 get_sub_group_lt_mask()
----
| Generates a bitmask where the bit is set in the bitmask if the bit index is less than the subgroup local ID and unset otherwise.
Bit zero of the first vector component represents the subgroup local ID zero, with higher-order bits and subsequent vector components representing, in order, increasing subgroup local IDs.

|=======================================================================

[[cl_khr_subgroup_non_uniform_arithmetic]]
=== Non-Uniform Arithmetic
 
This section describes functionality added by `cl_khr_subgroup_non_uniform_arithmetic`.
This extension adds the ability to use some subgroup functions within non-uniform flow control, including additional scan and reduction operators.

==== Add a new Section 6.15.X - Non Uniform Subgroup Scan and Reduction Built-in Functions

===== Arithmetic Operations

The table below describes the OpenCL C programming language built-in functions that perform simple arithmetic operations across work items in a subgroup.
These functions need not be encountered by all work items in a subgroup executing the kernel.
For the functions below, the generic type name `gentype` may be one of the supported built-in scalar data types `char`, `uchar`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double` (if double precision is supported), or `half` (if half precision is supported).

[cols="3a,2",options="header",]
|=======================================================================
|*Function*
|*Description*

|[source,opencl_c]
----
gentype sub_group_non_uniform_reduce_add(
    gentype value )
gentype sub_group_non_uniform_reduce_min(
    gentype value )
gentype sub_group_non_uniform_reduce_max(
    gentype value )
gentype sub_group_non_uniform_reduce_mul(
    gentype value )
----
| Returns the summation, multiplication, minimum, or maximum of _value_ for all active work items in the subgroup.

Note: This behavior is the same as the *add*, *min*, and *max* reduction built-in functions from `cl_khr_subgroups` and OpenCL 2.1, except these functions support additional types and need not be encountered by all work items in the subgroup executing the kernel.

|[source,opencl_c]
----
gentype sub_group_non_uniform_scan_inclusive_add(
    gentype value )
gentype sub_group_non_uniform_scan_inclusive_min(
    gentype value )
gentype sub_group_non_uniform_scan_inclusive_max(
    gentype value )
gentype sub_group_non_uniform_scan_inclusive_mul(
    gentype value )
----
| Returns the result of an inclusive scan operation, which is the summation, multiplication, minimum, or maximum of _value_ for all active work items in the subgroup with a subgroup local ID less than or equal to this work item's subgroup local ID.

Note: This behavior is the same as the *add*, *min*, and *max* inclusive scan built-in functions from `cl_khr_subgroups` and OpenCL 2.1, except these functions support additional types and need not be encountered by all work items in the subgroup executing the kernel.

|[source,opencl_c]
----
gentype sub_group_non_uniform_scan_exclusive_add(
    gentype value )
gentype sub_group_non_uniform_scan_exclusive_min(
    gentype value )
gentype sub_group_non_uniform_scan_exclusive_max(
    gentype value )
gentype sub_group_non_uniform_scan_exclusive_mul(
    gentype value )
----
| Returns the result of an exclusive scan operation, which is the summation, multiplication, minimum, or maximum of _value_ for all active work items in the subgroup with a subgroup local ID less than this work item's subgroup local ID.

If there is no active work item in the subgroup with a subgroup local ID less than this work item's subgroup local ID then an identity value `I` is returned.
For *add*, the identity value is `0`.
For *min*, the identity value is the largest representable value for integer types, or `+INF` for floating point types.
For *max*, the identity value is the minimum representable value for integer types, or `-INF` for floating point types.
For *mul*, the identity value is `1`.

Note: This behavior is the same as the *add*, *min*, and *max* exclusive scan built-in functions from `cl_khr_subgroups` and OpenCL 2.1, except these functions support additional types and need not be encountered by all work items in the subgroup executing the kernel.

|=======================================================================

Note: The order of floating-point operations is not guaranteed for the subgroup scan and reduction built-in functions that operate on floating point types, and the order of operations may additionally be non-deterministic for a given subgroup.

===== Bitwise Operations

The table below describes the OpenCL C programming language built-in functions that perform simple bitwise integer operations across work items in a subgroup.
These functions need not be encountered by all work items in a subgroup executing the kernel.
For the functions below, the generic type name `gentype` may be one of the supported built-in scalar data types `char`, `uchar`, `short`, `ushort`, `int`, `uint`, `long`, and `ulong`.

[cols="3a,2",options="header",]
|=======================================================================
|*Function*
|*Description*

|[source,opencl_c]
----
gentype sub_group_non_uniform_reduce_and(
    gentype value )
gentype sub_group_non_uniform_reduce_or(
    gentype value )
gentype sub_group_non_uniform_reduce_xor(
    gentype value )
----
| Returns the bitwise *and*, *or*, or *xor* of _value_ for all active work items in the subgroup.

|[source,opencl_c]
----
gentype sub_group_non_uniform_scan_inclusive_and(
    gentype value )
gentype sub_group_non_uniform_scan_inclusive_or(
    gentype value )
gentype sub_group_non_uniform_scan_inclusive_xor(
    gentype value )
----
| Returns the result of an inclusive scan operation, which is the bitwise *and*, *or*, or *xor* of _value_ for all active work items in the subgroup with a subgroup local ID less than or equal to this work item's subgroup local ID.

|[source,opencl_c]
----
gentype sub_group_non_uniform_scan_exclusive_and(
    gentype value )
gentype sub_group_non_uniform_scan_exclusive_or(
    gentype value )
gentype sub_group_non_uniform_scan_exclusive_xor(
    gentype value )
----
| Returns the result of an exclusive scan operation, which is the bitwise *and*, *or*, or *xor* of _value_ for all active work items in the subgroup with a subgroup local ID less than this work item's subgroup local ID.

If there is no active work item in the subgroup with a subgroup local ID less than this work item's subgroup local ID then an identity value `I` is returned.
For *and*, the identity value is `~0` (all bits set).
For *or* and *xor*, the identity value is `0`.

|=======================================================================

===== Logical Operations

The table below describes the OpenCL C programming language built-in functions that perform simple logical operations across work items in a subgroup.
These functions need not be encountered by all work items in a subgroup executing the kernel.
For these functions, a non-zero _predicate_ argument or return value is logically `true` and a zero _predicate_ argument or return value is logically `false`.

[cols="2a,1",options="header",]
|=======================================================================
|*Function*
|*Description*

|[source,opencl_c]
----
int sub_group_non_uniform_reduce_logical_and(
    int predicate )
int sub_group_non_uniform_reduce_logical_or(
    int predicate )
int sub_group_non_uniform_reduce_logical_xor(
    int predicate )
----
| Returns the logical *and*, *or*, or *xor* of _predicate_ for all active work items in the subgroup.

|[source,opencl_c]
----
int sub_group_non_uniform_scan_inclusive_logical_and(
    int predicate )
int sub_group_non_uniform_scan_inclusive_logical_or(
    int predicate )
int sub_group_non_uniform_scan_inclusive_logical_xor(
    int predicate )
----
| Returns the result of an inclusive scan operation, which is the logical *and*, *or*, or *xor* of _predicate_ for all active work items in the subgroup with a subgroup local ID less than or equal to this work item's subgroup local ID.

|[source,opencl_c]
----
int sub_group_non_uniform_scan_exclusive_logical_and(
    int predicate )
int sub_group_non_uniform_scan_exclusive_logical_or(
    int predicate )
int sub_group_non_uniform_scan_exclusive_logical_xor(
    int predicate )
----
| Returns the result of an exclusive scan operation, which is the logical *and*, *or*, or *xor* of _predicate_ for all active work items in the subgroup with a subgroup local ID less than this work item's subgroup local ID.

If there is no active work item in the subgroup with a subgroup local ID less than this work item's subgroup local ID then an identity value `I` is returned.
For *and*, the identity value is `true` (non-zero).
For *or* and *xor*, the identity value is `false` (zero).

|=======================================================================

[[cl_khr_subgroup_shuffle]]
=== General Purpose Shuffles

This section describes functionality added by `cl_khr_subgroup_shuffle`.
This extension adds additional ways to exchange data among work items in a subgroup.

==== Add a new Section 6.15.X - Subgroup Shuffle Built-in Functions

The table below describes the OpenCL C programming language built-in functions that allow work items in a subgroup to exchange data.
These functions need not be encountered by all work items in a subgroup executing the kernel.
For the functions below, the generic type name `gentype` may be one of the supported built-in scalar data types `char`, `uchar`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double` (if double precision is supported), or `half` (if half precision is supported).

[cols="1a,1",options="header",]
|=======================================================================
|*Function*
|*Description*

|[source,opencl_c]
----
gentype sub_group_shuffle(
    gentype value, uint index )
----
| Returns _value_ for the work item with subgroup local ID equal to _index_.
The shuffle _index_ need not be the same for all work items in the subgroup.

The return value is undefined if the work item with subgroup local ID equal to _index_ is inactive or if _index_ is greater than or equal to the size of the subgroup.

|[source,opencl_c]
----
gentype sub_group_shuffle_xor(
    gentype value, uint mask )
----
| Returns _value_ for the work item with subgroup local ID equal to this work item's subgroup local ID xor'd with _mask_.
The shuffle _mask_ need not be the same for all work items in the subgroup.

The return value is undefined if the work item with subgroup local ID equal to the calculated index is inactive or if the calculated index is greater than or equal to the size of the subgroup.

This is a specialized function that may perform better than the equivalent `sub_group_shuffle` on some implementations.

|=======================================================================

[[cl_khr_subgroup_shuffle_relative]]
=== Relative Shuffles

This section describes functionality added by `cl_khr_subgroup_shuffle_relative`.
This extension adds specialized ways to exchange data among work items in a subgroup that may perform better on some implementations.

==== Add a new Section 6.15.X - Subgroup Relative Shuffle Built-in Functions

The table below describes specialized OpenCL C programming language built-in functions that allow work items in a subgroup to exchange data.
These functions need not be encountered by all work items in a subgroup executing the kernel.
For the functions below, the generic type name `gentype` may be one of the supported built-in scalar data types `char`, `uchar`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double` (if double precision is supported), or `half` (if half precision is supported).

[cols="1a,1",options="header",]
|=======================================================================
|*Function*
|*Description*

|[source,opencl_c]
----
gentype sub_group_shuffle_up(
    gentype value, uint delta )
----
| Returns _value_ for the work item with subgroup local ID equal to this work item's subgroup local ID minus _delta_.
The shuffle _delta_ need not be the same for all work items in the subgroup.

The return value is undefined if the work item with subgroup local ID equal to the calculated index is inactive, or _delta_ is greater than this work item's subgroup local ID.

This is a specialized function that may perform better than the equivalent `sub_group_shuffle` on some implementations.

|[source,opencl_c]
----
gentype sub_group_shuffle_down(
    gentype value, uint delta )
----
| Returns _value_ for the work item with subgroup local ID equal to this work item's subgroup local ID plus _delta_.
The shuffle _delta_ need not be the same for all work items in the subgroup.

The return value is undefined if the work item with subgroup local ID equal to the calculated index is inactive, or this work item's subgroup local ID plus _delta_ is greater than or equal to the size of the subgroup.

This is a specialized function that may perform better than the equivalent `sub_group_shuffle` on some implementations.

|=======================================================================

[[cl_khr_subgroup_clustered_reduce]]
=== Clustered Reductions

This section describes functionality added by `cl_khr_subgroup_clustered_reduce`.
This extension adds support for clustered reductions that operate on a subset of work items in the subgroup.

==== Add a new Section 6.15.X - Subgroup Clustered Reduction Built-in Functions

This section describes arithmetic operations that are performed on a subset of work items in a subgroup, referred to as a cluster.
A cluster is described by a specified cluster size.
Work items in a subgroup are assigned to clusters such that for cluster size _n_, the _n_ work items in the subgroup with the smallest subgroup local IDs are assigned to the first cluster, then the _n_ remaining work items with the smallest subgroup local IDs are assigned to the next cluster, and so on.
Behavior is undefined if the specified cluster size is not an integer constant expression, is not a power-of-two, or is greater than the maximum size of a subgroup within the dispatch.

===== Arithmetic Operations

The table below describes the OpenCL C programming language built-in functions that perform simple arithmetic operations on a cluster of work items in a subgroup.
These functions need not be encountered by all work items in a subgroup executing the kernel.
For the functions below, the generic type name `gentype` may be one of the supported built-in scalar data types `char`, `uchar`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double` (if double precision is supported), or `half` (if half precision is supported).

[cols="1a,1",options="header",]
|=======================================================================
|*Function*
|*Description*

|[source,opencl_c]
----
gentype sub_group_clustered_reduce_add(
    gentype value, uint clustersize )
gentype sub_group_clustered_reduce_mul(
    gentype value, uint clustersize )
gentype sub_group_clustered_reduce_min(
    gentype value, uint clustersize )
gentype sub_group_clustered_reduce_max(
    gentype value, uint clustersize )
----
| Returns the summation, multiplication, minimum, or maximum of _value_ for all active work items in the subgroup within a cluster of the specified _clustersize_.

|=======================================================================

Note: The order of floating-point operations is not guaranteed for the subgroup clustered reduction built-in functions that operate on floating point types, and the order of operations may additionally be non-deterministic for a given subgroup.

===== Bitwise Operations

The table below describes the OpenCL C programming language built-in functions to perform simple bitwise integer operations across a cluster of work items in a subgroup.
These functions need not be encountered by all work items in a subgroup executing the kernel.
For the functions below, the generic type name `gentype` may be the one of the supported built-in scalar data types `char`, `uchar`, `short`, `ushort`, `int`, `uint`, `long`, or `ulong`.

[cols="1a,1",options="header",]
|=======================================================================
|*Function*
|*Description*

|[source,opencl_c]
----
gentype sub_group_clustered_reduce_and(
    gentype value, uint clustersize )
gentype sub_group_clustered_reduce_or(
    gentype value, uint clustersize )
gentype sub_group_clustered_reduce_xor(
    gentype value, uint clustersize )
----
| Returns the bitwise *and*, *or*, or *xor* of _value_ for all active work items in the subgroup within a cluster of the specified _clustersize_.

|=======================================================================

===== Logical Operations

The table below describes the OpenCL C programming language built-in functions to perform simple logical operations across a cluster of work items in a subgroup.
These functions need not be encountered by all work items in a subgroup executing the kernel.
For these functions, a non-zero _predicate_ argument or return value is logically `true` and a zero _predicate_ argument or return value is logically `false`.

[cols="3a,2",options="header",]
|=======================================================================
|*Function*
|*Description*

|[source,opencl_c]
----
int sub_group_clustered_reduce_logical_and(
    int predicate, uint clustersize )
int sub_group_clustered_reduce_logical_or(
    int predicate, uint clustersize )
int sub_group_clustered_reduce_logical_xor(
    int predicate, uint clustersize )
----
| Returns the logical *and*, *or*, or *xor* of _predicate_ for all active work items in the subgroup within a cluster of the specified _clustersize_.

|=======================================================================

[[extended-subgroups-mapping]]
=== Function Mapping and Capabilities

This section describes a possible mapping between OpenCL built-in functions and SPIR-V instructions and required SPIR-V capabilities.

This section is informational and non-normative.

// Note: the Unicode "zero with space" (&#8203;) causes long function names to break much more sensibly.

[cols="1,1,1",options="header"]
|=======================================================================
|*OpenCL C Function*
|*SPIR-V BuiltIn or Instruction*
|*Enabling SPIR-V Capability*

3+| For OpenCL 2.1 or `cl_khr_subgroups`:

| `get_&#8203;sub_&#8203;group_&#8203;size`
       | *SubgroupSize*
            | *Kernel*
| `get_&#8203;max_&#8203;sub_&#8203;group_&#8203;size`
       | *SubgroupMaxSize*
            | *Kernel*
| `get_&#8203;num_&#8203;sub_&#8203;groups`
        | *NumSubgroups*
            | *Kernel*
| `get_&#8203;enqueued_&#8203;num_&#8203;sub_&#8203;groups`
        | *NumEnqueuedSubgroups*
            | *Kernel*
| `get_&#8203;sub_&#8203;group_&#8203;id`
        | *SubgroupId*
            | *Kernel*
| `get_&#8203;sub_&#8203;group_&#8203;local_&#8203;id`
        | *SubgroupLocalInvocationId*
            | *Kernel*

| `sub_&#8203;group_&#8203;barrier`
        | *OpControlBarrier*
            | None Needed

| `sub_&#8203;group_&#8203;all`
        | *OpGroupAll*
            | *Groups*
| `sub_&#8203;group_&#8203;any`
        | *OpGroupAny*
            | *Groups*

| `sub_&#8203;group_&#8203;broadcast`
        | *OpGroupBroadcast*
            | *Groups*

| `sub_&#8203;group_&#8203;reduce_&#8203;add`
        | *OpGroupIAdd*, *OpGroupFAdd*
            | *Groups*
| `sub_&#8203;group_&#8203;reduce_&#8203;min`
        | *OpGroupSMin*, *OpGroupUMin*, *OpGroupFMin*
            | *Groups*
| `sub_&#8203;group_&#8203;reduce_&#8203;max`
        | *OpGroupSMax*, *OpGroupUMax*, *OpGroupFMax*
            | *Groups*

| `sub_&#8203;group_&#8203;scan_&#8203;exclusive_&#8203;add`
        | *OpGroupIAdd*, *OpGroupFAdd*
            | *Groups*
| `sub_&#8203;group_&#8203;scan_&#8203;exclusive_&#8203;min`
        | *OpGroupSMin*, *OpGroupUMin*, *OpGroupFMin*
            | *Groups*
| `sub_&#8203;group_&#8203;scan_&#8203;exclusive_&#8203;max`
        | *OpGroupSMax*, *OpGroupUMax*, *OpGroupFMax*
            | *Groups*

| `sub_&#8203;group_&#8203;scan_&#8203;inclusive_&#8203;add`
        | *OpGroupIAdd*, *OpGroupFAdd*
            | *Groups*
| `sub_&#8203;group_&#8203;scan_&#8203;inclusive_&#8203;min`
        | *OpGroupSMin*, *OpGroupUMin*, *OpGroupFMin*
            | *Groups*
| `sub_&#8203;group_&#8203;scan_&#8203;inclusive_&#8203;max`
        | *OpGroupSMax*, *OpGroupUMax*, *OpGroupFMax*
            | *Groups*

| `sub_&#8203;group_&#8203;reserve_&#8203;read_&#8203;pipe`
        | *OpGroupReserveReadPipePackets*
            | *Pipes*
| `sub_&#8203;group_&#8203;reserve_&#8203;write_&#8203;pipe`
        | *OpGroupReserveReadWritePackets*
            | *Pipes*
| `sub_&#8203;group_&#8203;commit_&#8203;read_&#8203;pipe`
        | *OpGroupCommitReadPipe*
            | *Pipes*
| `sub_&#8203;group_&#8203;commit_&#8203;write_&#8203;pipe`
        | *OpGroupCommitWritePipe*
            | *Pipes*

| `get_&#8203;kernel_&#8203;sub_&#8203;group_&#8203;count_&#8203;for_&#8203;ndrange`
        | *OpGetKernelNDrangeSubGroupCount*
            | *DeviceEnqueue*
| `get_&#8203;kernel_&#8203;max_&#8203;sub_&#8203;group_&#8203;size_&#8203;for_&#8203;ndrange`
        | *OpGetKernelNDrangeMaxSubGroupSize*
            | *DeviceEnqueue*

3+| For `cl_khr_subgroup_extended_types`: +
Note: This extension adds new types to uniform subgroup operations.

| `sub_&#8203;group_&#8203;broadcast`
        | *OpGroupBroadcast*
            | *Groups*

| `sub_&#8203;group_&#8203;reduce_&#8203;add`
        | *OpGroupIAdd*, *OpGroupFAdd*
            | *Groups*
| `sub_&#8203;group_&#8203;reduce_&#8203;min`
        | *OpGroupSMin*, *OpGroupUMin*, *OpGroupFMin*
            | *Groups*
| `sub_&#8203;group_&#8203;reduce_&#8203;max`
        | *OpGroupSMax*, *OpGroupUMax*, *OpGroupFMax*
            | *Groups*

| `sub_&#8203;group_&#8203;scan_&#8203;exclusive_&#8203;add`
        | *OpGroupIAdd*, *OpGroupFAdd*
            | *Groups*
| `sub_&#8203;group_&#8203;scan_&#8203;exclusive_&#8203;min`
        | *OpGroupSMin*, *OpGroupUMin*, *OpGroupFMin*
            | *Groups*
| `sub_&#8203;group_&#8203;scan_&#8203;exclusive_&#8203;max`
        | *OpGroupSMax*, *OpGroupUMax*, *OpGroupFMax*
            | *Groups*

| `sub_&#8203;group_&#8203;scan_&#8203;inclusive_&#8203;add`
        | *OpGroupIAdd*, *OpGroupFAdd*
            | *Groups*
| `sub_&#8203;group_&#8203;scan_&#8203;inclusive_&#8203;min`
        | *OpGroupSMin*, *OpGroupUMin*, *OpGroupFMin*
            | *Groups*
| `sub_&#8203;group_&#8203;scan_&#8203;inclusive_&#8203;max`
        | *OpGroupSMax*, *OpGroupUMax*, *OpGroupFMax*
            | *Groups*

3+| For `cl_khr_subgroup_non_uniform_vote`:

| `sub_&#8203;group_&#8203;elect`
        | *OpGroupNonUniformElect*
            | *GroupNonUniform*
| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;all`
        | *OpGroupNonUniformAll*
            | *GroupNonUniformVote*
| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;any`
        | *OpGroupNonUniformAny*
            | *GroupNonUniformVote*
| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;all_&#8203;equal`
        | *OpGroupNonUniformAllEqual*
            | *GroupNonUniformVote*

3+| For `cl_khr_subgroup_ballot`:

| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;broadcast`
        | *OpGroupNonUniformBroadcast*
            | *GroupNonUniformBallot*
| `sub_&#8203;group_&#8203;broadcast_&#8203;first`
        | *OpGroupNonUniformBroadcastFirst*
            | *GroupNonUniformBallot*

| `sub_&#8203;group_&#8203;ballot`
        | *OpGroupNonUniformBallot*
            | *GroupNonUniformBallot*
| `sub_&#8203;group_&#8203;inverse_&#8203;ballot`
        | *OpGroupNonUniformInverseBallot*
            | *GroupNonUniformBallot*
| `sub_&#8203;group_&#8203;ballot_&#8203;bit_&#8203;extract`
        | *OpGroupNonUniformBallotBitExtract*
            | *GroupNonUniformBallot*
| `sub_&#8203;group_&#8203;ballot_&#8203;bit_&#8203;count`
        | *OpGroupNonUniformBallotBitCount*
            | *GroupNonUniformBallot*
| `sub_&#8203;group_&#8203;ballot_&#8203;inclusive_&#8203;scan`
        | *OpGroupNonUniformBallotBitCount*
            | *GroupNonUniformBallot*
| `sub_&#8203;group_&#8203;ballot_&#8203;exclusive_&#8203;scan`
        | *OpGroupNonUniformBallotBitCount*
            | *GroupNonUniformBallot*
| `sub_&#8203;group_&#8203;ballot_&#8203;find_&#8203;lsb`
        | *OpGroupNonUniformBallotFindLSB*
            | *GroupNonUniformBallot*
| `sub_&#8203;group_&#8203;ballot_&#8203;find_&#8203;msb`
        | *OpGroupNonUniformBallotFindMSB*
            | *GroupNonUniformBallot*

| `get_&#8203;sub_&#8203;group_&#8203;eq_&#8203;mask`
        | *SubgroupEqMask*
            | *GroupNonUniformBallot*
| `get_&#8203;sub_&#8203;group_&#8203;ge_&#8203;mask`
        | *SubgroupGeMask*
            | *GroupNonUniformBallot*
| `get_&#8203;sub_&#8203;group_&#8203;gt_&#8203;mask`
        | *SubgroupGtMask*
            | *GroupNonUniformBallot*
| `get_&#8203;sub_&#8203;group_&#8203;le_&#8203;mask`
        | *SubgroupLeMask*
            | *GroupNonUniformBallot*
| `get_&#8203;sub_&#8203;group_&#8203;lt_&#8203;mask`
        | *SubgroupLtMask*
            | *GroupNonUniformBallot*

3+| For `cl_khr_subgroup_non_uniform_arithmetic`:

| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;reduce_&#8203;add`
        | *OpGroupNonUniformIAdd*, *OpGroupNonUniformFAdd*
            | *GroupNonUniformArithmetic*
| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;reduce_&#8203;mul`
        | *OpGroupNonUniformIMul*, *OpGroupNonUniformFMul*
            | *GroupNonUniformArithmetic*
| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;reduce_&#8203;min`
        | *OpGroupNonUniformSMin*, *OpGroupNonUniformUMin*, *OpGroupNonUniformFMin*
            | *GroupNonUniformArithmetic*
| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;reduce_&#8203;max`
        | *OpGroupNonUniformSMax*, *OpGroupNonUniformUMax*, *OpGroupNonUniformFMax*
            | *GroupNonUniformArithmetic*
| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;reduce_&#8203;and`
        | *OpGroupNonUniformBitwiseAnd*
            | *GroupNonUniformArithmetic*
| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;reduce_&#8203;or`
        | *OpGroupNonUniformBitwiseOr*
            | *GroupNonUniformArithmetic*
| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;reduce_&#8203;xor`
        | *OpGroupNonUniformBitwiseXor*
            | *GroupNonUniformArithmetic*
| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;reduce_&#8203;logical_&#8203;and`
        | *OpGroupNonUniformLogicalAnd*
            | *GroupNonUniformArithmetic*
| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;reduce_&#8203;logical_&#8203;or`
        | *OpGroupNonUniformLogicalOr*
            | *GroupNonUniformArithmetic*
| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;reduce_&#8203;logical_&#8203;xor`
        | *OpGroupNonUniformLogicalXor*
            | *GroupNonUniformArithmetic*

| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;scan_&#8203;inclusive_&#8203;add`
        | *OpGroupNonUniformIAdd*, *OpGroupNonUniformFAdd*
            | *GroupNonUniformArithmetic*
| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;scan_&#8203;inclusive_&#8203;mul`
        | *OpGroupNonUniformIMul*, *OpGroupNonUniformFMul*
            | *GroupNonUniformArithmetic*
| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;scan_&#8203;inclusive_&#8203;min`
        | *OpGroupNonUniformSMin*, *OpGroupNonUniformUMin*, *OpGroupNonUniformFMin*
            | *GroupNonUniformArithmetic*
| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;scan_&#8203;inclusive_&#8203;max`
        | *OpGroupNonUniformSMax*, *OpGroupNonUniformUMax*, *OpGroupNonUniformFMax*
            | *GroupNonUniformArithmetic*
| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;scan_&#8203;inclusive_&#8203;and`
        | *OpGroupNonUniformBitwiseAnd*
            | *GroupNonUniformArithmetic*
| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;scan_&#8203;inclusive_&#8203;or`
        | *OpGroupNonUniformBitwiseOr*
            | *GroupNonUniformArithmetic*
| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;scan_&#8203;inclusive_&#8203;xor`
        | *OpGroupNonUniformBitwiseXor*
            | *GroupNonUniformArithmetic*
| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;scan_&#8203;inclusive_&#8203;logical_&#8203;and`
        | *OpGroupNonUniformLogicalAnd*
            | *GroupNonUniformArithmetic*
| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;scan_&#8203;inclusive_&#8203;logical_&#8203;or`
        | *OpGroupNonUniformLogicalOr*
            | *GroupNonUniformArithmetic*
| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;scan_&#8203;inclusive_&#8203;logical_&#8203;xor`
        | *OpGroupNonUniformLogicalXor*
            | *GroupNonUniformArithmetic*

| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;scan_&#8203;exclusive_&#8203;add`
        | *OpGroupNonUniformIAdd*, *OpGroupNonUniformFAdd*
            | *GroupNonUniformArithmetic*
| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;scan_&#8203;exclusive_&#8203;mul`
        | *OpGroupNonUniformIMul*, *OpGroupNonUniformFMul*
            | *GroupNonUniformArithmetic*
| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;scan_&#8203;exclusive_&#8203;min`
        | *OpGroupNonUniformSMin*, *OpGroupNonUniformUMin*, *OpGroupNonUniformFMin*
            | *GroupNonUniformArithmetic*
| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;&#8203;scan_&#8203;exclusive_&#8203;max`
        | *OpGroupNonUniformSMax*, *OpGroupNonUniformUMax*, *OpGroupNonUniformFMax*
            | *GroupNonUniformArithmetic*
| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;&#8203;scan_&#8203;exclusive_&#8203;and`
        | *OpGroupNonUniformBitwiseAnd*
            | *GroupNonUniformArithmetic*
| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;&#8203;scan_&#8203;exclusive_&#8203;or`
        | *OpGroupNonUniformBitwiseOr*
            | *GroupNonUniformArithmetic*
| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;&#8203;scan_&#8203;exclusive_&#8203;xor`
        | *OpGroupNonUniformBitwiseXor*
            | *GroupNonUniformArithmetic*
| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;&#8203;scan_&#8203;exclusive_&#8203;logical_&#8203;and`
        | *OpGroupNonUniformLogicalAnd*
            | *GroupNonUniformArithmetic*
| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;&#8203;scan_&#8203;exclusive_&#8203;logical_&#8203;or`
        | *OpGroupNonUniformLogicalOr*
            | *GroupNonUniformArithmetic*
| `sub_&#8203;group_&#8203;non_&#8203;uniform_&#8203;&#8203;scan_&#8203;exclusive_&#8203;logical_&#8203;xor`
        | *OpGroupNonUniformLogicalXor*
            | *GroupNonUniformArithmetic*

3+| For `cl_khr_subgroup_shuffle`:

| `sub_&#8203;group_&#8203;shuffle`
        | *OpGroupNonUniformShuffle*
            | *GroupNonUniformShuffle*
| `sub_&#8203;group_&#8203;shuffle_&#8203;xor`
        | *OpGroupNonUniformShuffleXor*
            | *GroupNonUniformShuffle*

3+| For `cl_khr_subgroup_shuffle_relative`:

| `sub_&#8203;group_&#8203;shuffle_&#8203;up`
        | *OpGroupNonUniformShuffleUp*
            | *GroupNonUniformShuffleRelative*
| `sub_&#8203;group_&#8203;shuffle_&#8203;down`
        | *OpGroupNonUniformShuffleDown*
            | *GroupNonUniformShuffleRelative*

3+| For `cl_khr_subgroup_clustered_reduce`:

| `sub_&#8203;group_&#8203;clustered_&#8203;reduce_&#8203;add`
        | *OpGroupNonUniformIAdd*, *OpGroupNonUniformFAdd*
            | *GroupNonUniformClustered*
| `sub_&#8203;group_&#8203;clustered_&#8203;reduce_&#8203;mul`
        | *OpGroupNonUniformIMul*, *OpGroupNonUniformFMul*
            | *GroupNonUniformClustered*
| `sub_&#8203;group_&#8203;clustered_&#8203;reduce_&#8203;min`
        | *OpGroupNonUniformSMin*, *OpGroupNonUniformUMin*, *OpGroupNonUniformFMin*
            | *GroupNonUniformClustered*
| `sub_&#8203;group_&#8203;clustered_&#8203;reduce_&#8203;max`
        | *OpGroupNonUniformSMax*, *OpGroupNonUniformUMax*, *OpGroupNonUniformFMax*
            | *GroupNonUniformClustered*
| `sub_&#8203;group_&#8203;clustered_&#8203;reduce_&#8203;and`
        | *OpGroupNonUniformBitwiseAnd*
            | *GroupNonUniformClustered*
| `sub_&#8203;group_&#8203;clustered_&#8203;reduce_&#8203;or`
        | *OpGroupNonUniformBitwiseOr*
            | *GroupNonUniformClustered*
| `sub_&#8203;group_&#8203;clustered_&#8203;reduce_&#8203;xor`
        | *OpGroupNonUniformBitwiseXor*
            | *GroupNonUniformClustered*
| `sub_&#8203;group_&#8203;clustered_&#8203;reduce_&#8203;logical_&#8203;and`
        | *OpGroupNonUniformLogicalAnd*
            | *GroupNonUniformClustered*
| `sub_&#8203;group_&#8203;clustered_&#8203;reduce_&#8203;logical_&#8203;or`
        | *OpGroupNonUniformLogicalOr*
            | *GroupNonUniformClustered*
| `sub_&#8203;group_&#8203;clustered_&#8203;reduce_&#8203;logical_&#8203;xor`
        | *OpGroupNonUniformLogicalXor*
            | *GroupNonUniformClustered*

|=======================================================================
