// Copyright 2018-2022 The Khronos Group. This work is licensed under a
// Creative Commons Attribution 4.0 International License; see
// http://creativecommons.org/licenses/by/4.0/

[[cl_khr_command_buffer]]
== Command Buffers (Provisional)

This extension adds the ability to record and replay buffers of OpenCL commands.

=== General Information

==== Name Strings

`cl_khr_command_buffer`

==== Version History

[cols="1,1,3",options="header",]
|====
| *Date*     | *Version* | *Description*
| 2021-11-10 | 0.9.0     | First assigned version (provisional).
|====

==== Dependencies

This extension is written against the OpenCL Specification version 3.0.6.

This extension requires OpenCL 1.2 or later.

==== Contributors

Ewan Crawford, Codeplay Software Ltd. +
Gordon Brown, Codeplay Software Ltd. +
Kenneth Benzie, Codeplay Software Ltd. +
Alastair Murray, Codeplay Software Ltd. +
Jack Frankland, Codeplay Software Ltd. +
Balaji Calidas, Qualcomm Technologies Inc. +
Joshua Kelly, Qualcomm Technologies, Inc. +
Kevin Petit, Arm Ltd. +
Aharon Abramson, Intel. +
Ben Ashbaugh, Intel. +
Boaz Ouriel, Intel. +
Pekka Jääskeläinen, Tampere University +
Nikhil Joshi, NVIDIA +
James Price, Google +

=== Overview

Command-buffers enable a reduction in overhead when enqueuing the same
workload multiple times. By separating the command-queue setup from dispatch,
the ability to replay a set of previously created commands is introduced.

Device-side _cl_sync_point_khr_ synchronization-points can be used within
command-buffers to define command dependencies. This allows the commands of a
command-buffer to execute out-of-order on a single <<compatible, compatible>>
command-queue. The command-buffer itself has no inherent in-order/out-of-order
property, this ordering is inferred from the command-queue used on command
recording. Out-of-order enqueues without event dependencies of both regular
commands, such as *clEnqueueFillBuffer*, and command-buffers are allowed to
execute concurrently, and it is up to the user to express any dependencies using
events.

The command-queues a command-buffer will be executed on can be set on replay via
parameters to *clEnqueueCommandBufferKHR*, provided they are
<<compatible, compatible>> with the command-queues used on command-buffer
recording.

==== Background

On embedded devices where building a command stream accounts for a significant
expenditure of resources and where workloads are often required to be pipelined,
a solution that minimizes driver overhead can significantly improve the
utilization of accelerators by removing a bottleneck in repeated command stream
generation.

An additional motivator is lowering task execution latency, as devices can be
kept occupied with work by repeated submissions, without having to wait on
the host to construct commands again for a similar workload.

==== Rationale

The command-buffer abstraction over the generation of command streams is a
proven approach which facilitates a significant reduction in driver overhead in
existing real-world applications with repetitive pipelined workloads which are
built on top of Vulkan, DirectX 12, and Metal.

A primary goal is for a command-buffer to avoid any interaction with
application code after being enqueued until all recorded commands have
completed. As such, any command which maps or migrates memory objects; reads
or writes memory objects; or enqueues a native kernel, is not available for
command-buffer recording. Finally commands recorded into a command buffer do
not wait for or return event objects, these are instead replaced with
device-side synchronization-point identifiers which enable out-of-order
execution when enqueued on <<compatible, compatible>> command-queues.

Adding new entry-points for individual commands, rather than recording existing
command-queue APIs with begin/end markers was a design decision made for the
following reasons:

* Individually specified entry points makes it clearer to the user what's
  supported, as opposed to adding a large number of error conditions
  throughout the specification with all the restrictions.

* Prevents code forking in existing entry points for the implementer, as
  otherwise separate paths in each entry point need to be maintained for both
  the recording and normal cases.

* Allows the definition of a new device-side synchronization primitive rather
  than overloading `cl_event`. As use of `cl_event` in individual commands
  allows host interaction from callback and user-events, as well as introducing
  complexities when a command-buffer is enqueued multiple times regarding
  profiling and execution status.

* New entry points facilitate returning handles to individual commands, allowing
  those commands to be modified between enqueues of the command buffer. Not all
  command handles are used in this extension, but providing them facilitates
  other extensions layered on top to take advantage of them to provide additional
  mutable functionality.

==== Simultaneous Use

The optional simultaneous use capability was added to the extension so that
vendors can support pipelined workflows, where command-buffers are repeatedly
enqueued without blocking in user code. However, simultaneous use may result in
command-buffers being more expensive to enqueue than in a sequential model, so
the capability is optional to enable optimizations on command-buffer recording.

=== Interactions with Other Extensions

All command recording entry-points return a mutable-command handle for
modifying the command between enqueues of the command-buffer. However,
functionality for mutating commands is not supported by this
extension. These are provided for other extensions layered on top to use,
such as `cl_khr_mutable_dispatch`.

Only a single command-queue specified on creation of a command-buffer can
be used for recording commands to in this `cl_khr_command_buffer` extension.
The `cl_khr_heterogeneous_replay` extension allows commands to be recorded across
multiple queues in the same command-buffer, providing replay of heterogeneous
task graphs.

=== New Types

====  Command Buffer Types

Bitfield for querying command-buffer capabilities of an OpenCL device with
*clGetDeviceInfo*, see <<command-buffer-queries, device queries table>>:
[source]
----
typedef cl_bitfield cl_device_command_buffer_capabilities_khr
----

Types describing <<command-buffers, command-buffers>>:

[source]
----
// Returned by clCreateCommandBufferKHR()
typedef struct _cl_command_buffer_khr* cl_command_buffer_khr;

// Unique ID to a device-side synchronization-point used to describe the
// ordering of commands when recording a command-buffer. Valid for use
// only within the same command-buffer during recording.
typedef cl_uint cl_sync_point_khr;

// Handle returned on command recording
typedef struct _cl_mutable_command_khr* cl_mutable_command_khr;

// Mutable properties of a clCommandNDRangeKernelKHR command
typedef cl_properties cl_ndrange_kernel_command_properties_khr;

// Properties for command-buffer creation
typedef cl_properties cl_command_buffer_properties_khr;

// Bitfield representing flags for command-buffers
typedef cl_bitfield cl_command_buffer_flags_khr;

// Enumerated type for use in clGetCommandBufferInfoKHR()
typedef cl_uint cl_command_buffer_info_khr;

// Return type for CL_COMMAND_BUFFER_STATE_KHR in clGetCommandBufferInfoKHR()
typedef cl_uint cl_command_buffer_state_khr;
----

=== New API Functions

Command-buffer entry points from <<command-buffers, Section 5.X>>:
[source]
----
cl_command_buffer_khr clCreateCommandBufferKHR(
    cl_uint num_queues,
    const cl_command_queue* queues,
    const cl_command_buffer_properties_khr* properties,
    cl_int* errcode_ret);

cl_int clRetainCommandBufferKHR(cl_command_buffer_khr command_buffer);

cl_int clReleaseCommandBufferKHR(cl_command_buffer_khr command_buffer);

cl_int clFinalizeCommandBufferKHR(cl_command_buffer_khr command_buffer);

cl_int clEnqueueCommandBufferKHR(
    cl_uint num_queues,
    cl_command_queue* queues,
    cl_command_buffer_khr command_buffer,
    cl_uint num_events_in_wait_list,
    const cl_event* event_wait_list,
    cl_event* event);

cl_int clCommandBarrierWithWaitListKHR(
    cl_command_buffer_khr command_buffer,
    cl_command_queue command_queue,
    cl_uint num_sync_points_in_wait_list,
    const cl_sync_point_khr* sync_point_wait_list,
    cl_sync_point_khr* sync_point,
    cl_mutable_command_khr* mutable_handle);

cl_int clCommandCopyBufferKHR(
    cl_command_buffer_khr command_buffer,
    cl_command_queue command_queue,
    cl_mem src_buffer,
    cl_mem dst_buffer,
    size_t src_offset,
    size_t dst_offset,
    size_t size,
    cl_uint num_sync_points_in_wait_list,
    const cl_sync_point_khr* sync_point_wait_list,
    cl_sync_point_khr* sync_point,
    cl_mutable_command_khr* mutable_handle);

cl_int clCommandCopyBufferRectKHR(
    cl_command_buffer_khr command_buffer,
    cl_command_queue command_queue,
    cl_mem src_buffer,
    cl_mem dst_buffer,
    const size_t* src_origin,
    const size_t* dst_origin,
    const size_t* region,
    size_t src_row_pitch,
    size_t src_slice_pitch,
    size_t dst_row_pitch,
    size_t dst_slice_pitch,
    cl_uint num_sync_points_in_wait_list,
    const cl_sync_point_khr* sync_point_wait_list,
    cl_sync_point_khr* sync_point,
    cl_mutable_command_khr* mutable_handle);

cl_int clCommandCopyBufferToImageKHR(
    cl_command_buffer_khr command_buffer,
    cl_command_queue command_queue,
    cl_mem src_buffer,
    cl_mem dst_image,
    size_t src_offset,
    const size_t* dst_origin,
    const size_t* region,
    cl_uint num_sync_points_in_wait_list,
    const cl_sync_point_khr* sync_point_wait_list,
    cl_sync_point_khr* sync_point,
    cl_mutable_command_khr* mutable_handle);

cl_int clCommandCopyImageKHR(
    cl_command_buffer_khr command_buffer,
    cl_command_queue command_queue,
    cl_mem src_image,
    cl_mem dst_image,
    const size_t* src_origin,
    const size_t* dst_origin,
    const size_t* region,
    cl_uint num_sync_points_in_wait_list,
    const cl_sync_point_khr* sync_point_wait_list,
    cl_sync_point_khr* sync_point,
    cl_mutable_command_khr* mutable_handle);

cl_int clCommandCopyImageToBufferKHR(
    cl_command_buffer_khr command_buffer,
    cl_command_queue command_queue,
    cl_mem src_image,
    cl_mem dst_buffer,
    const size_t* src_origin,
    const size_t* region,
    size_t dst_offset,
    cl_uint num_sync_points_in_wait_list,
    const cl_sync_point_khr* sync_point_wait_list,
    cl_sync_point_khr* sync_point,
    cl_mutable_command_khr* mutable_handle);

cl_int clCommandFillBufferKHR(
    cl_command_buffer_khr command_buffer,
    cl_command_queue command_queue,
    cl_mem buffer,
    const void* pattern,
    size_t pattern_size,
    size_t offset,
    size_t size,
    cl_uint num_sync_points_in_wait_list,
    const cl_sync_point_khr* sync_point_wait_list,
    cl_sync_point_khr* sync_point,
    cl_mutable_command_khr* mutable_handle);

cl_int clCommandFillImageKHR(
    cl_command_buffer_khr command_buffer,
    cl_command_queue command_queue,
    cl_mem image,
    const void* fill_color,
    const size_t* origin,
    const size_t* region,
    cl_uint num_sync_points_in_wait_list,
    const cl_sync_point_khr* sync_point_wait_list,
    cl_sync_point_khr* sync_point,
    cl_mutable_command_khr* mutable_handle);

cl_int clCommandNDRangeKernelKHR(
    cl_command_buffer_khr command_buffer,
    cl_command_queue command_queue,
    const cl_ndrange_kernel_command_properties_khr* properties,
    cl_kernel kernel,
    cl_uint work_dim,
    const size_t* global_work_offset,
    const size_t* global_work_size,
    const size_t* local_work_size,
    cl_uint num_sync_points_in_wait_list,
    const cl_sync_point_khr* sync_point_wait_list,
    cl_sync_point_khr* sync_point,
    cl_mutable_command_khr* mutable_handle);

cl_int clGetCommandBufferInfoKHR(
    cl_command_buffer_khr command_buffer,
    cl_command_buffer_info_khr param_name,
    size_t param_value_size,
    void* param_value,
    size_t* param_value_size_ret);
----


=== New API Enums

Enums for querying device command-buffer capabilities with
*clGetDeviceInfo*, see <<command-buffer-queries, device queries table>>:

[source]
----
// Accepted values for the param_name parameter to clGetDeviceInfo
CL_DEVICE_COMMAND_BUFFER_CAPABILITIES_KHR              0x12A9
CL_DEVICE_COMMAND_BUFFER_REQUIRED_QUEUE_PROPERTIES_KHR 0x12AA

// Bits for cl_device_command_buffer_capabilities_khr bitfield
CL_COMMAND_BUFFER_CAPABILITY_KERNEL_PRINTF_KHR        (0x1 << 0)
CL_COMMAND_BUFFER_CAPABILITY_DEVICE_SIDE_ENQUEUE_KHR  (0x1 << 1)
CL_COMMAND_BUFFER_CAPABILITY_SIMULTANEOUS_USE_KHR     (0x1 << 2)
CL_COMMAND_BUFFER_CAPABILITY_OUT_OF_ORDER_KHR         (0x1 << 3)

// Values for cl_command_buffer_state_khr
CL_COMMAND_BUFFER_STATE_RECORDING_KHR              0x0
CL_COMMAND_BUFFER_STATE_EXECUTABLE_KHR             0x1
CL_COMMAND_BUFFER_STATE_PENDING_KHR                0x2
CL_COMMAND_BUFFER_STATE_INVALID_KHR                0x3
----

Enums for base <<command-buffer, command-buffers>> functionality:

[source]
----
// Error codes
CL_INVALID_COMMAND_BUFFER_KHR                      -1138
CL_INVALID_SYNC_POINT_WAIT_LIST_KHR                -1139
CL_INCOMPATIBLE_COMMAND_QUEUE_KHR                  -1140

// Bitfield to clCreateCommandBufferKHR
CL_COMMAND_BUFFER_FLAGS_KHR                        0x1293

// Bits for cl_command_buffer_flags_khr bitfield
CL_COMMAND_BUFFER_SIMULTANEOUS_USE_KHR             (0x1 << 0)

// cl_command_buffer_info_khr queries to clGetCommandBufferInfoKHR
CL_COMMAND_BUFFER_QUEUES_KHR                       0x1294
CL_COMMAND_BUFFER_NUM_QUEUES_KHR                   0x1295
CL_COMMAND_BUFFER_REFERENCE_COUNT_KHR              0x1296
CL_COMMAND_BUFFER_STATE_KHR                        0x1297
CL_COMMAND_BUFFER_PROPERTIES_ARRAY_KHR             0x1298

// cl_event command-buffer enqueue command type
CL_COMMAND_COMMAND_BUFFER_KHR                      0x12A8
----

=== Modifications to section 4.2 of the OpenCL API Specification

Add to *Table 5*, _Device Queries_, of section 4.2:
[[command-buffer-queries]]
[cols="1,1,4",options="header"]
|====
| cl_device_info
| Return Type
| Description

| `CL_DEVICE_COMMAND_BUFFER_CAPABILITIES_KHR`
| `cl_device_command_buffer_capabilities_khr`
| Describes device command-buffer capabilities, encoded as bits in a bitfield.
  Supported capabilities are:

  `CL_COMMAND_BUFFER_CAPABILITY_KERNEL_PRINTF_KHR` Device supports the ability
  to record commands that execute kernels which contain printf calls.

  `CL_COMMAND_BUFFER_CAPABILITY_DEVICE_SIDE_ENQUEUE_KHR` Device supports the
  ability to record commands that execute kernels which contain device-side
  kernel-enqueue calls.

  `CL_COMMAND_BUFFER_CAPABILITY_SIMULTANEOUS_USE_KHR` Device supports the
  command-buffers having a <<pending_count, Pending Count>> that exceeds 1.

  `CL_COMMAND_BUFFER_CAPABILITY_OUT_OF_ORDER_KHR` Device supports the ability
  to record command-buffers to out-of-order command-queues.

| `CL_DEVICE_COMMAND_BUFFER_REQUIRED_QUEUE_PROPERTIES_KHR`
| `cl_command_queue_properties`
| Bitmask of the minimum properties with which a command-queue must be created
  to allow a command-buffer to be executed on it. It is valid for a
  command-queue to be created with extra properties in addition to this
  base requirement and still be compatible with command-buffer execution.
|====

[[command-buffers]]
=== Add new section "Section 5.X - Command Buffers" to OpenCL API Specification

A _command-buffer_ object represents a series of operations to be enqueued
on one or more command-queues without any application code interaction.
Grouping the operations together allows efficient enqueuing of repetitive
operations, as well as enabling driver optimizations.

Command-buffers are _sequential use_ by default, but may also be set to
_simultaneous use_ on creation if the device optionally supports this
capability. A sequential use command-buffer must have a <<pending_count,
Pending Count>> of 0 or 1. The simultaneous use capability removes this
restriction and allows command-buffers to have a <<pending_count, Pending
Count>> greater than 1.

[[compatible]]
Command-buffers are created using an ordered list of command-queues that
commands are recorded to and execute on by default. These command-queues can be
replaced on command-buffer enqueue with different command-queues, provided for
each element in the replacement list the substitute command-queue is compatible
with the command-queue used on command-buffer creation. Where a _compatible_
command-queue is defined as a command-queue with identical properties targeting
the same device and in the same OpenCL context.


==== Add new section "Section 5.X.1 - Command Buffer Lifecycle"

A command-buffer is always in one of the following states:

[[recording]]
Recording:: Initial state of a command-buffer on creation, where commands can be
recorded to the command-buffer.

[[executable]]
Executable:: State after command recording has finished with
*clFinalizeCommandBufferKHR* and the command-buffer may be enqueued.

[[pending]]
Pending:: Once a command-buffer has been enqueued to a command-queue it enters
the Pending state until completion, at which point it moves back to the
<<executable, Executable>> state.

[[invalid]]
Invalid:: A command-buffer can enter the Invalid state if a resource that was
used in a command has been modified or freed. The only valid operation to
perform on a command-buffer in the Invalid state is to call
*clReleaseCommandBufferKHR* for each of the reference counts the application
owns.

image::images/commandbuffer_lifecycle.svg[align="center", title="Lifecycle of a command-buffer."]

[[pending_count]]
The Pending Count is the number of copies of the command
buffer in the <<pending, Pending>> state. By default a command-buffer's Pending
Count must be 0 or 1. If the command-buffer was created with
`CL_COMMAND_BUFFER_SIMULTANEOUS_USE_KHR` then the command-buffer may have a
Pending Count greater than 1.

==== Add new section "Section 5.X.2 - Creating Command Buffer Objects"

The function
indexterm:[clCreateCommandBufferKHR]
[source]
----
cl_command_buffer_khr clCreateCommandBufferKHR(
    cl_uint num_queues,
    const cl_command_queue* queues,
    const cl_command_buffer_properties_khr* properties,
    cl_int* errcode_ret);
----
Is used to create a command-buffer that can record commands to the specified
queues.

[NOTE]
====
Upon creation the command-buffer is defined as being in the
<<recording, Recording>> state, in order for the command-buffer to be enqueued
it must first be finalized using *clFinalizeCommandBufferKHR* after which no
further commands can be recorded. A command-buffer is submitted for execution
on command-queues with a call to *clEnqueueCommandBufferKHR*.
====

_num_queues_ The number of command-queues listed in _queues_. This extension
only supports a single command-queue, so this **must** be one.

_queues_  Is a pointer to a command-queue that the command-buffer commands will
be recorded to. _queues_ must be a non-`NULL` value.

_properties_  Specifies a list of properties for the command-buffer and their
corresponding values. Each property name is immediately followed by the
corresponding desired value. The list is terminated with 0.
The list of supported properties is described in the table below. If a
supported property and its value is not specified in properties, its
default value will be used. _properties_ can be `NULL` in which case the
default values for supported command-buffer properties will be used.

.*clCreateCommandBufferKHR* properties
[cols=",,",options="header",]
|====
| *Recording Properties*
| *Property Value*
| *Description*

| *CL_COMMAND_BUFFER_FLAGS_KHR*
| `cl_command_buffer_flags_khr`
| This is a bitfield and can be set to a combination of the following values:

  `CL_COMMAND_BUFFER_SIMULTANEOUS_USE_KHR` - Allow multiple instances of the
  command-buffer to be submitted to the device for execution. If set, devices
  must support `CL_COMMAND_BUFFER_CAPABILITY_SIMULTANEOUS_USE_KHR`.
  
  The default value of this property is `0`.
|====

_errcode_ret_ Returns an appropriate error code. If _errcode_ret_ is `NULL`, no
error code is returned.

*clCreateCommandBufferKHR* returns a valid non-zero command-buffer and
_errcode_ret_ is set to `CL_SUCCESS` if the command-buffer is created
successfully. Otherwise, it returns a `NULL` value with one of the following
error values returned in _errcode_ret_:

* `CL_INVALID_COMMAND_QUEUE` if any command-queue in _queues_ is not a valid
  command-queue.

* `CL_INCOMPATIBLE_COMMAND_QUEUE_KHR` if any command-queue in _queues_ is an
  out-of-order command-queue and the device associated with the command-queue
  does not support the `CL_COMMAND_BUFFER_CAPABILITY_OUT_OF_ORDER_KHR`
  capability.

* `CL_INCOMPATIBLE_COMMAND_QUEUE_KHR` if the properties of any command-queue in
  _queues_ does not contain the minimum properties specified by
  `CL_DEVICE_COMMAND_BUFFER_REQUIRED_QUEUE_PROPERTIES_KHR`.

* `CL_INVALID_CONTEXT` if all the command-queues in _queues_ do not have the
  same OpenCL context.

* `CL_INVALID_VALUE` if _num_queues_ is not one.

* `CL_INVALID_VALUE` if _queues_ is `NULL`.

* `CL_INVALID_VALUE` if values specified in _properties_ are not valid, or if
  the same property name is specified more than once.

* `CL_INVALID_PROPERTY` if values specified in _properties_ are valid but are
  not supported by all the devices associated with command-queues in _queues_.

* `CL_OUT_OF_RESOURCES` if there is a failure to allocate resources
  required by the OpenCL implementation on the device.

* `CL_OUT_OF_HOST_MEMORY` if there is a failure to allocate resources
  required by the OpenCL implementation on the host.

The function
indexterm:[clRetainCommandBufferKHR]
[source]
----
cl_int clRetainCommandBufferKHR(cl_command_buffer_khr command_buffer)
----
Increments the _command_buffer_ reference count.

[NOTE]
====
A command-buffer object updates the reference count for objects such as
buffers, images, and kernels used as parameters for commands recorded to the
command-buffer.

For example, recording a ND-range kernel via *clCommandNDRangeKernel* into a
command-buffer and then releasing the kernel object will still allow continued
safe use of the command-buffer. As the reference count of the kernel object
will have been incremented when the command was recorded, and then on
command-buffer release the kernel reference count will be decremented. If at
that point the kernel reference count reaches 0, the kernel object will be
freed.
====

_command_buffer_ Specifies the command-buffer to retain.

*clRetainCommandBufferKHR* returns `CL_SUCCESS` if the function is executed
successfully. Otherwise, it returns one of the following errors:

* `CL_INVALID_COMMAND_BUFFER_KHR` if _command_buffer_ is not a valid
  command-buffer.

* `CL_OUT_OF_RESOURCES` if there is a failure to allocate resources required by
  the OpenCL implementation on the device.

* `CL_OUT_OF_HOST_MEMORY` if there is a failure to allocate resources required by
  the OpenCL implementation on the host.

The function
indexterm:[clReleaseCommandBufferKHR]
[source]
----
cl_int clReleaseCommandBufferKHR(cl_command_buffer_khr command_buffer)
----
Decrements the _command_buffer_ reference count.

[NOTE]
====
After the _command_buffer_ reference count becomes zero and has finished
execution, the command-buffer is deleted.
====

_command_buffer_ Specifies the command-buffer to release.

*clReleaseCommandBufferKHR* returns `CL_SUCCESS` if the function is executed
successfully. Otherwise, it returns one of the following errors:

* `CL_INVALID_COMMAND_BUFFER_KHR` if _command_buffer_ is not a valid
  command-buffer.

* `CL_OUT_OF_RESOURCES` if there is a failure to allocate resources
  required by the OpenCL implementation on the device.

* `CL_OUT_OF_HOST_MEMORY` if there is a failure to allocate resources
  required by the OpenCL implementation on the host.

==== Add new section "Section 5.X.2 - Enqueuing a Command Buffer"

The function
indexterm:[clFinalizeCommandBufferKHR]
[source]
----
cl_int clFinalizeCommandBufferKHR(cl_command_buffer_khr command_buffer);
----
Finalizes command recording ready for enqueuing the command-buffer on a
command-queue.

[NOTE]
====
*clFinalizeCommandBufferKHR* places the command-buffer in the
<<executable, Executable>> state where commands can no longer be recorded, at
this point the command-buffer is ready to be enqueued.
====

_command_buffer_ Refers to a valid command-buffer object.

*clFinalizeCommandBufferKHR* returns `CL_SUCCESS` if the function is executed
successfully. Otherwise, it returns one of the following errors:

* `CL_INVALID_COMMAND_BUFFER_KHR` if _command_buffer_ is not a valid
  command-buffer.

* `CL_OUT_OF_RESOURCES` if there is a failure to allocate resources required by
  the OpenCL implementation on the device.

* `CL_OUT_OF_HOST_MEMORY` if there is a failure to allocate resources required
  by the OpenCL implementation on the host.

The function
indexterm:[clEnqueueCommandBufferKHR]
[source]
----
cl_int clEnqueueCommandBufferKHR(
    cl_uint num_queues,
    cl_command_queue* queues,
    cl_command_buffer_khr command_buffer,
    cl_uint num_events_in_wait_list,
    const cl_event* event_wait_list,
    cl_event* event);
----
Enqueues a command-buffer to execute on command-queues specified by _queues_,
or on default command-queues used during recording if _queues_ is empty.

[NOTE]
====
To enqueue a command-buffer it must be in a <<executable, Executable>> state,
see *clFinalizeCommandBufferKHR*.
====

_num_queues_ The number of command-queues listed in _queues_.

_queues_  A pointer to an ordered list of command-queues
<<compatible, compatible>> with the command-queues used on recording. _queues_
can be `NULL` in which case the default command-queues used on command-buffer
creation are used and _num_queues_ must be 0.

_command_buffer_ Refers to a valid command-buffer object.

_event_wait_list_, _num_events_in_wait_list_ Specify events that need to
complete before this particular command can be executed. If
_event_wait_list_ is `NULL`, then this particular command does not wait
on any event to complete. If _event_wait_list_ is `NULL`,
_num_events_in_wait_list_ must be 0. If event_wait_list is not `NULL`,
the list of events pointed to by _event_wait_list_ must be valid and
_num_events_in_wait_list_ must be greater than 0. The events specified
in _event_wait_list_ act as synchronization points. The context associated
with events in _event_wait_list_ and command_queue must be the same. The memory
associated with _event_wait_list_ can be reused or freed after the function
returns.

_event_ Returns an event object that identifies this command and
can be used to query for profiling information or queue a wait for this
particular command to complete. _event_ can be `NULL` in which case it will not
be possible for the application to wait on this command or query it for
profiling information.

*clEnqueueCommandBufferKHR* returns `CL_SUCCESS` if the command-buffer
execution was successfully queued, or one of the errors below:

* `CL_INVALID_COMMAND_BUFFER_KHR` if _command_buffer_ is not a valid
  command-buffer.

* `CL_INVALID_OPERATION` if _command_buffer_ has not been finalized.

* `CL_INVALID_OPERATION` if _command_buffer_ was not created with the
  `CL_COMMAND_BUFFER_SIMULTANEOUS_USE_KHR` flag and is in the <<pending,
  Pending>> state.

* `CL_INVALID_VALUE` if _queues_ is `NULL` and _num_queues_ is > 0, or _queues_
  is not `NULL` and _num_queues_ is 0.

* `CL_INVALID_VALUE` if _num_queues_ is > 0 and not the same value as
  _num_queues_ set on _command_buffer_ creation.

* `CL_INVALID_COMMAND_QUEUE` if _command_queue_ is not a valid command-queue.

* `CL_INCOMPATIBLE_COMMAND_QUEUE_KHR` if any element of _queues_ is not
  <<compatible, compatible>>  with the command-queue set on _command_buffer_
  creation at the same list index.

* `CL_INVALID_CONTEXT` if any element of _queues_ does not have the same
  context as the command-queue set on _command_buffer_ creation at the same list
  index.

* `CL_INVALID_CONTEXT` if context associated with _command_buffer_ and
  events in _event_wait_list_ are not the same.

* `CL_OUT_OF_RESOURCES` if there is a failure to queue the execution instance of
  _command_buffer_ on the command-queues because of insufficient resources
  needed to execute _command_buffer_.

* `CL_INVALID_EVENT_WAIT_LIST` if _event_wait_list_ is `NULL` and
  _num_events_in_wait_list_ > 0, or _event_wait_list_ is not `NULL`
  and _num_events_in_wait_list_ is 0, or if event objects in
  _event_wait_list_ are not valid events.

* `CL_OUT_OF_RESOURCES` if there is a failure to allocate resources required by
  the OpenCL implementation on the device.

* `CL_OUT_OF_HOST_MEMORY` if there is a failure to allocate resources required
  by the OpenCL implementation on the host.

==== Add new section "Section 5.X.3 - Recording Commands to a Command Buffer"

The function
indexterm:[clCommandBarrierWithWaitListKHR]
[source]
----
cl_int clCommandBarrierWithWaitListKHR(
      cl_command_buffer_khr command_buffer,
      cl_command_queue command_queue,
      cl_uint num_sync_points_in_wait_list,
      const cl_sync_point_khr* sync_point_wait_list,
      cl_sync_point_khr* sync_point,
      cl_mutable_command_khr* mutable_handle);
----
Records a barrier operation used as a synchronization point.

[NOTE]
====
*clCommandBarrierWithWaitListKHR* Waits for either a list of
synchronization-points to complete, or if the list is empty it waits for all
commands previously recorded in _command_buffer_ to complete before it
completes. This command blocks command execution, that is, any following
commands recorded after it do not execute until it completes.
====

_command_buffer_ Refers to a valid command-buffer object.

_command_queue_ Specifies the command-queue the command will be recorded to.
Parameter is unused by this extension as only a single command-queue is
supported and **must** be `NULL`.

_sync_point_wait_list_, _num_sync_points_in_wait_list_ Specify
synchronization-points that need to complete before this
particular command can be executed.

If _sync_point_wait_list_ is `NULL`, _num_sync_points_in_wait_list_
must be 0. If _sync_point_wait_list_ is not `NULL`, the list of
synchronization-points pointed to by _sync_point_wait_list_ must be
valid and _num_sync_points_in_wait_list_ must be greater than 0.
The synchronization-points specified in _sync_point_wait_list_ are
*device side* synchronization-points. The command-buffer associated
with synchronization-points in _sync_point_wait_list_ must be the same
as _command_buffer_. The memory associated with _sync_point_wait_list_
can be reused or freed after the function returns.

If _sync_point_wait_list_ is `NULL`, then this particular command
waits until all previous recorded commands to _command_queue_ have
completed.

_sync_point_ Returns a synchronization-point ID that identifies this particular
command. Synchronization-point objects are unique and can be used to
identify this barrier command later on. _sync_point_ can be `NULL` in
which case it will not be possible for the application to record a wait
for this command to complete. If the _sync_point_wait_list_ and the
_sync_point_ arguments are not `NULL`, the _sync_point_ argument
should not refer to an element of the _sync_point_wait_list_ array.

_mutable_handle_ Returns a handle to the command. Handle is unused by
this extension and must be passed as `NULL`.

*clCommandBarrierWithWaitListKHR* returns `CL_SUCCESS` if the function is
executed successfully. Otherwise, it returns one of the following errors:

* `CL_INVALID_COMMAND_QUEUE` if _command_queue_ is not `NULL`.

* `CL_INVALID_COMMAND_BUFFER_KHR` if _command_buffer_ is not a valid
  command-buffer.

* `CL_INVALID_CONTEXT` if the context associated with _command_queue_ and
  _command_buffer_ is not the same.

* `CL_INVALID_OPERATION` if _command_buffer_ has been finalized.

* `CL_INVALID_VALUE` if _mutable_handle_ is not `NULL`.

* `CL_INVALID_SYNC_POINT_WAIT_LIST_KHR` if _sync_point_wait_list_ is `NULL` and
  _num_sync_points_in_wait_list_ is > 0, or _sync_point_wait_list_ is not
  `NULL` and _num_sync_points_in_wait_list_ is 0, or if
  synchronization-point objects in _sync_point_wait_list_ are not valid
  synchronization-points.

* `CL_OUT_OF_RESOURCES` if there is a failure to allocate resources required by
  the OpenCL implementation on the device.

* `CL_OUT_OF_HOST_MEMORY` if there is a failure to allocate resources required by
  the OpenCL implementation on the host.

The function
indexterm:[clCommandCopyBufferKHR]
[source]
----
cl_int clCommandCopyBufferKHR(
    cl_command_buffer_khr command_buffer,
    cl_command_queue command_queue,
    cl_mem src_buffer,
    cl_mem dst_buffer,
    size_t src_offset,
    size_t dst_offset,
    size_t size,
    cl_uint num_sync_points_in_wait_list,
    const cl_sync_point_khr* sync_point_wait_list,
    cl_sync_point_khr* sync_point,
    cl_mutable_command_khr* mutable_handle);
----
Records a command to copy from one buffer object to another.

_command_buffer_ Refers to a valid command-buffer object.

_command_queue_ Specifies the command-queue the command will be recorded to.
Parameter is unused by this extension as only a single command-queue is
supported and **must** be `NULL`.

_src_buffer_, _dst_buffer_, _src_offset_, _dst_offset_, _size_ Refer to
*clEnqueueCopyBuffer*.

_sync_point_wait_list_, _num_sync_points_in_wait_list_ Specify
synchronization-points that need to complete before this
particular command can be executed.

If _sync_point_wait_list_ is `NULL`, _num_sync_points_in_wait_list_
must be 0. If _sync_point_wait_list_ is not `NULL`, the list of
synchronization-points pointed to by _sync_point_wait_list_ must be
valid and _num_sync_points_in_wait_list_ must be greater than 0.
The synchronization-points specified in _sync_point_wait_list_ are
*device side* synchronization-points. The command-buffer associated
with synchronization-points in _sync_point_wait_list_ must be the same
as _command_buffer_. The memory associated with _sync_point_wait_list_
can be reused or freed after the function returns.

_sync_point_ Returns a synchronization-point ID that identifies this particular
command. Synchronization-point objects are unique and can be used to
identify this command later on. _sync_point_ can be `NULL` in which case it
will not be possible for the application to record a wait for this command to
complete. If the _sync_point_wait_list_ and the _sync_point_ arguments are not
`NULL`, the _sync_point_ argument should not refer to an element of the
_sync_point_wait_list_ array.

_mutable_handle_ Returns a handle to the command. Handle is unused by
this extension and must be passed as `NULL`.

*clCommandCopyBufferKHR* returns `CL_SUCCESS` if the function is executed
successfully. Otherwise, it returns the errors defined by
*clEnqueueCopyBuffer* except:

`CL_INVALID_COMMAND_QUEUE` is replaced with:

* `CL_INVALID_COMMAND_QUEUE` if _command_queue_ is not `NULL`.

`CL_INVALID_CONTEXT` is replaced with:

* `CL_INVALID_CONTEXT` if the context associated with _command_queue_,
  _command_buffer_, _src_buffer_, and _dst_buffer_ are not the same.

`CL_INVALID_EVENT_WAIT_LIST` is replaced with:

* `CL_INVALID_SYNC_POINT_WAIT_LIST_KHR` if _sync_point_wait_list_ is `NULL` and
  _num_sync_points_in_wait_list_ is > 0, or _sync_point_wait_list_ is not
  `NULL` and _num_sync_points_in_wait_list_ is 0, or if
  synchronization-point objects in _sync_point_wait_list_ are not valid
  synchronization-points.

New errors:

* `CL_INVALID_COMMAND_BUFFER_KHR` if _command_buffer_ is not a valid
  command-buffer.

* `CL_INVALID_OPERATION` if _command_buffer_ has been finalized.

* `CL_INVALID_VALUE` if _mutable_handle_ is not `NULL`.

The function
indexterm:[clCommandCopyBufferRectKHR]
[source]
----
cl_int clCommandCopyBufferRectKHR(
    cl_command_buffer_khr command_buffer,
    cl_command_queue command_queue,
    cl_mem src_buffer,
    cl_mem dst_buffer,
    const size_t* src_origin,
    const size_t* dst_origin,
    const size_t* region,
    size_t src_row_pitch,
    size_t src_slice_pitch,
    size_t dst_row_pitch,
    size_t dst_slice_pitch,
    cl_uint num_sync_points_in_wait_list,
    const cl_sync_point_khr* sync_point_wait_list,
    cl_sync_point_khr* sync_point,
    cl_mutable_command_khr* mutable_handle);
----
Records a command to copy a rectangular region from a buffer object to another
buffer object.

[NOTE]
====
*clCommandCopyBufferRectKHR* records a command to copy a 2D or 3D rectangular
region from the buffer object identified by _src_buffer_ to a 2D or 3D region
in the buffer object identified by _dst_buffer_. Copying begins at the source
offset and destination offset which are computed as described in the
description for _src_origin_ and _dst_origin_.

Each byte of the region's width is copied from the source offset to the
destination offset. After copying each width, the source and destination
offsets are incremented by their respective source and destination row
pitches. After copying each 2D rectangle, the source and destination offsets
are incremented by their respective source and destination slice pitches.
====

_command_buffer_ Refers to a valid command-buffer object.

_command_queue_ Specifies the command-queue the command will be recorded to.
Parameter is unused by this extension as only a single command-queue is
supported and **must** be `NULL`.

_src_origin_, _dst_origin_, _region_, _src_row_pitch_, _src_slice_pitch_,
_dst_row_pitch_, _dst_slice_pitch_ Refer to *clEnqueueCopyBufferRect*.

_sync_point_wait_list_, _num_sync_points_in_wait_list_ Specify
synchronization-points that need to complete before this
particular command can be executed.

If _sync_point_wait_list_ is `NULL`, _num_sync_points_in_wait_list_
must be 0. If _sync_point_wait_list_ is not `NULL`, the list of
synchronization-points pointed to by _sync_point_wait_list_ must be
valid and _num_sync_points_in_wait_list_ must be greater than 0.
The synchronization-points specified in _sync_point_wait_list_ are
*device side* synchronization-points. The command-buffer associated
with synchronization-points in _sync_point_wait_list_ must be the same
as _command_buffer_. The memory associated with _sync_point_wait_list_
can be reused or freed after the function returns.

_sync_point_ Returns a synchronization-point ID that identifies this particular
command. Synchronization-point objects are unique and can be used to
identify this command later on. _sync_point_ can be `NULL` in which case it
will not be possible for the application to record a wait for this command to
complete. If the _sync_point_wait_list_ and the _sync_point_ arguments are not
`NULL`, the _sync_point_ argument should not refer to an element of the
_sync_point_wait_list_ array.

_mutable_handle_ Returns a handle to the command. Handle is unused by
this extension and must be passed as `NULL`.

*clCommandCopyBufferRectKHR* returns `CL_SUCCESS` if the function is executed
successfully. Otherwise, it returns the errors defined by
*clEnqueueCopyBufferRect* except:

`CL_INVALID_COMMAND_QUEUE` is replaced with:

* `CL_INVALID_COMMAND_QUEUE` if _command_queue_ is not `NULL`.

`CL_INVALID_CONTEXT` is replaced with:

* `CL_INVALID_CONTEXT` if the context associated with _command_queue_,
  _command_buffer_, _src_buffer_, and _dst_buffer_ are not the same.

`CL_INVALID_EVENT_WAIT_LIST` is replaced with:

* `CL_INVALID_SYNC_POINT_WAIT_LIST_KHR` if _sync_point_wait_list_ is `NULL` and
  _num_sync_points_in_wait_list_ is > 0, or _sync_point_wait_list_ is not
  `NULL` and _num_sync_points_in_wait_list_ is 0, or if
  synchronization-point objects in _sync_point_wait_list_ are not valid
  synchronization-points.

New errors:

* `CL_INVALID_COMMAND_BUFFER_KHR` if _command_buffer_ is not a valid
  command-buffer.

* `CL_INVALID_OPERATION` if _command_buffer_ has been finalized.

* `CL_INVALID_VALUE` if _mutable_handle_ is not `NULL`.

The function
indexterm:[clCommandCopyBufferToImageKHR]
[source]
----
cl_int clCommandCopyBufferToImageKHR(
    cl_command_buffer_khr command_buffer,
    cl_command_queue command_queue,
    cl_mem src_buffer,
    cl_mem dst_image,
    size_t src_offset,
    const size_t* dst_origin,
    const size_t* region,
    cl_uint num_sync_points_in_wait_list,
    const cl_sync_point_khr* sync_point_wait_list,
    cl_sync_point_khr* sync_point,
    cl_mutable_command_khr* mutable_handle);
----
Records a command to copy a buffer object to an image object.

_command_buffer_ Refers to a valid command-buffer object.

_command_queue_ Specifies the command-queue the command will be recorded to.
Parameter is unused by this extension as only a single command-queue is
supported and **must** be `NULL`.

_src_buffer_, _dst_image_, _src_offset_, _dst_origin_, _region_ Refer to
*clEnqueueCopyBufferToImage*

_sync_point_wait_list_, _num_sync_points_in_wait_list_ Specify
synchronization-points that need to complete before this
particular command can be executed.

If _sync_point_wait_list_ is `NULL`, _num_sync_points_in_wait_list_
must be 0. If _sync_point_wait_list_ is not `NULL`, the list of
synchronization-points pointed to by _sync_point_wait_list_ must be
valid and _num_sync_points_in_wait_list_ must be greater than 0.
The synchronization-points specified in _sync_point_wait_list_ are
*device side* synchronization-points. The command-buffer associated
with synchronization-points in _sync_point_wait_list_ must be the same
as _command_buffer_. The memory associated with _sync_point_wait_list_
can be reused or freed after the function returns.

_sync_point_ Returns a synchronization-point ID that identifies this particular
command. Synchronization-point objects are unique and can be used to
identify this command later on. _sync_point_ can be `NULL` in which case it
will not be possible for the application to record a wait for this command to
complete. If the _sync_point_wait_list_ and the _sync_point_ arguments are not
`NULL`, the _sync_point_ argument should not refer to an element of the
_sync_point_wait_list_ array.

_mutable_handle_ Returns a handle to the command. Handle is unused by
this extension and must be passed as `NULL`.

*clCommandCopyBufferToImageKHR* returns `CL_SUCCESS` if the function is executed
successfully. Otherwise, it returns the errors defined by
*clEnqueueCopyBufferToImage* except:

`CL_INVALID_COMMAND_QUEUE` is replaced with:

* `CL_INVALID_COMMAND_QUEUE` if _command_queue_ is not `NULL`.

`CL_INVALID_CONTEXT` is replaced with:

* `CL_INVALID_CONTEXT` if the context associated with _command_queue_,
  _command_buffer_, _src_buffer_, and _dst_image_ are not the same.

`CL_INVALID_EVENT_WAIT_LIST` is replaced with:

* `CL_INVALID_SYNC_POINT_WAIT_LIST_KHR` if _sync_point_wait_list_ is `NULL` and
  _num_sync_points_in_wait_list_ is > 0, or _sync_point_wait_list_ is not
  `NULL` and _num_sync_points_in_wait_list_ is 0, or if
  synchronization-point objects in _sync_point_wait_list_ are not valid
  synchronization-points.

New errors:

* `CL_INVALID_COMMAND_BUFFER_KHR` if _command_buffer_ is not a valid
  command-buffer.

* `CL_INVALID_OPERATION` if _command_buffer_ has been finalized.

* `CL_INVALID_VALUE` if _mutable_handle_ is not `NULL`.

The function
indexterm:[clCommandCopyImageKHR]
[source]
----
cl_int clCommandCopyImageKHR(
    cl_command_buffer_khr command_buffer,
    cl_command_queue command_queue,
    cl_mem src_image,
    cl_mem dst_image,
    const size_t* src_origin,
    const size_t* dst_origin,
    const size_t* region,
    cl_uint num_sync_points_in_wait_list,
    const cl_sync_point_khr* sync_point_wait_list,
    cl_sync_point_khr* sync_point,
    cl_mutable_command_khr* mutable_handle);
----
Records a command to copy image objects.

[NOTE]
====
It is currently a requirement that the _src_image_ and _dst_image_ image
memory objects for *clCommandCopyImageKHR* must have the exact same image
format, i.e. the cl_image_format descriptor specified when _src_image_ and
_dst_image_ are created must match.
====

_command_buffer_ Refers to a valid command-buffer object.

_command_queue_ Specifies the command-queue the command will be recorded to.
Parameter is unused by this extension as only a single command-queue is
supported and **must** be `NULL`.

_src_image_, _dst_image_, _src_origin_, _dst_origin_, _region_ Refer to
*clEnqueueCopyImage*.

_sync_point_wait_list_, _num_sync_points_in_wait_list_ Specify
synchronization-points that need to complete before this
particular command can be executed.

If _sync_point_wait_list_ is `NULL`, _num_sync_points_in_wait_list_
must be 0. If _sync_point_wait_list_ is not `NULL`, the list of
synchronization-points pointed to by _sync_point_wait_list_ must be
valid and _num_sync_points_in_wait_list_ must be greater than 0.
The synchronization-points specified in _sync_point_wait_list_ are
*device side* synchronization-points. The command-buffer associated
with synchronization-points in _sync_point_wait_list_ must be the same
as _command_buffer_. The memory associated with _sync_point_wait_list_
can be reused or freed after the function returns.

_sync_point_ Returns a synchronization-point ID that identifies this particular
command. Synchronization-point objects are unique and can be used to
identify this command later on. _sync_point_ can be `NULL` in which case it
will not be possible for the application to record a wait for this command to
complete. If the _sync_point_wait_list_ and the _sync_point_ arguments are not
`NULL`, the _sync_point_ argument should not refer to an element of the
_sync_point_wait_list_ array.

_mutable_handle_ Returns a handle to the command. Handle is unused by
this extension and must be passed as `NULL`.

*clCommandCopyImageKHR* returns `CL_SUCCESS` if the function is executed
successfully. Otherwise, it returns the errors defined by
*clEnqueueCopyImage* except:

`CL_INVALID_COMMAND_QUEUE` is replaced with:

* `CL_INVALID_COMMAND_QUEUE` if _command_queue_ is not `NULL`.

`CL_INVALID_CONTEXT` is replaced with:

* `CL_INVALID_CONTEXT` if the context associated with _command_queue_,
  _command_buffer_, _src_image_, and _dst_image_ are not the same.

`CL_INVALID_EVENT_WAIT_LIST` is replaced with:

* `CL_INVALID_SYNC_POINT_WAIT_LIST_KHR` if _sync_point_wait_list_ is `NULL` and
  _num_sync_points_in_wait_list_ is > 0, or _sync_point_wait_list_ is not
  `NULL` and _num_sync_points_in_wait_list_ is 0, or if
  synchronization-point objects in _sync_point_wait_list_ are not valid
  synchronization-points.

New errors:

* `CL_INVALID_COMMAND_BUFFER_KHR` if _command_buffer_ is not a valid
  command-buffer.

* `CL_INVALID_OPERATION` if _command_buffer_ has been finalized.

* `CL_INVALID_VALUE` if _mutable_handle_ is not `NULL`.

The function
indexterm:[clCommandCopyImageToBufferKHR]
[source]
----
cl_int clCommandCopyImageToBufferKHR(
    cl_command_buffer_khr command_buffer,
    cl_command_queue command_queue,
    cl_mem src_image,
    cl_mem  dst_buffer,
    const size_t* src_origin,
    const size_t* region,
    size_t dst_offset,
    cl_uint num_sync_points_in_wait_list,
    const cl_sync_point_khr* sync_point_wait_list,
    cl_sync_point_khr* sync_point,
    cl_mutable_command_khr* mutable_handle);
----
Records a command to copy an image object to a buffer object.

_command_buffer_ Refers to a valid command-buffer object.

_command_queue_ Specifies the command-queue the command will be recorded to.
Parameter is unused by this extension as only a single command-queue is
supported and **must** be `NULL`.

_src_image_, _dst_buffer_, _src_origin_, _region_, _dst_offset_
Refer to *clEnqueueCopyImageToBuffer*.

_sync_point_wait_list_, _num_sync_points_in_wait_list_ Specify
synchronization-points that need to complete before this
particular command can be executed.

If _sync_point_wait_list_ is `NULL`, _num_sync_points_in_wait_list_
must be 0. If _sync_point_wait_list_ is not `NULL`, the list of
synchronization-points pointed to by _sync_point_wait_list_ must be
valid and _num_sync_points_in_wait_list_ must be greater than 0.
The synchronization-points specified in _sync_point_wait_list_ are
*device side* synchronization-points. The command-buffer associated
with synchronization-points in _sync_point_wait_list_ must be the same
as _command_buffer_. The memory associated with _sync_point_wait_list_
can be reused or freed after the function returns.

_sync_point_ Returns a synchronization-point ID that identifies this particular
command. Synchronization-point objects are unique and can be used to
identify this command later on. _sync_point_ can be `NULL` in which case it
will not be possible for the application to record a wait for this command to
complete. If the _sync_point_wait_list_ and the _sync_point_ arguments are not
`NULL`, the _sync_point_ argument should not refer to an element of the
_sync_point_wait_list_ array.

_mutable_handle_ Returns a handle to the command. Handle is unused by
this extension and must be passed as `NULL`.

*clCommandCopyImageToBufferKHR* returns `CL_SUCCESS` if the function is
executed successfully. Otherwise, it returns the errors defined by
*clEnqueueCopyImageToBuffer* except:

`CL_INVALID_COMMAND_QUEUE` is replaced with:

* `CL_INVALID_COMMAND_QUEUE` if _command_queue_ is not `NULL`.

`CL_INVALID_CONTEXT` is replaced with:

* `CL_INVALID_CONTEXT` if the context associated with _command_queue_,
  _command_buffer_, _src_image_, and _dst_buffer_ are not the same.

`CL_INVALID_EVENT_WAIT_LIST` is replaced with:

* `CL_INVALID_SYNC_POINT_WAIT_LIST_KHR` if _sync_point_wait_list_ is `NULL` and
  _num_sync_points_in_wait_list_ is > 0, or _sync_point_wait_list_ is not
  `NULL` and _num_sync_points_in_wait_list_ is 0, or if
  synchronization-point objects in _sync_point_wait_list_ are not valid
  synchronization-points.

New errors:

* `CL_INVALID_COMMAND_BUFFER_KHR` if _command_buffer_ is not a valid
  command-buffer.

* `CL_INVALID_OPERATION` if _command_buffer_ has been finalized.

* `CL_INVALID_VALUE` if _mutable_handle_ is not `NULL`.

The function
indexterm:[clCommandFillBufferKHR]
[source]
----
cl_int clCommandFillBufferKHR(
    cl_command_buffer_khr command_buffer,
    cl_command_queue command_queue,
    cl_mem buffer,
    const void* pattern,
    size_t pattern_size,
    size_t offset,
    size_t size,
    cl_uint num_sync_points_in_wait_list,
    const cl_sync_point_khr* sync_point_wait_list,
    cl_sync_point_khr* sync_point,
    cl_mutable_command_khr* mutable_handle);
----
Records a command to fill a buffer object with a pattern of a given pattern
size.

[NOTE]
====
The usage information which indicates whether the memory object can be read or
written by a kernel and/or the host and is given by the _cl_mem_flags_ argument
value specified when _buffer_ is created is ignored by
*clCommandFillBufferKHR*.
====

_command_buffer_ Refers to a valid command-buffer object.

_command_queue_ Specifies the command-queue the command will be recorded to.
Parameter is unused by this extension as only a single command-queue is
supported and **must** be `NULL`.

_buffer_, _pattern_, _pattern_size_, _offset_, _size_ Refer to
*clEnqueueFillBuffer*.

_sync_point_wait_list_, _num_sync_points_in_wait_list_ Specify
synchronization-points that need to complete before this
particular command can be executed.

If _sync_point_wait_list_ is `NULL`, _num_sync_points_in_wait_list_
must be 0. If _sync_point_wait_list_ is not `NULL`, the list of
synchronization-points pointed to by _sync_point_wait_list_ must be
valid and _num_sync_points_in_wait_list_ must be greater than 0.
The synchronization-points specified in _sync_point_wait_list_ are
*device side* synchronization-points. The command-buffer associated
with synchronization-points in _sync_point_wait_list_ must be the same
as _command_buffer_. The memory associated with _sync_point_wait_list_
can be reused or freed after the function returns.

_sync_point_ Returns a synchronization-point ID that identifies this particular
command. Synchronization-point objects are unique and can be used to
identify this command later on. _sync_point_ can be `NULL` in which case it
will not be possible for the application to record a wait for this command to
complete. If the _sync_point_wait_list_ and the _sync_point_ arguments are not
`NULL`, the _sync_point_ argument should not refer to an element of the
_sync_point_wait_list_ array.

_mutable_handle_ Returns a handle to the command. Handle is unused by
this extension and must be passed as `NULL`.

*clCommandFillBufferKHR* returns `CL_SUCCESS` if the function is executed
successfully. Otherwise, it returns the errors defined by
*clEnqueueFillBuffer* except:

`CL_INVALID_COMMAND_QUEUE` is replaced with:

* `CL_INVALID_COMMAND_QUEUE` if _command_queue_ is not `NULL`.

`CL_INVALID_CONTEXT` is replaced with:

* `CL_INVALID_CONTEXT` if the context associated with _command_queue_,
  _command_buffer_, and _buffer_ are not the same.

`CL_INVALID_EVENT_WAIT_LIST` is replaced with:

* `CL_INVALID_SYNC_POINT_WAIT_LIST_KHR` if _sync_point_wait_list_ is `NULL` and
  _num_sync_points_in_wait_list_ is > 0, or _sync_point_wait_list_ is not
  `NULL` and _num_sync_points_in_wait_list_ is 0, or if
  synchronization-point objects in _sync_point_wait_list_ are not valid
  synchronization-points.

New errors:

* `CL_INVALID_COMMAND_BUFFER_KHR` if _command_buffer_ is not a valid
  command-buffer.

* `CL_INVALID_OPERATION` if _command_buffer_ has been finalized.

* `CL_INVALID_VALUE` if _mutable_handle_ is not `NULL`.

The function
indexterm:[clCommandFillImageKHR]
[source]
----
cl_int clCommandFillImageKHR(
    cl_command_buffer_khr command_buffer,
    cl_command_queue command_queue,
    cl_mem image,
    const void* fill_color,
    const size_t* origin,
    const size_t* region,
    cl_uint num_sync_points_in_wait_list,
    const cl_sync_point_khr* sync_point_wait_list,
    cl_sync_point_khr* sync_point,
    cl_mutable_command_khr* mutable_handle);
----
Records a command to fill an image object with a specified color.

[NOTE]
====
The usage information which indicates whether the memory object can be read or
written by a kernel and/or the host and is given by the _cl_mem_flags_ argument
value specified when image is created is ignored by *clCommandFillImageKHR*.
====

_command_buffer_ Refers to a valid command-buffer object.

_command_queue_ Specifies the command-queue the command will be recorded to.
Parameter is unused by this extension as only a single command-queue is
supported and **must** be `NULL`.

_image_, _fill_color_, _origin_, _region_ Refer to *clEnqueueFillImage*.

_sync_point_wait_list_, _num_sync_points_in_wait_list_ Specify
synchronization-points that need to complete before this
particular command can be executed.

If _sync_point_wait_list_ is `NULL`, _num_sync_points_in_wait_list_
must be 0. If _sync_point_wait_list_ is not `NULL`, the list of
synchronization-points pointed to by _sync_point_wait_list_ must be
valid and _num_sync_points_in_wait_list_ must be greater than 0.
The synchronization-points specified in _sync_point_wait_list_ are
*device side* synchronization-points. The command-buffer associated
with synchronization-points in _sync_point_wait_list_ must be the same
as _command_buffer_. The memory associated with _sync_point_wait_list_
can be reused or freed after the function returns.

_sync_point_ Returns a synchronization-point ID that identifies this particular
command. Synchronization-point objects are unique and can be used to
identify this command later on. _sync_point_ can be `NULL` in which case it
will not be possible for the application to record a wait for this command to
complete. If the _sync_point_wait_list_ and the _sync_point_ arguments are not
`NULL`, the _sync_point_ argument should not refer to an element of the
_sync_point_wait_list_ array.

_mutable_handle_ Returns a handle to the command. Handle is unused by
this extension and must be passed as `NULL`.

*clCommandFillImageKHR* returns `CL_SUCCESS` if the function is executed
successfully. Otherwise, it returns the errors defined by
*clEnqueueFillImage* except:

`CL_INVALID_COMMAND_QUEUE` is replaced with:

* `CL_INVALID_COMMAND_QUEUE` if _command_queue_ is not `NULL`.

`CL_INVALID_CONTEXT` is replaced with:

* `CL_INVALID_CONTEXT` if the context associated with _command_queue_,
  _command_buffer_, and _image_ are not the same.

`CL_INVALID_EVENT_WAIT_LIST` is replaced with:

* `CL_INVALID_SYNC_POINT_WAIT_LIST_KHR` if _sync_point_wait_list_ is `NULL` and
  _num_sync_points_in_wait_list_ is > 0, or _sync_point_wait_list_ is not
  `NULL` and _num_sync_points_in_wait_list_ is 0, or if
  synchronization-point objects in _sync_point_wait_list_ are not valid
  synchronization-points.

New errors:

* `CL_INVALID_COMMAND_BUFFER_KHR` if _command_buffer_ is not a valid
  command-buffer.

* `CL_INVALID_OPERATION` if _command_buffer_ has been finalized.

* `CL_INVALID_VALUE` if _mutable_handle_ is not `NULL`.

The function
indexterm:[clCommandNDRangeKernelKHR]
[source]
----
cl_int clCommandNDRangeKernelKHR(
    cl_command_buffer_khr command_buffer,
    cl_command_queue command_queue,
    const cl_ndrange_kernel_command_properties_khr* properties,
    cl_kernel kernel,
    cl_uint work_dim,
    const size_t* global_work_offset,
    const size_t* global_work_size,
    const size_t* local_work_size,
    cl_uint num_sync_points_in_wait_list,
    const cl_sync_point_khr* sync_point_wait_list,
    cl_sync_point_khr* sync_point,
    cl_mutable_command_khr* mutable_handle);
----
Records a command to execute a kernel on a device.

[NOTE]
====
The work-group size to be used for _kernel_ can also be specified in the
program source using the
`+__attribute__((reqd_work_group_size(X, Y, Z)))+` qualifier. In this case the
size of work group specified by _local_work_size_ must match the value
specified by the `reqd_work_group_size` `+__attribute__+` qualifier.

These work-group instances are executed in parallel across multiple compute
units or concurrently on the same compute unit.

Each work-item is uniquely identified by a global identifier. The global ID,
which can be read inside the kernel, is computed using the value given by
_global_work_size_ and _global_work_offset_. In addition, a work-item is
also identified within a work-group by a unique local ID. The local ID,
which can also be read by the kernel, is computed using the value given by
_local_work_size_. The starting local ID is always (0, 0, ... 0).
====

_command_buffer_ Refers to a valid command-buffer object.

_command_queue_ Specifies the command-queue the command will be recorded to.
Parameter is unused by this extension as only a single command-queue is
supported and **must** be `NULL`.

_properties_ Specifies a list of properties for the kernel command and their
corresponding values. Each property name is immediately followed by the
corresponding desired value. The list is terminated with 0. If no properties are
required, _properties_ may be `NULL`. This extension does not define any
properties.

_kernel_ A valid kernel object.

_work_dim_, _global_work_offset_, _global_work_size_, _local_work_size_ Refer
to *clEnqueueNDRangeKernel*.

_sync_point_wait_list_, _num_sync_points_in_wait_list_ Specify
synchronization-points that need to complete before this
particular command can be executed.

If _sync_point_wait_list_ is `NULL`, _num_sync_points_in_wait_list_
must be 0. If _sync_point_wait_list_ is not `NULL`, the list of
synchronization-points pointed to by _sync_point_wait_list_ must be
valid and _num_sync_points_in_wait_list_ must be greater than 0.
The synchronization-points specified in _sync_point_wait_list_ are
*device side* synchronization-points. The command-buffer associated
with synchronization-points in _sync_point_wait_list_ must be the same
as _command_buffer_. The memory associated with _sync_point_wait_list_
can be reused or freed after the function returns.

_sync_point_ Returns a synchronization-point ID that identifies this particular
command. Synchronization-point objects are unique and can be used to
identify this command later on. _sync_point_ can be `NULL` in which case it
will not be possible for the application to record a wait for this command to
complete. If the _sync_point_wait_list_ and the _sync_point_ arguments are not
`NULL`, the _sync_point_ argument should not refer to an element of the
_sync_point_wait_list_ array.

_mutable_handle_ Returns a handle to the command. Handle is unused by
this extension and must be passed as `NULL`.

*clCommandNDRangeKernelKHR* returns `CL_SUCCESS` if the function is executed
successfully. Otherwise, it returns the errors defined by
*clEnqueueNDRangeKernel* except:

`CL_INVALID_COMMAND_QUEUE` is replaced with:

* `CL_INVALID_COMMAND_QUEUE` if _command_queue_ is not `NULL`.

`CL_INVALID_CONTEXT` is replaced with:

* `CL_INVALID_CONTEXT` if the context associated with _command_queue_,
  _command_buffer_, and _kernel_ are not the same.

`CL_INVALID_EVENT_WAIT_LIST` is replaced with:

* `CL_INVALID_SYNC_POINT_WAIT_LIST_KHR` if _sync_point_wait_list_ is `NULL` and
  _num_sync_points_in_wait_list_ is > 0, or _sync_point_wait_list_ is not
  `NULL` and _num_sync_points_in_wait_list_ is 0, or if
  synchronization-point objects in _sync_point_wait_list_ are not valid
  synchronization-points.

New errors:

* `CL_INVALID_COMMAND_BUFFER_KHR` if _command_buffer_ is not a valid
  command-buffer.

* `CL_INVALID_VALUE` if values specified in _properties_ are not valid

* `CL_INVALID_OPERATION` if _command_buffer_ has been finalized.

* `CL_INVALID_VALUE` if _mutable_handle_ is not `NULL`.

* `CL_INVALID_OPERATION` if the device associated with _command_queue_ does not
  support `CL_COMMAND_BUFFER_CAPABILITY_KERNEL_PRINTF_KHR` and _kernel_ contains
  a printf call.

* `CL_INVALID_OPERATION` if the device associated with _command_queue_ does not
  support `CL_COMMAND_BUFFER_CAPABILITY_DEVICE_SIDE_ENQUEUE_KHR` and _kernel_
  contains a kernel-enqueue call.

==== Add new section "Section 5.X.4 - Command Buffer Queries"

The function
indexterm:[clGetCommandBufferInfoKHR]
[source]
----
cl_int clGetCommandBufferInfoKHR(
    cl_command_buffer_khr command_buffer,
    cl_command_buffer_info_khr param_name,
    size_t param_value_size,
    void* param_value,
    size_t* param_value_size_ret);
----
Queries information about a command-buffer.

_command_buffer_ Specifies the command-buffer being queried.

_param_name_ Specifies the information to query.

_param_value_size_ Specifies the size in bytes of memory pointed to by
_param_value_. This size must be ≥ size of return type as described in the table
below. If _param_value_ is `NULL`, it is ignored.

_param_value_ A pointer to memory where the appropriate result being queried is
returned. If _param_value_ is `NULL`, it is ignored.

_param_value_size_ret_ Returns the actual size in bytes of data being queried by
_param_value_. If _param_value_size_ret_ is `NULL`, it is ignored.

The list of supported _param_name_ values and the information returned in
_param_value_ by *clGetCommandBufferInfoKHR* is described in the table below.

.*clGetCommandBufferInfoKHR* values
[cols=",,",options="header",]
|====
| *cl_command_buffer_info_khr*
| *Return Type*
| *Description*

| *CL_COMMAND_BUFFER_NUM_QUEUES_KHR*
| cl_uint
| The number of command-queues specified when _command_buffer_ was created.

| *CL_COMMAND_BUFFER_QUEUES_KHR*
| cl_command_queue[]
| Return the list of command-queues specified when the _command_buffer_ was
  created.

| *CL_COMMAND_BUFFER_REFERENCE_COUNT_KHR* footnote:[{fn-reference-count-usage}]
| cl_uint
| Return the _command_buffer_ reference count.

| *CL_COMMAND_BUFFER_STATE_KHR*
| cl_command_buffer_state_khr
| Return the state of _command_buffer_.

  `CL_COMMAND_BUFFER_STATE_RECORDING_KHR` is returned when _command_buffer_ has
  not been finalized.

  `CL_COMMAND_BUFFER_STATE_EXECUTABLE_KHR` is returned when _command_buffer_
  has been finalized and there is not a <<pending, Pending>> instance of
  _command_buffer_ awaiting completion on a command_queue.

  `CL_COMMAND_BUFFER_STATE_PENDING_KHR` is returned when an instance of
  _command_buffer_ has been enqueued for execution but not yet completed.

  `CL_COMMAND_BUFFER_STATE_INVALID_KHR` is returned when _command_buffer_ is
  in an <<invalid, Invalid>> state.

| *CL_COMMAND_BUFFER_PROPERTIES_ARRAY_KHR*
| cl_command_buffer_properties_khr[]
| Return the _properties_ argument specified in *clCreateCommandBufferKHR*.

  If the _properties_ argument specified in *clCreateCommandBufferKHR* used to
  create _command_buffer_ was not `NULL`, the implementation must return the
  values specified in the properties argument.

  If the _properties_ argument specified in *clCreateCommandBufferKHR* used to
  create _command_buffer_ was `NULL`, the implementation may return either a
  _param_value_size_ret_ of 0 (i.e. there is are no properties to be returned),
  or the implementation may return a property value of 0 (where 0 is used to
  terminate the properties list).

|====

*clGetCommandBufferInfoKHR* returns `CL_SUCCESS` if the function is executed
successfully. Otherwise, it returns one of the following errors:

* `CL_INVALID_COMMAND_BUFFER_KHR` if _command_buffer_ is not a valid
  command-buffer.

* `CL_INVALID_VALUE` if _param_name_ is not one of the supported values
  or if size in bytes specified by _param_value_size_ is less than size of
  return type and _param_value_ is not a `NULL` value.

* `CL_OUT_OF_RESOURCES` if there is a failure to allocate resources required by
  the OpenCL implementation on the device.

* `CL_OUT_OF_HOST_MEMORY` if there is a failure to allocate resources required by
  the OpenCL implementation on the host.

=== Modifications to section 5.11 of the OpenCL API Specification

In the opening paragraph add *clEnqueueCommandBufferKHR* to list of commands that
can return an event object.

Add to Table 37, _Event Command Types_:
[cols=",",options="header"]
|====
| Events Created By
| Event Command Type

| `clEnqueueCommandBufferKHR`
| `CL_COMMAND_COMMAND_BUFFER_KHR`
|====

=== Sample Code

[source]
----
  #define CL_CHECK(ERROR)                             \
    if (ERROR) {                                      \
      std::cerr << "OpenCL error: " << ERROR << "\n"; \
      return ERROR;                                   \
    }

  int main() {
    cl_platform_id platform;
    CL_CHECK(clGetPlatformIDs(1, &platform, nullptr));
    cl_device_id device;
    CL_CHECK(clGetDeviceIDs(platform, CL_DEVICE_TYPE_ALL, 1, &device, nullptr));

    cl_int error;
    cl_context context =
        clCreateContext(nullptr, 1, &device, nullptr, nullptr, &error);
    CL_CHECK(error);

    const char* code = R"OpenCLC(
  kernel void vector_addition(global int* tile1, global int* tile2,
                              global int* res) {
    size_t index = get_global_id(0);
    res[index] = tile1[index] + tile2[index];
  }
  )OpenCLC";
    const size_t length = std::strlen(code);

    cl_program program =
        clCreateProgramWithSource(context, 1, &code, &length, &error);
    CL_CHECK(error);

    cl_kernel kernel = clCreateKernel(program, "vector_addition", &error);
    CL_CHECK(error);

    constexpr size_t frame_count = 60;
    constexpr size_t frame_elements = 1024;
    constexpr size_t frame_size = frame_elements * sizeof(cl_int);

    constexpr size_t tile_count = 16;
    constexpr size_t tile_elements = frame_elements / tile_count;
    constexpr size_t tile_size = tile_elements * sizeof(cl_int);

    cl_mem buffer_tile1 =
        clCreateBuffer(context, CL_MEM_READ_ONLY, tile_size, nullptr, &error);
    CL_CHECK(error);
    cl_mem buffer_tile2 =
        clCreateBuffer(context, CL_MEM_READ_ONLY, tile_size, nullptr, &error);
    CL_CHECK(error);
    cl_mem buffer_res =
        clCreateBuffer(context, CL_MEM_WRITE_ONLY, tile_size, nullptr, &error);
    CL_CHECK(error);

    CL_CHECK(clSetKernelArg(kernel, 0, sizeof(buffer_tile1), &buffer_tile1));
    CL_CHECK(clSetKernelArg(kernel, 1, sizeof(buffer_tile2), &buffer_tile2));
    CL_CHECK(clSetKernelArg(kernel, 2, sizeof(buffer_res), &buffer_res));

    cl_command_queue command_queue =
      clCreateCommandQueue(context, device,
                           CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE, &error);
    CL_CHECK(error);

    cl_command_buffer_khr command_buffer =
        clCreateCommandBufferKHR(1, &command_queue, nullptr, &error);
    CL_CHECK(error);

    cl_mem buffer_src1 =
        clCreateBuffer(context, CL_MEM_READ_ONLY, frame_size, nullptr, &error);
    CL_CHECK(error);
    cl_mem buffer_src2 =
        clCreateBuffer(context, CL_MEM_READ_ONLY, frame_size, nullptr, &error);
    CL_CHECK(error);
    cl_mem buffer_dst =
        clCreateBuffer(context, CL_MEM_WRITE_ONLY, frame_size, nullptr, &error);
    CL_CHECK(error);

    cl_sync_point_khr tile_sync_point = 0;
    for (size_t tile_index = 0; tile_index < tile_count; tile_index++) {
      std::array<cl_sync_point_khr, 2> copy_sync_points;
      CL_CHECK(clCommandCopyBufferKHR(command_buffer,
          command_queue, buffer_src1, buffer_tile1, tile_index * tile_size, 0,
          tile_size, tile_sync_point ? 1 : 0,
          tile_sync_point ? &tile_sync_point : nullptr, &copy_sync_points[0]),
          nullptr);
      CL_CHECK(clCommandCopyBufferKHR(command_buffer,
          command_queue, buffer_src2, buffer_tile2, tile_index * tile_size, 0,
          tile_size, tile_sync_point ? 1 : 0,
          tile_sync_point ? &tile_sync_point : nullptr, &copy_sync_points[1]),
          nullptr);

      cl_sync_point_khr nd_sync_point;
      CL_CHECK(clCommandNDRangeKernelKHR(command_buffer,
          command_queue, nullptr, kernel, 1, nullptr, &tile_elements, nullptr,
          copy_sync_points.size(), copy_sync_points.data(), &nd_sync_point,
          nullptr));

      CL_CHECK(clCommandCopyBufferKHR(command_buffer,
          command_queue, buffer_res, buffer_dst, 0, tile_index * tile_size,
          tile_size, 1, &nd_sync_point, &tile_sync_point, nullptr));
    }

    CL_CHECK(clFinalizeCommandBufferKHR(command_buffer));

    std::random_device random_device;
    std::mt19937 random_engine{random_device()};
    std::uniform_int_distribution<cl_int> random_distribution{
        0, std::numeric_limits<cl_int>::max() / 2};
    auto random_generator = [&]() { return random_distribution(random_engine); };

    for (size_t frame_index = 0; frame_index < frame_count; frame_index++) {
      std::array<cl_event, 2> write_src_events;
      std::vector<cl_int> src1(frame_elements);
      std::generate(src1.begin(), src1.end(), random_generator);
      CL_CHECK(clEnqueueWriteBuffer(command_queue, buffer_src1, CL_FALSE, 0,
                                    frame_size, src1.data(), 0, nullptr,
                                    &write_src_events[0]));
      std::vector<cl_int> src2(frame_elements);
      std::generate(src2.begin(), src2.end(), random_generator);
      CL_CHECK(clEnqueueWriteBuffer(command_queue, buffer_src2, CL_FALSE, 0,
                                    frame_size, src2.data(), 0, nullptr,
                                    &write_src_events[1]));

      CL_CHECK(clEnqueueCommandBufferKHR(0, NULL, command_buffer, 2,
                                         write_src_events.data(), nullptr));

      CL_CHECK(clFinish(command_queue));

      CL_CHECK(clReleaseEvent(write_src_event[0]));
      CL_CHECK(clReleaseEvent(write_src_event[1]));
    }

    CL_CHECK(clReleaseCommandBufferKHR(command_buffer));
    CL_CHECK(clReleaseCommandQueue(command_queue));

    CL_CHECK(clReleaseMemObject(buffer_src1));
    CL_CHECK(clReleaseMemObject(buffer_src2));
    CL_CHECK(clReleaseMemObject(buffer_dst));

    CL_CHECK(clReleaseMemObject(buffer_tile1));
    CL_CHECK(clReleaseMemObject(buffer_tile2));
    CL_CHECK(clReleaseMemObject(buffer_res));

    CL_CHECK(clReleaseKernel(kernel));
    CL_CHECK(clReleaseProgram(program));
    CL_CHECK(clReleaseContext(context));

    return 0;
  }
----

=== Issues

. Introduce a `clCloneCommandBufferKHR` entry-point for cloning a
  command-buffer.
+
--
*UNRESOLVED*
--
. Enable detached command-buffer execution, where command-buffers are executed
  on their own internal queue to prevent locking user created queues for the
  duration of their execution.
+
--
*UNRESOLVED*
--

NOTE: This is a preview of an OpenCL provisional extension specification that has been Ratified under the Khronos Intellectual Property Framework. It is being made publicly available prior to being uploaded to the Khronos registry to enable review and feedback from the community. If you have feedback please create an issue on https://github.com/KhronosGroup/OpenCL-Docs/
