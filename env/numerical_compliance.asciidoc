// Copyright 2017-2024 The Khronos Group. This work is licensed under a
// Creative Commons Attribution 4.0 International License; see
// http://creativecommons.org/licenses/by/4.0/

[[numerical_compliance]]
== OpenCL Numerical Compliance

This section describes features of the <<cpp14-spec, {cpp14}>> and
<<ieee-754-spec, IEEE-754>> standards that must be supported by all OpenCL
compliant devices.

This section describes the functionality that must be supported by all
OpenCL devices for single precision floating-point numbers.
Currently, only single precision floating-point is a requirement.
Half precision floating-point is an optional feature indicated by the
*Float16* capability.
Double precision floating-point is also an optional feature indicated by the
*Float64* capability.

=== Rounding Modes

Floating-point calculations may be carried out internally with extra
precision and then rounded to fit into the destination type.
IEEE 754 defines four possible rounding modes:

  * _Round to nearest even_
  * _Round toward +infinity_
  * _Round toward -infinity_
  * _Round toward zero_

The complete set of rounding modes supported by the device are described by
the {CL_DEVICE_SINGLE_FP_CONFIG}, {CL_DEVICE_HALF_FP_CONFIG}, and
{CL_DEVICE_DOUBLE_FP_CONFIG} device queries.

For double precision operations, _Round to nearest even_ is a required
rounding mode, and is therefore the default rounding mode for double
precision operations.

For single precision operations, devices supporting the full profile must
support _Round to nearest even_, therefore for full profile devices this is
the default rounding mode for single precision operations.
Devices supporting the embedded profile may support either _Round to nearest
even_ or _Round toward zero_ as the default rounding mode for single
precision operations.

For half precision operations, devices may support either _Round to nearest
even_ or _Round toward zero_ as the default rounding mode for half precision
operations.

Only static selection of rounding mode is supported.
Dynamically reconfiguring the rounding mode as specified by the IEEE 754
spec is not supported.

=== Rounding Modes for Conversions

Results of the following conversion instructions may include an optional
*FPRoundingMode* decoration:

* *OpConvertFToU*
* *OpConvertFToS*
* *OpConvertSToF*
* *OpConvertUToF*
* *OpFConvert*

The *FPRoundingMode* decoration may not be added to results of any other
instruction.

If no rounding mode is specified explicitly via an *FPRoundingMode*
decoration, then the default rounding mode for conversion operations is:

* _Round to nearest even_, for conversions to floating-point types.
* _Round toward zero_, for conversions from floating-point to integer types.

=== Out-of-Range Conversions

When a conversion operand is either greater than the greatest representable
destination value or less than the least representable destination value,
it is said to be out-of-range.

Converting an out-of-range integer to an integer type without a
*SaturatedConversion* decoration follows <<C99-spec, C99>>/<<cpp14-spec,
C++14>> conversion rules.

Converting an out-of-range floating-point number to an integer type without
a *SaturatedConversion* decoration is implementation-defined.

=== INF, NaN, and Denormalized Numbers

INFs and NaNs must be supported.
Support for signaling NaNs is not required.

Support for denormalized numbers with single precision and half precision
floating-point is optional.
Denormalized single precision or half precision floating-point numbers
passed as the input or produced as the output of single precision or half
precision floating-point operations may be flushed to zero.
Support for denormalized numbers is required for double precision
floating-point.

Support for INFs, NaNs, and denormalized numbers is described by the
{CL_FP_DENORM} and {CL_FP_INF_NAN} bits in the {CL_DEVICE_SINGLE_FP_CONFIG},
{CL_DEVICE_HALF_FP_CONFIG}, and {CL_DEVICE_DOUBLE_FP_CONFIG} device queries.

=== Floating-Point Exceptions

Floating-point exceptions are disabled in OpenCL.
The result of a floating-point exception must match the IEEE 754 spec for
the exceptions-not-enabled case.
Whether and when the implementation sets floating-point flags or raises
floating-point exceptions is implementation-defined.

This standard provides no method for querying, clearing or setting
floating-point flags or trapping raised exceptions.
Due to non-performance, non-portability of trap mechanisms, and the
impracticality of servicing precise exceptions in a vector context
(especially on heterogeneous hardware), such features are discouraged.

Implementations that nevertheless support such operations through an
extension to the standard shall initialize with all exception flags cleared
and the exception masks set so that exceptions raised by arithmetic
operations do not trigger a trap to be taken.
If the underlying work is reused by the implementation, the implementation
is however not responsible for re-clearing the flags or resetting exception
masks to default values before entering the kernel.
That is to say that kernels that do not inspect flags or enable traps are
licensed to expect that their arithmetic will not trigger a trap.
Those kernels that do examine flags or enable traps are responsible for
clearing flag state and disabling all traps before returning control to the
implementation.
Whether or when the underlying work-item (and accompanying global
floating-point state if any) is reused is implementation-defined.

[[relative-error-as-ulps]]
=== Relative Error as ULPs

In this section we discuss the maximum relative error defined as ulp (units
in the last place).
Addition, subtraction, multiplication, fused multiply-add, and conversion
between integer and a single precision floating-point format are IEEE 754
compliant and are therefore correctly rounded.
Conversion between floating-point formats and explicit conversions must be
correctly rounded.

The ULP is defined as follows:
____
If x is a real number that lies between two finite consecutive
floating-point numbers a and b, without being equal to one of them, then
ulp(x) = |b - a|, otherwise ulp(x) is the distance between the two non-equal
finite floating-point numbers nearest x.
Moreover, ulp(NaN) is NaN.
____

Attribution: This definition was taken with consent from Jean-Michel Muller
with slight clarification for behavior at zero.  Refer to: <<ulp-definition,
On the definition of ulp(x)>>.

0 ULP is used for math functions that do not require rounding.
The reference value used to compute the ULP value is the infinitely precise
result.

Result overflow within the specified ULP error is permitted. Math instructions
are allowed to return infinity for a finite reference value when the next
floating-point number that would be representable after the finite maximum, if
there was sufficient range, meets ULP error tolerance.

==== ULP Values for Math Instructions - Full Profile

The ULP Values for Math Instructions - Full Profile table below
describes the minimum accuracy of floating-point math arithmetic instructions
given as ULP values for the full profile.

[[ulp_values_for_math_instructions]]
.ULP Values for Math Instructions - Full Profile
[width="100%",cols="31%,23%,23%,23%",options="header"]
|====
| *SPIR-V Instruction*
| *Minimum Accuracy - Float64*
| *Minimum Accuracy - Float32*
| *Minimum Accuracy - Float16*

| *OpFAdd*
| Correctly rounded
| Correctly rounded
| Correctly rounded

| *OpFSub*
| Correctly rounded
| Correctly rounded
| Correctly rounded

| *OpFMul*
| Correctly rounded
| Correctly rounded
| Correctly rounded

| *OpFDiv*
| Correctly rounded
| \<= 2.5 ulp
| Correctly rounded

| *OpExtInst* *acos*
| \<= 4 ulp
| \<= 4 ulp
| \<= 2 ulp

| *OpExtInst* *acosh*
| \<= 4 ulp
| \<= 4 ulp
| \<= 2 ulp

| *OpExtInst* *acospi*
| \<= 5 ulp
| \<= 5 ulp
| \<= 2 ulp

| *OpExtInst* *asin*
| \<= 4 ulp
| \<= 4 ulp
| \<= 2 ulp

| *OpExtInst* *asinh*
| \<= 4 ulp
| \<= 4 ulp
| \<= 2 ulp

| *OpExtInst* *asinpi*
| \<= 5 ulp
| \<= 5 ulp
| \<= 2 ulp

| *OpExtInst* *atan*
| \<= 5 ulp
| \<= 5 ulp
| \<= 2 ulp

| *OpExtInst* *atanh*
| \<= 5 ulp
| \<= 5 ulp
| \<= 2 ulp

| *OpExtInst* *atanpi*
| \<= 5 ulp
| \<= 5 ulp
| \<= 2 ulp

| *OpExtInst* *atan2*
| \<= 6 ulp
| \<= 6 ulp
| \<= 2 ulp

| *OpExtInst* *atan2pi*
| \<= 6 ulp
| \<= 6 ulp
| \<= 2 ulp

| *OpExtInst* *cbrt*
| \<= 2 ulp
| \<= 2 ulp
| \<= 2 ulp

| *OpExtInst* *ceil*
| Correctly rounded
| Correctly rounded
| Correctly rounded

| *OpExtInst* *copysign*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *cos*
| \<= 4 ulp
| \<= 4 ulp
| \<= 2 ulp

| *OpExtInst* *cosh*
| \<= 4 ulp
| \<= 4 ulp
| \<= 2 ulp

| *OpExtInst* *cospi*
| \<= 4 ulp
| \<= 4 ulp
| \<= 2 ulp

// 3 operations from the 2 multiplications and 1 subtraction per component
| *OpExtInst* *cross*
| absolute error tolerance of 'max * max * (3 * FLT_EPSILON)' per vector component, where _max_ is the maximum input operand magnitude
| absolute error tolerance of 'max * max * (3 * FLT_EPSILON)' per vector component, where _max_ is the maximum input operand magnitude
| absolute error tolerance of 'max * max * (3 * HALF_EPSILON)' per vector component, where _max_ is the maximum input operand magnitude

| *OpExtInst* *degrees*
| \<= 2 ulp
| \<= 2 ulp
| \<= 2 ulp

| *OpExtInst* *distance*
// See ext/cl_khr_fp64.asciidoc for derivation
| \<= 5.5 + 2n ulp, for gentype with vector width _n_
// See OpenCL_C.txt derivation
| \<= 2.5 + 2n ulp, for gentype with vector width _n_
// See ext/cl_khr_fp16.asciidoc for derivation
| \<= 2n ulp, for gentype with vector width _n_

// n + n-1  Number of operations from n multiples and (n-1) additions
// 2n - 1
| *OpDot*
| absolute error tolerance of 'max * max * (2n - 1) * FLT_EPSILON', for vector width _n_ and maximum input operand magnitude _max_ across all vector components
| absolute error tolerance of 'max * max * (2n - 1) * FLT_EPSILON', for vector width _n_ and maximum input operand magnitude _max_ across all vector components
| absolute error tolerance of 'max * max * (2n - 1) * HALF_EPSILON', for vector width _n_ and maximum input operand magnitude _max_ across all vector components

| *OpExtInst* *erfc*
| \<= 16 ulp
| \<= 16 ulp
| \<= 4 ulp

| *OpExtInst* *erf*
| \<= 16 ulp
| \<= 16 ulp
| \<= 4 ulp

| *OpExtInst* *exp*
| \<= 3 ulp
| \<= 3 ulp
| \<= 2 ulp

| *OpExtInst* *exp2*
| \<= 3 ulp
| \<= 3 ulp
| \<= 2 ulp

| *OpExtInst* *exp10*
| \<= 3 ulp
| \<= 3 ulp
| \<= 2 ulp

| *OpExtInst* *expm1*
| \<= 3 ulp
| \<= 3 ulp
| \<= 2 ulp

| *OpExtInst* *fabs*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *fclamp*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *fdim*
| Correctly rounded
| Correctly rounded
| Correctly rounded

| *OpExtInst* *floor*
| Correctly rounded
| Correctly rounded
| Correctly rounded

| *OpExtInst* *fma*
| Correctly rounded
| Correctly rounded
| Correctly rounded

| *OpExtInst* *fmax*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *fmax_common*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *fmin*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *fmin_common*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *fmod*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *fract*
| Correctly rounded
| Correctly rounded
| Correctly rounded

| *OpExtInst* *frexp*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *hypot*
| \<= 4 ulp
| \<= 4 ulp
| \<= 2 ulp

| *OpExtInst* *ilogb*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *ldexp*
| Correctly rounded
| Correctly rounded
| Correctly rounded

| *OpExtInst* *length*
// See ext/cl_khr_fp64.asciidoc for derivation
| \<= 5.5 + n ulp, for gentype with vector width _n_
// See OpenCL_C.txt derivation
| \<= 2.75 + 0.5n ulp, for gentype with vector width _n_
// See ext/cl_khr_fp16.asciidoc for derivation
| \<= 0.25 + 0.5n ulp, for gentype with vector width _n_

| *OpExtInst* *lgamma*
| Implementation-defined
| Implementation-defined
| Implementation-defined

| *OpExtInst* *lgamma_r*
| Implementation-defined
| Implementation-defined
| Implementation-defined

| *OpExtInst* *log*
| \<= 3 ulp
| \<= 3 ulp
| \<= 2 ulp

| *OpExtInst* *log2*
| \<= 3 ulp
| \<= 3 ulp
| \<= 2 ulp

| *OpExtInst* *log10*
| \<= 3 ulp
| \<= 3 ulp
| \<= 2 ulp

| *OpExtInst* *log1p*
| \<= 2 ulp
| \<= 2 ulp
| \<= 2 ulp

| *OpExtInst* *logb*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *mad*
| Implemented either as a correctly rounded fma, or as a multiply followed
  by an add, both of which are correctly rounded
| Implemented either as a correctly rounded fma, or as a multiply followed
  by an add, both of which are correctly rounded
| Implemented either as a correctly rounded fma, or as a multiply followed
  by an add, both of which are correctly rounded

| *OpExtInst* *maxmag*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *minmag*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *mix*
| Implementation-defined
| absolute error tolerance of 1e-3
| Implementation-defined

| *OpExtInst* *modf*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *nan*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *nextafter*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *normalize*
// See ext/cl_khr_fp64.asciidoc for derivation
| \<= 4.5 + n ulp, for gentype with vector width _n_
// See OpenCL_C.txt derivation
| \<= 2 + n ulp, for gentype with vector width _n_
// See ext/cl_khr_fp16.asciidoc for derivation
| \<= 1 + n ulp, for gentype with vector width _n_

| *OpExtInst* *pow*
| \<= 16 ulp
| \<= 16 ulp
| \<= 4 ulp

| *OpExtInst* *pown*
| \<= 16 ulp
| \<= 16 ulp
| \<= 4 ulp

| *OpExtInst* *powr*
| \<= 16 ulp
| \<= 16 ulp
| \<= 4 ulp

| *OpExtInst* *radians*
| \<= 2 ulp
| \<= 2 ulp
| \<= 2 ulp

| *OpExtInst* *remainder*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *remquo*
| 0 ulp for the remainder, at least the lower 7 bits of the integral quotient
| 0 ulp for the remainder, at least the lower 7 bits of the integral quotient
| 0 ulp for the remainder, at least the lower 7 bits of the integral quotient

| *OpExtInst* *rint*
| Correctly rounded
| Correctly rounded
| Correctly rounded

| *OpExtInst* *rootn*
| \<= 16 ulp
| \<= 16 ulp
| \<= 4 ulp

| *OpExtInst* *round*
| Correctly rounded
| Correctly rounded
| Correctly rounded

| *OpExtInst* *rsqrt*
| \<= 2 ulp
| \<= 2 ulp
| \<= 1 ulp

| *OpExtInst* *sign*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *sin*
| \<= 4 ulp
| \<= 4 ulp
| \<= 2 ulp

| *OpExtInst* *sincos*
| \<= 4 ulp for sine and cosine values
| \<= 4 ulp for sine and cosine values
| \<= 2 ulp for sine and cosine values

| *OpExtInst* *sinh*
| \<= 4 ulp
| \<= 4 ulp
| \<= 2 ulp

| *OpExtInst* *sinpi*
| \<= 4 ulp
| \<= 4 ulp
| \<= 2 ulp

| *OpExtInst* *smoothstep*
| Implementation-defined
| absolute error tolerance of 1e-5
| Implementation-defined

| *OpExtInst* *sqrt*
| Correctly rounded
| \<= 3 ulp
| Correctly rounded

| *OpExtInst* *step*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *tan*
| \<= 5 ulp
| \<= 5 ulp
| \<= 2 ulp

| *OpExtInst* *tanh*
| \<= 5 ulp
| \<= 5 ulp
| \<= 2 ulp

| *OpExtInst* *tanpi*
| \<= 6 ulp
| \<= 6 ulp
| \<= 2 ulp

| *OpExtInst* *tgamma*
| \<= 16 ulp
| \<= 16 ulp
| \<= 4 ulp

| *OpExtInst* *trunc*
| Correctly rounded
| Correctly rounded
| Correctly rounded

| *OpExtInst* *half_cos*
|
| \<= 8192 ulp
|

| *OpExtInst* *half_divide*
|
| \<= 8192 ulp
|

| *OpExtInst* *half_exp*
|
| \<= 8192 ulp
|

| *OpExtInst* *half_exp2*
|
| \<= 8192 ulp
|

| *OpExtInst* *half_exp10*
|
| \<= 8192 ulp
|

| *OpExtInst* *half_log*
|
| \<= 8192 ulp
|

| *OpExtInst* *half_log2*
|
| \<= 8192 ulp
|

| *OpExtInst* *half_log10*
|
| \<= 8192 ulp
|

| *OpExtInst* *half_powr*
|
| \<= 8192 ulp
|

| *OpExtInst* *half_recip*
|
| \<= 8192 ulp
|

| *OpExtInst* *half_rsqrt*
|
| \<= 8192 ulp
|

| *OpExtInst* *half_sin*
|
| \<= 8192 ulp
|

| *OpExtInst* *half_sqrt*
|
| \<= 8192 ulp
|

| *OpExtInst* *half_tan*
|
| \<= 8192 ulp
|

// See OpenCL_C.txt derivation
| *OpExtInst* *fast_distance*
|
| \<= 8191.5 + 2n ulp, for gentype with vector width _n_
|

// See OpenCL_C.txt derivation
| *OpExtInst* *fast_length*
|
| \<= 8191.5 + n ulp, for gentype with vector width _n_
|

// See OpenCL_C.txt derivation
| *OpExtInst* *fast_normalize*
|
| \<= 8192 + n ulp, for gentype with vector width _n_
|

| *OpExtInst* *native_cos*
|
| Implementation-defined
|

| *OpExtInst* *native_divide*
|
| Implementation-defined
|

| *OpExtInst* *native_exp*
|
| Implementation-defined
|

| *OpExtInst* *native_exp2*
|
| Implementation-defined
|

| *OpExtInst* *native_exp10*
|
| Implementation-defined
|

| *OpExtInst* *native_log*
|
| Implementation-defined
|

| *OpExtInst* *native_log2*
|
| Implementation-defined
|

| *OpExtInst* *native_log10*
|
| Implementation-defined
|

| *OpExtInst* *native_powr*
|
| Implementation-defined
|

| *OpExtInst* *native_recip*
|
| Implementation-defined
|

| *OpExtInst* *native_rsqrt*
|
| Implementation-defined
|

| *OpExtInst* *native_sin*
|
| Implementation-defined
|

| *OpExtInst* *native_sqrt*
|
| Implementation-defined
|

| *OpExtInst* *native_tan*
|
| Implementation-defined
|

|====

==== ULP Values for Math Instructions - Embedded Profile

The ULP Values for Math instructions - Embedded Profile table below
describes the minimum accuracy of floating-point math arithmetic instructions
given as ULP values for the embedded profile.

[[ulp_values_for_math_instructions_for_embedded_profile]]
.ULP Values for Math Instructions - Embedded Profile
[width="100%",cols="31%,23%,23%,23%",options="header"]
|====
| *SPIR-V Instruction*
| *Minimum Accuracy - Float64*
| *Minimum Accuracy - Float32*
| *Minimum Accuracy - Float16*

| *OpFAdd*
| Correctly rounded
| Correctly rounded
| Correctly rounded

| *OpFSub*
| Correctly rounded
| Correctly rounded
| Correctly rounded

| *OpFMul*
| Correctly rounded
| Correctly rounded
| Correctly rounded

| *OpFDiv*
// TODO: For both Float32 and Float64?
| \<= 3 ulp
| \<= 3 ulp
| \<= 1 ulp

| *OpExtInst* *acos*
| \<= 4 ulp
| \<= 4 ulp
| \<= 3 ulp

| *OpExtInst* *acosh*
| \<= 4 ulp
| \<= 4 ulp
| \<= 3 ulp

| *OpExtInst* *acospi*
| \<= 5 ulp
| \<= 5 ulp
| \<= 3 ulp

| *OpExtInst* *asin*
| \<= 4 ulp
| \<= 4 ulp
| \<= 3 ulp

| *OpExtInst* *asinh*
| \<= 4 ulp
| \<= 4 ulp
| \<= 3 ulp

| *OpExtInst* *asinpi*
| \<= 5 ulp
| \<= 5 ulp
| \<= 3 ulp

| *OpExtInst* *atan*
| \<= 5 ulp
| \<= 5 ulp
| \<= 3 ulp

| *OpExtInst* *atanh*
| \<= 5 ulp
| \<= 5 ulp
| \<= 3 ulp

| *OpExtInst* *atanpi*
| \<= 5 ulp
| \<= 5 ulp
| \<= 3 ulp

| *OpExtInst* *atan2*
| \<= 6 ulp
| \<= 6 ulp
| \<= 3 ulp

| *OpExtInst* *atan2pi*
| \<= 6 ulp
| \<= 6 ulp
| \<= 3 ulp

| *OpExtInst* *cbrt*
| \<= 4 ulp
| \<= 4 ulp
| \<= 2 ulp

| *OpExtInst* *ceil*
| Correctly rounded
| Correctly rounded
| Correctly rounded

| *OpExtInst* *copysign*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *cos*
| \<= 4 ulp
| \<= 4 ulp
| \<= 2 ulp

| *OpExtInst* *cosh*
| \<= 4 ulp
| \<= 4 ulp
| \<= 3 ulp

| *OpExtInst* *cospi*
| \<= 4 ulp
| \<= 4 ulp
| \<= 2 ulp

| *OpExtInst* *cross*
| Implementation-defined
| Implementation-defined
| Implementation-defined

| *OpExtInst* *degrees*
| \<= 2 ulp
| \<= 2 ulp
| \<= 2 ulp

| *OpExtInst* *distance*
| Implementation-defined
| Implementation-defined
| Implementation-defined

| *OpDot*
| Implementation-defined
| Implementation-defined
| Implementation-defined

| *OpExtInst* *erfc*
| \<= 16 ulp
| \<= 16 ulp
| \<= 4 ulp

| *OpExtInst* *erf*
| \<= 16 ulp
| \<= 16 ulp
| \<= 4 ulp

| *OpExtInst* *exp*
| \<= 4 ulp
| \<= 4 ulp
| \<= 3 ulp

| *OpExtInst* *exp2*
| \<= 4 ulp
| \<= 4 ulp
| \<= 3 ulp

| *OpExtInst* *exp10*
| \<= 4 ulp
| \<= 4 ulp
| \<= 3 ulp

| *OpExtInst* *expm1*
| \<= 4 ulp
| \<= 4 ulp
| \<= 3 ulp

| *OpExtInst* *fabs*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *fclamp*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *fdim*
| Correctly rounded
| Correctly rounded
| Correctly rounded

| *OpExtInst* *floor*
| Correctly rounded
| Correctly rounded
| Correctly rounded

| *OpExtInst* *fma*
| Correctly rounded
| Correctly rounded
| Correctly rounded

| *OpExtInst* *fmax*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *fmax_common*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *fmin*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *fmin_common*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *fmod*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *fract*
| Correctly rounded
| Correctly rounded
| Correctly rounded

| *OpExtInst* *frexp*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *hypot*
| \<= 4 ulp
| \<= 4 ulp
| \<= 3 ulp

| *OpExtInst* *ilogb*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *ldexp*
| Correctly rounded
| Correctly rounded
| Correctly rounded

| *OpExtInst* *length*
| Implementation-defined
| Implementation-defined
| Implementation-defined

| *OpExtInst* *lgamma*
| Implementation-defined
| Implementation-defined
| Implementation-defined

| *OpExtInst* *lgamma_r*
| Implementation-defined
| Implementation-defined
| Implementation-defined

| *OpExtInst* *log*
| \<= 4 ulp
| \<= 4 ulp
| \<= 3 ulp

| *OpExtInst* *log2*
| \<= 4 ulp
| \<= 4 ulp
| \<= 3 ulp

| *OpExtInst* *log10*
| \<= 4 ulp
| \<= 4 ulp
| \<= 3 ulp

| *OpExtInst* *log1p*
| \<= 4 ulp
| \<= 4 ulp
| \<= 3 ulp

| *OpExtInst* *logb*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *mad*
| Implementation-defined
| Implementation-defined
| Implementation-defined

| *OpExtInst* *maxmag*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *minmag*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *mix*
| Implementation-defined
| Implementation-defined
| Implementation-defined

| *OpExtInst* *modf*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *nan*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *nextafter*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *normalize*
| Implementation-defined
| Implementation-defined
| Implementation-defined

| *OpExtInst* *pow*
| \<= 16 ulp
| \<= 16 ulp
| \<= 5 ulp

| *OpExtInst* *pown*
| \<= 16 ulp
| \<= 16 ulp
| \<= 5 ulp

| *OpExtInst* *powr*
| \<= 16 ulp
| \<= 16 ulp
| \<= 5 ulp

| *OpExtInst* *radians*
| \<= 2 ulp
| \<= 2 ulp
| \<= 2 ulp

| *OpExtInst* *remainder*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *remquo*
| 0 ulp for the remainder, at least the lower 7 bits of the integral quotient
| 0 ulp for the remainder, at least the lower 7 bits of the integral quotient
| 0 ulp for the remainder, at least the lower 7 bits of the integral quotient

| *OpExtInst* *rint*
| Correctly rounded
| Correctly rounded
| Correctly rounded

| *OpExtInst* *rootn*
| \<= 16 ulp
| \<= 16 ulp
| \<= 5 ulp

| *OpExtInst* *round*
| Correctly rounded
| Correctly rounded
| Correctly rounded

| *OpExtInst* *rsqrt*
| \<= 4 ulp
| \<= 4 ulp
| \<= 1 ulp

| *OpExtInst* *sign*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *sin*
| \<= 4 ulp
| \<= 4 ulp
| \<= 2 ulp

| *OpExtInst* *sincos*
| \<= 4 ulp for sine and cosine values
| \<= 4 ulp for sine and cosine values
| \<= 2 ulp for sine and cosine values

| *OpExtInst* *sinh*
| \<= 4 ulp
| \<= 4 ulp
| \<= 3 ulp

| *OpExtInst* *sinpi*
| \<= 4 ulp
| \<= 4 ulp
| \<= 2 ulp

| *OpExtInst* *smoothstep*
| Implementation-defined
| Implementation-defined
| Implementation-defined

// TODO: For both Float32 and Float64?
| *OpExtInst* *sqrt*
| \<= 4 ulp
| \<= 4 ulp
| \<= 1 ulp

| *OpExtInst* *step*
| 0 ulp
| 0 ulp
| 0 ulp

| *OpExtInst* *tan*
| \<= 5 ulp
| \<= 5 ulp
| \<= 3 ulp

| *OpExtInst* *tanh*
| \<= 5 ulp
| \<= 5 ulp
| \<= 3 ulp

| *OpExtInst* *tanpi*
| \<= 6 ulp
| \<= 6 ulp
| \<= 3 ulp

| *OpExtInst* *tgamma*
| \<= 16 ulp
| \<= 16 ulp
| \<= 4 ulp

| *OpExtInst* *trunc*
| Correctly rounded
| Correctly rounded
| Correctly rounded

| *OpExtInst* *half_cos*
|
| \<= 8192 ulp
|

| *OpExtInst* *half_divide*
|
| \<= 8192 ulp
|

| *OpExtInst* *half_exp*
|
| \<= 8192 ulp
|

| *OpExtInst* *half_exp2*
|
| \<= 8192 ulp
|

| *OpExtInst* *half_exp10*
|
| \<= 8192 ulp
|

| *OpExtInst* *half_log*
|
| \<= 8192 ulp
|

| *OpExtInst* *half_log2*
|
| \<= 8192 ulp
|

| *OpExtInst* *half_log10*
|
| \<= 8192 ulp
|

| *OpExtInst* *half_powr*
|
| \<= 8192 ulp
|

| *OpExtInst* *half_recip*
|
| \<= 8192 ulp
|

| *OpExtInst* *half_rsqrt*
|
| \<= 8192 ulp
|

| *OpExtInst* *half_sin*
|
| \<= 8192 ulp
|

| *OpExtInst* *half_sqrt*
|
| \<= 8192 ulp
|

| *OpExtInst* *half_tan*
|
| \<= 8192 ulp
|

| *OpExtInst* *fast_distance*
|
| Implementation-defined
|

| *OpExtInst* *fast_length*
|
| Implementation-defined
|

| *OpExtInst* *fast_normalize*
|
| Implementation-defined
|

| *OpExtInst* *native_cos*
|
| Implementation-defined
|

| *OpExtInst* *native_divide*
|
| Implementation-defined
|

| *OpExtInst* *native_exp*
|
| Implementation-defined
|

| *OpExtInst* *native_exp2*
|
| Implementation-defined
|

| *OpExtInst* *native_exp10*
|
| Implementation-defined
|

| *OpExtInst* *native_log*
|
| Implementation-defined
|

| *OpExtInst* *native_log2*
|
| Implementation-defined
|

| *OpExtInst* *native_log10*
|
| Implementation-defined
|

| *OpExtInst* *native_powr*
|
| Implementation-defined
|

| *OpExtInst* *native_recip*
|
| Implementation-defined
|

| *OpExtInst* *native_rsqrt*
|
| Implementation-defined
|

| *OpExtInst* *native_sin*
|
| Implementation-defined
|

| *OpExtInst* *native_sqrt*
|
| Implementation-defined
|

| *OpExtInst* *native_tan*
|
| Implementation-defined
|

|====

==== ULP Values for Math Instructions - Unsafe Math Optimizations Enabled

The ULP Values for Math Instructions with Unsafe Math Optimizations table below
describes the minimum accuracy of commonly used single precision
floating-point math arithmetic instructions given as ULP values if the
_-cl-unsafe-math-optimizations_ compiler option is specified when compiling or
building the OpenCL program.

For derived implementations, the operations used in the derivation may
themselves be relaxed according to the ULP Values for Math Instructions with
Unsafe Math Optimizations table.

The minimum accuracy of math functions not defined in the ULP Values for
Math Instructions with Unsafe Math Optimizations table when the
_-cl-unsafe-math-optimizations_ compiler option is specified is as defined in the
<<ulp_values_for_math_instructions,ULP Values for Math Instructions for Full
Profile>> table when operating in the full profile, and as defined in the
<<ulp_values_for_math_instructions_for_embedded_profile,ULP Values for Math
instructions for Embedded Profile>> table when operating in the embedded
profile.

[[ulp_values_for_math_instructions_with_fast_relaxed_math]]
.ULP Values for Single Precision Math Instructions with _-cl-unsafe-math-optimizations_
[width="100%",cols="30%,70%",options="header"]
|====
| *Function*
| *Minimum Accuracy*

| *OpFDiv* for 1.0 / _x_
    | {leq} 2.5 ulp for _x_ in the domain of 2^-126^ to 2^126^ for the full
      profile, and {leq} 3 ulp for the embedded profile.

| *OpFDiv* for _x_ / _y_
    | {leq} 2.5 ulp for _x_ in the domain of 2^-62^ to 2^62^ and _y_ in the
      domain of 2^-62^ to 2^62^ for the full profile, and {leq} 3 ulp for
      the embedded profile.

| *OpExtInst* *acos*
    | {leq} 4096 ulp

| *OpExtInst* *acosh*
    | Derived implementations may implement as *log*(_x_ + *sqrt*(_x_ * _x_ - 1)).
      For non-derived implementations, the error is {leq} 8192 ulp.

| *OpExtInst* *acospi*
    | Derived implementations may implement as *acos*(_x_) * `M_PI_F`.
      For non-derived implementations, the error is {leq} 8192 ulp.

| *OpExtInst* *asin*
    | {leq} 4096 ulp

| *OpExtInst* *asinh*
    | Derived implementations may implement as *log*(_x_ + *sqrt*(_x_ * _x_ + 1)).
      For non-derived implementations, the error is {leq} 8192 ulp.

| *OpExtInst* *asinpi*
    | Derived implementations may implement as *asin*(_x_) * `M_PI_F`.
      For non-derived implementations, the error is {leq} 8192 ulp.

| *OpExtInst* *atan*
    | {leq} 4096 ulp

| *OpExtInst* *atanh*
    | Defined for _x_ in the domain (-1, 1).
      For _x_ in [-2^-10^, 2^-10^], derived implementations may implement as _x_.
      For _x_ outside of [-2^-10^, 2^-10^], derived implementations may implement as
      0.5f * *log*\((1.0f + _x_) / (1.0f - _x_)).
      For non-derived implementations, the error is {leq} 8192 ulp.

| *OpExtInst* *atanpi*
    | Derived implementations may implement as *atan*(_x_) * `M_1_PI_F`.
      For non-derived implementations, the error is {leq} 8192 ulp.

| *OpExtInst* *atan2*
    | Derived implementations may implement as *atan*(_y_ / _x_) for _x_ > 0,
      *atan*(_y_ / _x_) + `M_PI_F` for _x_ < 0 and _y_ > 0, and
      *atan*(_y_ / _x_) - `M_PI_F` for _x_ < 0 and _y_ < 0.

| *OpExtInst* *atan2pi*
    | Derived implementations may implement as *atan2*(_y_, _x_) * `M_1_PI_F`.
      For non-derived implementations, the error is {leq} 8192 ulp.

| *OpExtInst* *cbrt*
    | Derived implementations may implement as *rootn*(_x_, 3).
      For non-derived implementations, the error is {leq} 8192 ulp.

| *OpExtInst* *cos*
    | For _x_ in the domain [-{pi}, {pi}], the maximum absolute error
      is {leq} 2^-11^ and larger otherwise.

| *OpExtInst* *cosh*
    | Defined for _x_ in the domain [-88, 88].
      Derived implementations may implement as 0.5f * (*exp*(_x_) + *exp*(-_x_)).
      For non-derived implementations, the error is {leq} 8192 ulp.

| *OpExtInst* *cospi*
    | For _x_ in the domain [-1, 1], the maximum absolute error is {leq}
      2^-11^ and larger otherwise.

| *OpExtInst* *exp*
    | {leq} 3 + *floor*(*fabs*(2 * _x_)) ulp for the full profile, and {leq}
      4 ulp for the embedded profile.

| *OpExtInst* *exp2*
    | {leq} 3 + *floor*(*fabs*(2 * _x_)) ulp for the full profile, and {leq}
      4 ulp for the embedded profile.

| *OpExtInst* *exp10*
    | Derived implementations may implement as *exp2*(_x_ * *log2*(10)).
      For non-derived implementations, the error is {leq} 8192 ulp.

| *OpExtInst* *expm1*
    | Derived implementations may implement as *exp*(_x_) - 1.
      For non-derived implementations, the error is {leq} 8192 ulp.

| *OpExtInst* *log*
    | For _x_ in the domain [0.5, 2] the maximum absolute error is {leq}
      2^-21^; otherwise the maximum error is {leq} 3 ulp for the full profile
      and {leq} 4 ulp for the embedded profile.

| *OpExtInst* *log2*
    | For _x_ in the domain [0.5, 2] the maximum absolute error is {leq}
      2^-21^; otherwise the maximum error is {leq} 3 ulp for the full profile
      and {leq} 4 ulp for the embedded profile.

| *OpExtInst* *log10*
    | For _x_ in the domain [0.5, 2] the maximum absolute error is {leq}
      2^-21^; otherwise the maximum error is {leq} 3 ulp for the full profile
      and {leq} 4 ulp for the embedded profile.

| *OpExtInst* *log1p*
    | Derived implementations may implement as *log*(_x_ + 1).
      For non-derived implementations, the error is {leq} 8192 ulp.

| *OpExtInst* *pow*
    | Undefined for _x_ = 0 and _y_ = 0.
      Undefined for _x_ < 0 and non-integer _y_.
      Undefined for _x_ < 0 and _y_ outside the domain [-2^24^, 2^24^].
      For _x_ > 0 or _x_ < 0 and even _y_, derived implementations may implement as
      *exp2*(_y_ * *log2*(*fabs*(_x_))).
      For _x_ < 0 and odd _y_, derived implementations may implement as
      -*exp2*(_y_ * *log2*(*fabs*(_x_)).
      For _x_ == 0 and non-zero _y_, for derived implementations may return zero.
      For non-derived implementations, the error is {leq} 8192 ulp.

      On some implementations, powr() or pown() may perform faster
      than pow().
      If x is known to be >= 0, consider using powr() in place of pow(),
      or if y is known to be an integer, consider using pown() in place of
      pow().

| *OpExtInst* *pown*
    | Defined only for integer values of _y_.
      Undefined for _x_ = 0 and _y_ = 0.
      For _x_ >= 0 or _x_ < 0 and even _y_, derived implementations may implement as
      *exp2*(_y_ * *log2*(*fabs*(_x_))).
      For _x_ < 0 and odd _y_, derived implementations may implement as
      -*exp2*(_y_ * *log2*(*fabs*(_x_))).
      For non-derived implementations, the error is {leq} 8192 ulp.

| *OpExtInst* *powr*
    | Defined only for _x_ >= 0.
      Undefined for _x_ = 0 and _y_ = 0.
      Derived implementations may implement as *exp2*(_y_ * *log2*(_x_)).
      For non-derived implementations, the error is {leq} 8192 ulp.

| *OpExtInst* *rootn*
    | Defined for _x_ > 0 when _y_ is non-zero, derived implementations
      may implement this case as *exp2*(*log2*(_x_) / _y_).
      Defined for _x_ < 0 when _y_ is odd, derived implementations
      may implement this case as -*exp2*(*log2*(-_x_) / _y_).
      Defined for _x_ = +/-0 when _y_ > 0, derived implementations may
      return +0 in this case.
      For non-derived implementations, the error is {leq} 8192 ulp.

| *OpExtInst* *sin*
    | For _x_ in the domain [-{pi}, {pi}], the maximum absolute error is
      {leq} 2^-11^ and larger otherwise.

| *OpExtInst* *sincos*
    | ulp values as defined for *sin*(_x_) and *cos*(_x_).

| *OpExtInst* *sinh*
    | Defined for _x_ in the domain [-88, 88].
      For _x_ in [-2^-10^, 2^-10^], derived implementations
      may implement as _x_.
      For _x_ outside of [-2^-10^, 2^-10^], derived implementations
      may implement as 0.5f * (*exp*(_x_) - *exp*(-_x_)).
      For non-derived implementations, the error is {leq} 8192 ulp.

| *OpExtInst* *sinpi*
    | For _x_ in the domain [-1, 1], the maximum absolute error is {leq}
      2^-11^ and larger otherwise.

| *OpExtInst* *tan*
    | Derived implementations may implement as
      *sin*(_x_) * (1.0f / *cos*(_x_)).
      For non-derived implementations, the error is {leq} 8192 ulp.

| *OpExtInst* *tanh*
    | Defined for _x_ in the domain [-{inf}, {inf}].
      For _x_ in [-2^-10^, 2^-10^], derived implementations
      may implement as _x_.
      For _x_ outside of [-2^-10^, 2^-10^], derived implementations
      may implement as (*exp*(_x_) - *exp*(-_x_)) / (*exp*(_x_) + *exp*(-_x_)).
      For non-derived implementations, the error is {leq} 8192 ULP.

| *OpExtInst* *tanpi*
    | Derived implementations may implement as *tan*(_x_ * `M_PI_F`).
      For non-derived implementations, the error is {leq} 8192 ulp for _x_
      in the domain [-1, 1].

| *OpFMul* and *OpFAdd*, +
  for _x_ * _y_ + _z_
    | Implemented either as a correctly rounded *fma* or as a multiply and
      an add both of which are correctly rounded.

|====

=== Edge Case Behavior

The edge case behavior of the math functions shall conform to sections F.9
and G.6 of ISO/IEC 9899:TC 2, except where noted below in the
__<<additional-requirements-beyond-isoiec-9899tc2,Additional Requirements
Beyond ISO/IEC 9899:TC2>> section__.

[[additional-requirements-beyond-isoiec-9899tc2]]
==== Additional Requirements Beyond ISO/IEC 9899:TC2

All functions that return a NaN should return a quiet NaN.

The usual allowances for rounding error (__<<relative-error-as-ulps,Relative
Error as ULPs>> section__) or flushing behavior
(__<<edge-case-behavior-in-flush-to-zero-mode,Edge Case Behavior in Flush To
Zero Mode>> section__) shall not apply for those values for which _section
F.9_ of ISO/IEC 9899:,TC2, or
__<<additional-requirements-beyond-isoiec-9899tc2,Additional Requirements
Beyond ISO/IEC 9899:TC2>>__ and
__<<edge-case-behavior-in-flush-to-zero-mode,Edge Case Behavior in Flush To
Zero Mode>> sections__ below (and similar sections for other floating-point
precisions) prescribe a result (e.g. ceil( -1 < x < 0 ) returns -0).
Those values shall produce exactly the prescribed answers, and no other.
Where the {plusmn} symbol is used, the sign shall be preserved.
For example, sin({plusmn}0) = {plusmn}0 shall be interpreted to mean sin(+0)
is +0 and sin(-0) is -0.

  * *OpExtInst* *acospi*:
  ** acospi( 1 ) = +0.
  ** acospi( x ) returns a NaN for | x | > 1.

  * *OpExtInst* *asinpi*:
  ** asinpi( {plusmn}0 ) = {plusmn}0.
  ** asinpi( x ) returns a NaN for | x | > 1.

  * *OpExtInst* *atanpi*:
  ** atanpi( {plusmn}0 ) = {plusmn}0.
  ** atanpi ( {plusmn}{inf} ) = {plusmn}0.5.

  * *OpExtInst* *atan2pi*:
  ** atan2pi ( {plusmn}0, -0 ) = {plusmn}1.
  ** atan2pi ( {plusmn}0, +0 ) = {plusmn} 0.
  ** atan2pi ( {plusmn}0, x ) returns {plusmn} 1 for x < 0.
  ** atan2pi ( {plusmn}0, x) returns {plusmn} 0 for x > 0.
  ** atan2pi ( y, {plusmn}0 ) returns -0.5 for y < 0.
  ** atan2pi ( y, {plusmn}0 ) returns 0.5 for y > 0.
  ** atan2pi ( {plusmn}y, -{inf} ) returns {plusmn} 1 for finite y > 0.
  ** atan2pi ( {plusmn}y, +{inf} ) returns {plusmn} 0 for finite y > 0.
  ** atan2pi ( {plusmn}{inf}, x ) returns {plusmn} 0.5 for finite x.
  ** atan2pi ({plusmn}{inf}, -{inf} ) returns {plusmn}0.75.
  ** atan2pi ({plusmn}{inf}, +{inf} ) returns {plusmn}0.25.

  * *OpExtInst* *ceil*:
  ** ceil( -1 < x < 0 ) returns -0.

  * *OpExtInst* *cospi*:
  ** cospi( {plusmn}0 ) returns 1
  ** cospi( n + 0.5 ) is +0 for any integer n where n + 0.5 is
     representable.
  ** cospi( {plusmn}{inf} ) returns a NaN.

  * *OpExtInst* *exp10*:
  ** exp10( {plusmn}0 ) returns 1.
  ** exp10( -{inf} ) returns +0.
  ** exp10( +{inf} ) returns +{inf}.

  * *OpExtInst* *distance*:
  ** distance(x, y) calculates the distance from x to y without overflow or
     extraordinary precision loss due to underflow.

  * *OpExtInst* *fdim*:
  ** fdim( any, NaN ) returns NaN.
  ** fdim( NaN, any ) returns NaN.

  * *OpExtInst* *fmod*:
  ** fmod( {plusmn}0, NaN ) returns NaN.

  * *OpExtInst* *fract*:
  ** fract( x, iptr) shall not return a value greater than or equal to 1.0,
     and shall not return a value less than 0.
  ** fract( +0, iptr ) returns +0 and +0 in iptr.
  ** fract( -0, iptr ) returns -0 and -0 in iptr.
  ** fract( +inf, iptr ) returns +0 and +inf in iptr.
  ** fract( -inf, iptr ) returns -0 and -inf in iptr.
  ** fract( NaN, iptr ) returns the NaN and NaN in iptr.

  * *OpExtInst* *frexp*:
  ** frexp( {plusmn}{inf}, exp ) returns {plusmn}{inf} and stores 0 in exp.
  ** frexp( NaN, exp ) returns the NaN and stores 0 in exp.

  * *OpExtInst* *length*:
  ** length calculates the length of a vector without overflow or
     extraordinary precision loss due to underflow.

  * *OpExtInst* *lgamma_r*:
  ** lgamma_r( x, signp ) returns 0 in signp if x is zero or a negative
     integer.

  * *OpExtInst* *nextafter*:
  ** nextafter( -0, y > 0 ) returns smallest positive denormal value.
  ** nextafter( +0, y < 0 ) returns smallest negative denormal value.

  * *OpExtInst* *normalize*:
  ** normalize shall reduce the vector to unit length, pointing in the same
     direction without overflow or extraordinary precision loss due to
     underflow.
  ** normalize( v ) returns v if all elements of v are zero.
  ** normalize( v ) returns a vector full of NaNs if any element is a NaN.
  ** normalize( v ) for which any element in v is infinite shall proceed as
     if the elements in v were replaced as follows:
+
[source,opencl_c]
----
for( i = 0; i < sizeof(v) / sizeof(v[0] ); i++ )
    v[i] = isinf(v[i] )  ?  copysign(1.0, v[i]) : 0.0 * v [i];
----

  * *OpExtInst* *pow*:
  ** pow( {plusmn}0, -{inf} ) returns +{inf}

  * *OpExtInst* *pown*:
  ** pown( x, 0 ) is 1 for any x, even zero, NaN or infinity.
  ** pown( {plusmn}0, n ) is {plusmn}{inf} for odd n < 0.
  ** pown( {plusmn}0, n ) is +{inf} for even n < 0.
  ** pown( {plusmn}0, n ) is +0 for even n > 0.
  ** pown( {plusmn}0, n ) is {plusmn}0 for odd n > 0.

  * *OpExtInst* *powr*:
  ** powr( x, {plusmn}0 ) is 1 for finite x > 0.
  ** powr( {plusmn}0, y ) is +{inf} for finite y < 0.
  ** powr( {plusmn}0, -{inf}) is +{inf}.
  ** powr( {plusmn}0, y ) is +0 for y > 0.
  ** powr( +1, y ) is 1 for finite y.
  ** powr( x, y ) returns NaN for x < 0.
  ** powr( {plusmn}0, {plusmn}0 ) returns NaN.
  ** powr( +{inf}, {plusmn}0 ) returns NaN.
  ** powr( +1, {plusmn}{inf} ) returns NaN.
  ** powr( x, NaN ) returns the NaN for x >= 0.
  ** powr( NaN, y ) returns the NaN.

  * *OpExtInst* *rint*:
  ** rint( -0.5 \<= x < 0 ) returns -0.

  * *OpExtInst* *remquo*:
  ** remquo(x, y, &quo) returns a NaN and 0 in quo if x is {plusmn}{inf}, or
     if y is 0 and the other argument is non-NaN or if either argument is a
     NaN.

  * *OpExtInst* *rootn*:
  ** rootn( {plusmn}0, n ) is {plusmn}{inf} for odd n < 0.
  ** rootn( {plusmn}0, n ) is +{inf} for even n < 0.
  ** rootn( {plusmn}0, n ) is +0 for even n > 0.
  ** rootn( {plusmn}0, n ) is {plusmn}0 for odd n > 0.
  ** rootn( x, n ) returns a NaN for x < 0 and n is even.
  ** rootn( x, 0 ) returns a NaN.

  * *OpExtInst* *round*:
  ** round( -0.5 < x < 0 ) returns -0.

  * *OpExtInst* *sinpi*:
  ** sinpi( {plusmn}0 ) returns {plusmn}0.
  ** sinpi( +n) returns +0 for positive integers n.
  ** sinpi( -n ) returns -0 for negative integers n.
  ** sinpi( {plusmn}{inf} ) returns a NaN.

  * *OpExtInst* *tanpi*:
  ** tanpi( {plusmn}0 ) returns {plusmn}0.
  ** tanpi( {plusmn}{inf} ) returns a NaN.
  ** tanpi( n ) is copysign( 0.0, n ) for even integers n.
  ** tanpi( n ) is copysign( 0.0, - n) for odd integers n.
  ** tanpi( n + 0.5 ) for even integer n is +{inf} where n + 0.5 is
     representable.
  ** tanpi( n + 0.5 ) for odd integer n is -{inf} where n + 0.5 is
     representable.

  * *OpExtInst* *trunc*:
  ** trunc( -1 < x < 0 ) returns -0.

[[changes-to-isoiec-9899-tc2-behavior]]
==== Changes to ISO/IEC 9899: TC2 Behavior

*OpExtInst* *modf* behaves as though implemented by:

[source,opencl_c]
----
gentype modf( gentype value, gentype *iptr )
{
    *iptr = trunc( value );
    return copysign( isinf( value ) ? 0.0 : value - *iptr, value );
}
----

*OpExtInst* *rint* always rounds according to round to nearest even rounding
mode even if the caller is in some other rounding mode.

[[edge-case-behavior-in-flush-to-zero-mode]]
==== Edge Case Behavior in Flush To Zero Mode

If denormals are flushed to zero, then a function may return one of four
results:

  . Any conforming result for non-flush-to-zero mode.
  . If the result given by 1 is a sub-normal before rounding, it may be
    flushed to zero.
  . Any non-flushed conforming result for the function if one or more of its
    sub-normal operands are flushed to zero.
  . If the result of 3 is a sub-normal before rounding, the result may be
    flushed to zero.

In each of the above cases, if an operand or result is flushed to zero, the
sign of the zero is undefined.

If subnormals are flushed to zero, a device may choose to conform to the
following edge cases for *OpExtInst* *nextafter* instead of those listed in
__<<additional-requirements-beyond-isoiec-9899tc2,Additional Requirements
Beyond ISO/IEC 9899:TC2>> section__:

  * nextafter ( +smallest normal, y < +smallest normal ) = +0.
  * nextafter ( -smallest normal, y > -smallest normal ) = -0.
  * nextafter ( -0, y > 0 ) returns smallest positive normal value.
  * nextafter ( +0, y < 0 ) returns smallest negative normal value.

For clarity, subnormals or denormals are defined to be the set of
representable numbers in the range 0 < x < TYPE_MIN and -TYPE_MIN < x < -0.
They do not include {plusmn}0.
A non-zero number is said to be sub-normal before rounding if, after
normalization, its radix-2 exponent is less than (TYPE_MIN_EXP - 1).
footnote:[Here `TYPE_MIN` and `TYPE_MIN_EXP` should be substituted by
constants appropriate to the floating-point type under consideration, such
as `FLT_MIN` and `FLT_MIN_EXP` for float.]
