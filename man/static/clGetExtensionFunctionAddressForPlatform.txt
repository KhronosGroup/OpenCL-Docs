// Copyright 2014-2026 The Khronos Group Inc.
// SPDX-License-Identifier: CC-BY-4.0

:data-uri:
:icons: font
include::{config}/attribs.txt[]

= clGetExtensionFunctionAddressForPlatform(3)

== Name

clGetExtensionFunctionAddressForPlatform - Returns the address of the extension function named by _funcname_ for a given _platform_.

== Specification

[source,c]
----
void* clGetExtensionFunctionAddressForPlatform(cl_platform_id platform,
                                               const char *funcname)
----

== Parameters

  * _platform_ - Refers to the platform ID returned by
    flink:clGetPlatformIDs.
  * _funcname_ - Name of an extension function.

== Description

The function `clGetExtensionFunctionAddressForPlatform` returns the address of the extension function named by _funcname_ for a given _platform_.
The returned function pointer should be cast to a function pointer type matching
the extension function's definition defined in the appropriate extension
specification and header file.

A return value of `NULL` indicates that _platform_ is not a valid platform or
that the specified extension function does not exist for the platform.

A non-NULL return value for `clGetExtensionFunctionAddressForPlatform` does not guarantee that an extension function is actually supported by the platform.
The application must also make a corresponding query using flink:clGetPlatformInfo (platform, {CL_PLATFORM_EXTENSIONS}, ... ) or
flink:clGetDeviceInfo (device,{CL_DEVICE_EXTENSIONS}, ... ) to determine if an extension is supported by the OpenCL implementation.

`clGetExtensionFunctionAddressForPlatform` may not be queried for core (non-extension) functions in OpenCL.
For functions that are queryable with `clGetExtensionFunctionAddressForPlatform`, implementations may choose to also export those functions statically from the object libraries implementing those functions.
However, portable applications cannot rely on this behavior.

Function pointer typedefs should be declared for all extensions that add API
entrypoints.
These typedefs are a required part of the extension interface, and should be
provided in an appropriate header, such as `cl_ext.h`.

== Notes

Since there is no way to qualify the query with a device, the function pointer returned must work for all implementations of that extension on different devices for a platform.
The behavior of calling a device extension function on a device not supporting that extension is undefined.

If the reflink:cl_khr_icd extension is enabled, for functions supported by the ICD Loader, `clGetExtensionFunctionAddress` will return the function pointer of the ICD Loader implementation.
For extension functions which the ICD Loader is unaware of, the function `clGetExtensionFunctionAddress` will determine the vendor implementation to return based on the string passed in.
The ICD Loader will return the result from querying `clGetExtensionFunctionAddress` on the vendor ICD enumerated by the ICD Loader whose ICD suffix is a suffix of the function name being queried.
If no such vendor exists or the suffix of the function is `KHR` or `EXT` then `clGetExtensionFunctionAddress` will return NULL.

== Example

The following convention should be followed for all extensions affecting the
host API:

[source,opencl]
----
#define cl_extension_name 1
#define CL_EXTENSION_NAME_NAME "cl_extension_name"

#define CL_EXTENSION_NAME_VERSION CL_MAKE_VERSION(major, minor, patch)

// all data typedefs and token #defines for this extension
#define CL_EXTENSION_ENUM_NAME_TAG    0xXXXX

// function types for extension functions
typedef return_type
clExtensionFunctionNameTAG_t(...);

// function pointer typedefs for extension functions
typedef clExtensionFunctionNameTAG_t *
clExtensionFunctionNameTAG_fn;

// extension function prototypes (optional)
extern return_type
clExtensionFunctionTAG(...);
----

Consider, for example, the reflink:cl_khr_create_command_queue extension.
This extension adds the following to `cl_ext.h`:

[source,opencl]
----
#define cl_khr_create_command_queue 1
#define CL_KHR_CREATE_COMMAND_QUEUE_EXTENSION_NAME \
    "cl_khr_create_command_queue"

#define CL_KHR_CREATE_COMMAND_QUEUE_EXTENSION_VERSION CL_MAKE_VERSION(1, 0, 0)

typedef cl_properties       cl_queue_properties_khr;

typedef cl_command_queue CL_API_CALL
clCreateCommandQueueWithPropertiesKHR_t(
    cl_context context,
    cl_device_id device,
    const cl_queue_properties_khr* properties,
    cl_int* errcode_ret);

typedef clCreateCommandQueueWithPropertiesKHR_t *
clCreateCommandQueueWithPropertiesKHR_fn CL_API_SUFFIX__VERSION_1_2;

#if !defined(CL_NO_NON_ICD_DISPATCH_EXTENSION_PROTOTYPES)

extern CL_API_ENTRY cl_command_queue CL_API_CALL
clCreateCommandQueueWithPropertiesKHR(
    cl_context context,
    cl_device_id device,
    const cl_queue_properties_khr* properties,
    cl_int* errcode_ret) CL_API_SUFFIX__VERSION_1_2;

#endif /* !defined(CL_NO_NON_ICD_DISPATCH_EXTENSION_PROTOTYPES) */
----

== See Also

reflink:EXTENSION

== Document Notes

For more information, see the OpenCL Specification at URL

https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_API.html#clGetExtensionFunctionAddressForPlatform

== Copyright

include::footer.txt[]
