// Copyright 2017-2024 The Khronos Group Inc.
// SPDX-License-Identifier: CC-BY-4.0

[[opencl-platform-layer]]
= The OpenCL Platform Layer

This section describes the OpenCL platform layer which implements
platform-specific features that allow applications to query OpenCL devices,
device configuration information, and to create OpenCL contexts using one or
more devices.


== Querying Platform Info

[open,refpage='clGetPlatformIDs',desc='Query list of available platforms',type='protos']
--
The list of platforms available can be obtained with the function:

include::{generated}/api/protos/clGetPlatformIDs.txt[]
include::{generated}/api/version-notes/clGetPlatformIDs.asciidoc[]

  * _num_entries_ is the number of {cl_platform_id_TYPE} entries that can be added to
    _platforms_.
    If _platforms_ is not `NULL`, _num_entries_ must be greater than zero.
  * _platforms_ returns a list of OpenCL platforms found.
    The {cl_platform_id_TYPE} values returned in _platforms_ can be used to
    identify a specific OpenCL platform.
    If _platforms_ is `NULL`, this argument is ignored.
    The number of OpenCL platforms returned is the minimum of the value
    specified by _num_entries_ or the number of OpenCL platforms available.
  * _num_platforms_ returns the number of OpenCL platforms available.
    If _num_platforms_ is `NULL`, this argument is ignored.

// refError

{clGetPlatformIDs} returns {CL_SUCCESS} if the function is executed
ifndef::cl_khr_icd[successfully.]
ifdef::cl_khr_icd[]
and, if the `<<cl_khr_icd>>` extension is supported, there are a non-zero
number of platforms available.
endif::cl_khr_icd[]
Otherwise, it returns one of the following errors:

ifdef::cl_khr_icd[]
  * {CL_PLATFORM_NOT_FOUND_KHR} if the `<<cl_khr_icd>>` extension is
    supported and zero platforms are available.
endif::cl_khr_icd[]
  * {CL_INVALID_VALUE} if _num_entries_ is equal to zero and _platforms_ is
    not `NULL` or if both _num_platforms_ and _platforms_ are `NULL`.
  * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources
    required by the OpenCL implementation on the host.
--

ifdef::cl_khr_icd[]
[open,refpage='clIcdGetPlatformIDsKHR',desc='Query platforms accessible through the Khronos ICD Loader',type='protos']
--
To obtain the list of platforms accessible through the Khronos ICD Loader,
call the function:

include::{generated}/api/protos/clIcdGetPlatformIDsKHR.txt[]
include::{generated}/api/version-notes/clIcdGetPlatformIDsKHR.asciidoc[]

  * _num_entries_ is the number of {cl_platform_id_TYPE} entries that can be
    added to _platforms_.
    If _platforms_ is not `NULL`, then _num_entries_ must be greater than
    zero.
  * _platforms_ returns a list of OpenCL platforms available for access
    through the Khronos ICD Loader.
    The {cl_platform_id_TYPE} values returned in _platforms_ are ICD
    compatible and can be used to identify a specific OpenCL platform.
    If the _platforms_ argument is `NULL`, then this argument is ignored.
    The number of OpenCL platforms returned is the minimum of the value
    specified by _num_entries_ or the number of OpenCL platforms available.
  * _num_platforms_ returns the number of OpenCL platforms available.
    If _num_platforms_ is `NULL`, then this argument is ignored.

// refError

{clIcdGetPlatformIDsKHR} returns {CL_SUCCESS} if the function is executed
successfully and there are a non zero number of platforms available.
Otherwise, it returns one of the following errors:

  * {CL_PLATFORM_NOT_FOUND_KHR} if zero platforms are available.
  * {CL_INVALID_VALUE} if _num_entries_ is equal to zero and _platforms_ is
    not `NULL` or if both _num_platforms_ and _platforms_ are `NULL`.
--
endif::cl_khr_icd[]

[open,refpage='clGetPlatformInfo',desc='Query information about an OpenCL platform',type='protos']
--
Specific information about an OpenCL platform can be obtained with
the function:

include::{generated}/api/protos/clGetPlatformInfo.txt[]
include::{generated}/api/version-notes/clGetPlatformInfo.asciidoc[]

  * _platform_ refers to the platform ID returned by {clGetPlatformIDs} or can
    be `NULL`.
    If _platform_ is `NULL`, the behavior is implementation-defined.
  * _param_name_ is an enumeration constant that identifies the platform
    information being queried.
    It can be one of the following values as specified in the
    <<platform-queries-table, Platform Queries>> table.
  * _param_value_ is a pointer to memory location where appropriate values for a
    given _param_name_, as specified in the <<platform-queries-table, Platform
    Queries>> table, will be returned.
    If _param_value_ is `NULL`, it is ignored.
  * _param_value_size_ specifies the size in bytes of memory pointed to by
    _param_value_.
    This size in bytes must be {geq} size of return type specified in the
    <<platform-queries-table, Platform Queries>> table.
  * _param_value_size_ret_ returns the actual size in bytes of data being
    queried by _param_name_.
    If _param_value_size_ret_ is `NULL`, it is ignored.

The information that can be queried using {clGetPlatformInfo} is specified
in the <<platform-queries-table, Platform Queries>> table.

[[platform-queries-table]]
.List of supported param_names by {clGetPlatformInfo}
[width="100%",cols="<33%,<17%,<50%",options="header"]
|====
| Platform Info | Return Type | Description
| {CL_PLATFORM_PROFILE_anchor} footnote:[{fn-platform-profile}]

include::{generated}/api/version-notes/CL_PLATFORM_PROFILE.asciidoc[]
  | {char_TYPE}[] footnote:[{fn-null-terminated-string}]
      | OpenCL profile string.
        Returns the profile name supported by the implementation.
        The profile name returned can be one of the following strings:

        FULL_PROFILE - if the implementation supports the OpenCL
        specification (functionality defined as part of the core
        specification and does not require any extensions to be supported).

        EMBEDDED_PROFILE - if the implementation supports the OpenCL
        embedded profile.
        The embedded profile is defined to be a subset for each version of
        OpenCL.
        The embedded profile for OpenCL is described in
        <<opencl-embedded-profile, OpenCL Embedded Profile>>.
| {CL_PLATFORM_VERSION_anchor}

include::{generated}/api/version-notes/CL_PLATFORM_VERSION.asciidoc[]
  | {char_TYPE}[]
      | OpenCL version string.
        Returns the OpenCL version supported by the implementation.
        This version string has the following format:

        _OpenCL<space><major_version.minor_version><space><platform-specific
        information>_

        The _major_version.minor_version_ value returned will be one of 1.0,
        1.1, 1.2, 2.0, 2.1, 2.2 or 3.0.

| {CL_PLATFORM_NUMERIC_VERSION_anchor}

include::{generated}/api/version-notes/CL_PLATFORM_NUMERIC_VERSION.asciidoc[]

ifdef::cl_khr_extended_versioning[]
or

{CL_PLATFORM_NUMERIC_VERSION_KHR_anchor}

include::{generated}/api/version-notes/CL_PLATFORM_NUMERIC_VERSION_KHR.asciidoc[]
endif::cl_khr_extended_versioning[]
  | {cl_version_TYPE}

ifdef::cl_khr_extended_versioning[or {cl_version_khr_TYPE}]
      | Returns the detailed (major, minor, patch) version supported by the
        platform. The major and minor version numbers returned must match
        those returned via {CL_PLATFORM_VERSION}.

| {CL_PLATFORM_NAME_anchor}

include::{generated}/api/version-notes/CL_PLATFORM_NAME.asciidoc[]
  | {char_TYPE}[]
      | Platform name string.
| {CL_PLATFORM_VENDOR_anchor}

include::{generated}/api/version-notes/CL_PLATFORM_VENDOR.asciidoc[]
  | {char_TYPE}[]
      | Platform vendor string.
| {CL_PLATFORM_EXTENSIONS_anchor}

include::{generated}/api/version-notes/CL_PLATFORM_EXTENSIONS.asciidoc[]
  | {char_TYPE}[]
      | Returns a space separated list of extension names (the extension
        names themselves do not contain any spaces) supported by the
        platform.
        Each extension that is supported by all devices associated with this
        platform must be reported here.
| {CL_PLATFORM_EXTENSIONS_WITH_VERSION_anchor}

include::{generated}/api/version-notes/CL_PLATFORM_EXTENSIONS_WITH_VERSION.asciidoc[]

ifdef::cl_khr_extended_versioning[]
or

{CL_PLATFORM_EXTENSIONS_WITH_VERSION_KHR_anchor}

include::{generated}/api/version-notes/CL_PLATFORM_EXTENSIONS_WITH_VERSION_KHR.asciidoc[]
endif::cl_khr_extended_versioning[]
  | {cl_name_version_TYPE}[]

ifdef::cl_khr_extended_versioning[or {cl_name_version_khr_TYPE}[]]
      | Returns an array of description (name and version) structures that lists
        all the extensions supported by the platform. The same extension name
        must not be reported more than once. The list of extensions reported
        must match the list reported via {CL_PLATFORM_EXTENSIONS}.

| {CL_PLATFORM_HOST_TIMER_RESOLUTION_anchor}

include::{generated}/api/version-notes/CL_PLATFORM_HOST_TIMER_RESOLUTION.asciidoc[]
  | {cl_ulong_TYPE}
      | Returns the resolution of the host timer in nanoseconds as used by
        {clGetDeviceAndHostTimer}.

        Support for device and host timer synchronization is required for
        platforms supporting OpenCL 2.1 or 2.2.
        This value must be 0 for devices that do not support device and
        host timer synchronization.

ifdef::cl_khr_command_buffer_multi_device[]
| {CL_PLATFORM_COMMAND_BUFFER_CAPABILITIES_KHR_anchor}

include::{generated}/api/version-notes/CL_PLATFORM_COMMAND_BUFFER_CAPABILITIES_KHR.asciidoc[]
  | {cl_platform_command_buffer_capabilities_khr_TYPE}
    | Describes platform command-buffer capabilities, encoded as bits in a
      bitfield.
      Supported capabilities are:

      {CL_COMMAND_BUFFER_PLATFORM_UNIVERSAL_SYNC_KHR_anchor} - Platform
      supports the ability to synchronize all commands in a command-buffer
      using sync-points, irrespective of the queue the individual commands
      are recorded to.

include::{generated}/api/version-notes/CL_COMMAND_BUFFER_PLATFORM_UNIVERSAL_SYNC_KHR.asciidoc[]

      {CL_COMMAND_BUFFER_PLATFORM_REMAP_QUEUES_KHR_anchor} - Platform
      supports the ability to create a deep copy of an existing
      command-buffer with the commands explicitly remapped to different,
      potentially <<compatible, incompatible>>, queues.

include::{generated}/api/version-notes/CL_COMMAND_BUFFER_PLATFORM_REMAP_QUEUES_KHR.asciidoc[]

      {CL_COMMAND_BUFFER_PLATFORM_AUTOMATIC_REMAP_KHR_anchor} - Platform
      supports the ability to create a remapped command-buffer where the
      mapping of commands to queues is done by the OpenCL runtime in a way
      it determines as optimal.
      If {CL_COMMAND_BUFFER_PLATFORM_AUTOMATIC_REMAP_KHR} is reported,
      {CL_COMMAND_BUFFER_PLATFORM_REMAP_QUEUES_KHR} must also be reported.

include::{generated}/api/version-notes/CL_COMMAND_BUFFER_PLATFORM_AUTOMATIC_REMAP_KHR.asciidoc[]
endif::cl_khr_command_buffer_multi_device[]

ifdef::cl_khr_external_memory[]
| {CL_PLATFORM_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES_KHR_anchor}

include::{generated}/api/version-notes/CL_PLATFORM_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES_KHR.asciidoc[]
  | {cl_external_memory_handle_type_khr_TYPE}[]
      | Returns the list of importable external memory handle types
        supported by all devices in _platform_.
endif::cl_khr_external_memory[]

ifdef::cl_khr_semaphore[]
| {CL_PLATFORM_SEMAPHORE_TYPES_KHR_anchor}

include::{generated}/api/version-notes/CL_PLATFORM_SEMAPHORE_TYPES_KHR.asciidoc[]
  | {cl_semaphore_type_khr_TYPE}[]
      | Returns the list of the semaphore types supported all devices in
        _platform_.
endif::cl_khr_semaphore[]

ifdef::cl_khr_external_semaphore[]
| {CL_PLATFORM_SEMAPHORE_IMPORT_HANDLE_TYPES_KHR_anchor}

include::{generated}/api/version-notes/CL_PLATFORM_SEMAPHORE_IMPORT_HANDLE_TYPES_KHR.asciidoc[]
  | {cl_external_semaphore_handle_type_khr_TYPE}[]
    | Returns the list of importable external semaphore handle types
      supported by all devices in _platform_.

      The size of this query may be 0 if no importable external semaphore
      handle types are supported by all devices in _platform_.
| {CL_PLATFORM_SEMAPHORE_EXPORT_HANDLE_TYPES_KHR_anchor}

include::{generated}/api/version-notes/CL_PLATFORM_SEMAPHORE_EXPORT_HANDLE_TYPES_KHR.asciidoc[]
  | {cl_external_semaphore_handle_type_khr_TYPE}[]
    | Returns the list of exportable external semaphore handle types
      supported by all devices in the platform.

      This size of this query may be 0 if no exportable external semaphore
      handle types are supported by all devices in _platform_.
endif::cl_khr_external_semaphore[]

ifdef::cl_khr_icd[]
| {CL_PLATFORM_ICD_SUFFIX_KHR_anchor}

include::{generated}/api/version-notes/CL_PLATFORM_ICD_SUFFIX_KHR.asciidoc[]
  | {char_TYPE}[]
    | The function name suffix used to identify extension functions to be
      directed to this platform by the ICD Loader.
endif::cl_khr_icd[]
|====

// refError

{clGetPlatformInfo} returns {CL_SUCCESS} if the function is executed
successfully.
Otherwise, it returns one of the following
errors footnote:[{fn-error-precedence}].

  * {CL_INVALID_PLATFORM} if _platform_ is not a valid platform.
  * {CL_INVALID_VALUE} if _param_name_ is not one of the supported values or
    if size in bytes specified by _param_value_size_ is < size of return
    type as specified in the <<platform-queries-table,OpenCL Platform
    Queries>> table, and _param_value_ is not a `NULL` value.
  * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources
    required by the OpenCL implementation on the host.
--


[[platform-querying-devices]]
== Querying Devices

[open,refpage='clGetDeviceIDs',desc='Query devices available on a platform',type='protos']
--
The list of devices available on a platform can be obtained using the
function footnote:[{fn-get-device-ids-all-or-subset}]:

include::{generated}/api/protos/clGetDeviceIDs.txt[]
include::{generated}/api/version-notes/clGetDeviceIDs.asciidoc[]

  * _platform_ refers to the platform ID returned by {clGetPlatformIDs} or can
    be `NULL`.
    If _platform_ is `NULL`, the behavior is implementation-defined.
  * _device_type_ is a bitfield that identifies the type of OpenCL device.
    The _device_type_ can be used to query specific OpenCL devices or all OpenCL
    devices available.
    The valid values for _device_type_ are specified in the
    <<device-types-table, Device Types>> table.
  * _num_entries_ is the number of {cl_device_id_TYPE} entries that can be added to
    _devices_.
    If _devices_ is not `NULL`, the _num_entries_ must be greater than zero.
  * _devices_ returns a list of OpenCL devices found.
    The {cl_device_id_TYPE} values returned in _devices_ can be used to identify a
    specific OpenCL device.
    If _devices_ is `NULL`, this argument is ignored.
    The number of OpenCL devices returned is the minimum of the value specified
    by _num_entries_ or the number of OpenCL devices whose type matches
    _device_type_.
  * _num_devices_ returns the number of OpenCL devices available that match
    _device_type_.
    If _num_devices_ is `NULL`, this argument is ignored.

[[device-types-table]]
.List of supported device_types by {clGetDeviceIDs}
[width="100%",cols="<50%,<50%",options="header"]
|====
| Device Type | Description
| {CL_DEVICE_TYPE_CPU_anchor}

include::{generated}/api/version-notes/CL_DEVICE_TYPE_CPU.asciidoc[]
  | An OpenCL device similar to a traditional CPU (Central Processing Unit).
    The host processor that executes OpenCL host code may also be considered
    a CPU OpenCL device.

| {CL_DEVICE_TYPE_GPU_anchor}

include::{generated}/api/version-notes/CL_DEVICE_TYPE_GPU.asciidoc[]
  | An OpenCL device similar to a GPU (Graphics Processing Unit).
    Many systems include a dedicated processor for graphics or rendering
    that may be considered a GPU OpenCL device.

| {CL_DEVICE_TYPE_ACCELERATOR_anchor}

include::{generated}/api/version-notes/CL_DEVICE_TYPE_ACCELERATOR.asciidoc[]
  | Dedicated devices that may accelerate OpenCL programs, such as FPGAs
    (Field Programmable Gate Arrays), DSPs (Digital Signal Processors), or
    AI (Artificial Intelligence) processors.

| {CL_DEVICE_TYPE_CUSTOM_anchor}

include::{generated}/api/version-notes/CL_DEVICE_TYPE_CUSTOM.asciidoc[]
  | Specialized devices that implement some of the OpenCL runtime APIs but
    do not support all required OpenCL functionality.

| {CL_DEVICE_TYPE_DEFAULT_anchor}

include::{generated}/api/version-notes/CL_DEVICE_TYPE_DEFAULT.asciidoc[]
  | The default OpenCL device in the platform.
    The default OpenCL device must not be a {CL_DEVICE_TYPE_CUSTOM} device.

| {CL_DEVICE_TYPE_ALL_anchor}

include::{generated}/api/version-notes/CL_DEVICE_TYPE_ALL.asciidoc[]
  | All OpenCL devices available in the platform, except for
    {CL_DEVICE_TYPE_CUSTOM} devices.

|====

The device type is purely informational and has no semantic meaning.

Some devices may be more than one type.
For example, a {CL_DEVICE_TYPE_CPU} device may also be a
{CL_DEVICE_TYPE_GPU} device, or a {CL_DEVICE_TYPE_ACCELERATOR} device
may also be some other, more descriptive device type.
{CL_DEVICE_TYPE_CUSTOM} devices must not be combined with any other
device types.

One device in the platform should be a {CL_DEVICE_TYPE_DEFAULT} device.
The default device should also be a more specific device type, such
as {CL_DEVICE_TYPE_CPU} or {CL_DEVICE_TYPE_GPU}.

// refError

{clGetDeviceIDs} returns {CL_SUCCESS} if the function is executed
successfully.
Otherwise, it returns one of the following errors:

  * {CL_INVALID_PLATFORM} if _platform_ is not a valid platform.
  * {CL_INVALID_DEVICE_TYPE} if _device_type_ is not a valid value.
  * {CL_INVALID_VALUE} if _num_entries_ is equal to zero and _devices_ is not
    `NULL` or if both _num_devices_ and _devices_ are `NULL`.
  * {CL_DEVICE_NOT_FOUND} if no OpenCL devices that matched _device_type_ were
    found.
  * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources required
    by the OpenCL implementation on the device.
  * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources
    required by the OpenCL implementation on the host.

The application can query specific capabilities of the OpenCL device(s)
returned by {clGetDeviceIDs}.
This can be used by the application to determine which device(s) to use.
--

[open,refpage='clGetDeviceInfo',desc='Query specific information about a device',type='protos']
--
To get specific information about an OpenCL device, call the function:

include::{generated}/api/protos/clGetDeviceInfo.txt[]
include::{generated}/api/version-notes/clGetDeviceInfo.asciidoc[]

  * _device_ may be a device returned by {clGetDeviceIDs} or a sub-device
    created by {clCreateSubDevices}.
    If _device_ is a sub-device, the specific information for the sub-device
    will be returned.
    The information that can be queried using {clGetDeviceInfo} is specified in
    the <<device-queries-table, Device Queries>> table.
  * _param_name_ is an enumeration constant that identifies the device
    information being queried.
    It can be one of the following values as specified in the
    <<device-queries-table, Device Queries>> table.
  * _param_value_ is a pointer to memory location where appropriate values for a
    given _param_name_, as specified in the <<device-queries-table, Device
    Queries>> table, will be returned.
    If _param_value_ is `NULL`, it is ignored.
  * _param_value_size_ specifies the size in bytes of memory pointed to by
    _param_value_.
    This size in bytes must be {geq} size of return type specified in the
    <<device-queries-table, Device Queries>> table.
  * _param_value_size_ret_ returns the actual size in bytes of data being
    queried by _param_name_.
    If _param_value_size_ret_ is `NULL`, it is ignored.

The device queries described in the <<device-queries-table, Device Queries>>
table should return the same information for a root-level device i.e. a
device returned by {clGetDeviceIDs} and any sub-devices created from this
device except for the following queries:

  * {CL_DEVICE_GLOBAL_MEM_CACHE_SIZE}
  * {CL_DEVICE_BUILT_IN_KERNELS}
  * {CL_DEVICE_PARENT_DEVICE}
  * {CL_DEVICE_PARTITION_TYPE}
  * {CL_DEVICE_REFERENCE_COUNT}

[[device-queries-table]]
.List of supported param_names by {clGetDeviceInfo}
[width="100%",cols="<33%,<17%,<50%",options="header"]
|====
| Device Info | Return Type | Description
| {CL_DEVICE_TYPE_anchor}

include::{generated}/api/version-notes/CL_DEVICE_TYPE.asciidoc[]
  | {cl_device_type_TYPE}
      | The type or types of the OpenCL device.

        Please see the <<device-types-table, Device Types>> table
        for supported device types and device type combinations.

| {CL_DEVICE_VENDOR_ID_anchor} footnote:[{fn-vendor-id}]

include::{generated}/api/version-notes/CL_DEVICE_VENDOR_ID.asciidoc[]
  | {cl_uint_TYPE}
      | A unique device vendor identifier.

        If the vendor has a PCI vendor ID, the low 16 bits must contain that PCI
        vendor ID, and the remaining bits must be set to zero. Otherwise, the
        value returned must be a valid Khronos vendor ID represented by type
        {cl_khronos_vendor_id_TYPE}. Khronos vendor IDs are allocated starting at
        0x10000, to distinguish them from the PCI vendor ID namespace.
| {CL_DEVICE_MAX_COMPUTE_UNITS_anchor}

include::{generated}/api/version-notes/CL_DEVICE_MAX_COMPUTE_UNITS.asciidoc[]
  | {cl_uint_TYPE}
      | The number of parallel compute units on the OpenCL device.
        A work-group executes on a single compute unit.
        The minimum value is 1.
| {CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS_anchor}

include::{generated}/api/version-notes/CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS.asciidoc[]
  | {cl_uint_TYPE}
      | Maximum dimensions that specify the global and local work-item IDs
        used by the data parallel execution model. (Refer to
        {clEnqueueNDRangeKernel}).
        The minimum value is 3 for devices that are not of type
        {CL_DEVICE_TYPE_CUSTOM}.
| {CL_DEVICE_MAX_WORK_ITEM_SIZES_anchor}

include::{generated}/api/version-notes/CL_DEVICE_MAX_WORK_ITEM_SIZES.asciidoc[]
  | {size_t_TYPE}[]
      | Maximum number of work-items that can be specified in each dimension
        of the work-group to {clEnqueueNDRangeKernel}.

        Returns _n_ {size_t_TYPE} entries, where _n_ is the value returned by the
        query for {CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS}.

        The minimum value is (1, 1, 1) for devices that are not of type
        {CL_DEVICE_TYPE_CUSTOM}.
| {CL_DEVICE_MAX_WORK_GROUP_SIZE_anchor}

include::{generated}/api/version-notes/CL_DEVICE_MAX_WORK_GROUP_SIZE.asciidoc[]
  | {size_t_TYPE}
      | Maximum number of work-items in a work-group that a device is
        capable of executing on a single compute unit, for any given
        kernel-instance running on the device. (Refer also to
        {clEnqueueNDRangeKernel} and {CL_KERNEL_WORK_GROUP_SIZE} ).
        The minimum value is 1.
        The returned value is an upper limit and will not necessarily
        maximize performance.
        This maximum may be larger than supported by a specific kernel
        (refer to the {CL_KERNEL_WORK_GROUP_SIZE} query of {clGetKernelWorkGroupInfo}).
| {CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR_anchor}   +
  {CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT_anchor}  +
  {CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT_anchor}    +
  {CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG_anchor}   +
  {CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT_anchor}  +
  {CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE_anchor} +
  {CL_DEVICE_PREFERRED_VECTOR_WIDTH_HALF_anchor}

// Manually write this annotation as HALF is an odd-one-out in the table row
// (all other entries were added in OpenCL 1.0).
  {CL_DEVICE_PREFERRED_VECTOR_WIDTH_HALF} is <<unified-spec, missing before>>
  version 1.1.
  | {cl_uint_TYPE}
      | Preferred native vector width size for built-in scalar types that
        can be put into vectors.
        The vector width is defined as the number of scalar elements that
        can be stored in the vector.

        If double precision is not supported,
        {CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE} must return 0.

        If the `<<cl_khr_fp16>>` extension is not supported,
        {CL_DEVICE_PREFERRED_VECTOR_WIDTH_HALF} must return 0.
| {CL_DEVICE_NATIVE_VECTOR_WIDTH_CHAR_anchor}   +
  {CL_DEVICE_NATIVE_VECTOR_WIDTH_SHORT_anchor}  +
  {CL_DEVICE_NATIVE_VECTOR_WIDTH_INT_anchor}    +
  {CL_DEVICE_NATIVE_VECTOR_WIDTH_LONG_anchor}   +
  {CL_DEVICE_NATIVE_VECTOR_WIDTH_FLOAT_anchor}  +
  {CL_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE_anchor} +
  {CL_DEVICE_NATIVE_VECTOR_WIDTH_HALF_anchor}

// The CHAR annotation here is used to convey the same information for all
// entries in this table row.
include::{generated}/api/version-notes/CL_DEVICE_NATIVE_VECTOR_WIDTH_CHAR.asciidoc[]
  | {cl_uint_TYPE}
      | Returns the native ISA vector width.
        The vector width is defined as the number of scalar elements that
        can be stored in the vector.

        If double precision is not supported,
        {CL_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE} must return 0.

        If the `<<cl_khr_fp16>>` extension is not supported,
        {CL_DEVICE_NATIVE_VECTOR_WIDTH_HALF} must return 0.
| {CL_DEVICE_MAX_CLOCK_FREQUENCY_anchor}

include::{generated}/api/version-notes/CL_DEVICE_MAX_CLOCK_FREQUENCY.asciidoc[]
  | {cl_uint_TYPE}
      | Clock frequency of the device in MHz.
        The meaning of this value is implementation-defined.
        For devices with multiple clock domains, the clock frequency for any
        of the clock domains may be returned.
        For devices that dynamically change frequency for power or thermal
        reasons, the returned clock frequency may be any valid frequency.
        Note: This definition is <<unified-spec, missing before>> version 2.2.

        Maximum configured clock frequency of the device in MHz.
        Note: This definition is <<unified-spec, deprecated by>> version 2.2.
| {CL_DEVICE_ADDRESS_BITS_anchor}

include::{generated}/api/version-notes/CL_DEVICE_ADDRESS_BITS.asciidoc[]
  | {cl_uint_TYPE}
      | The default compute device address space size of the global address
        space specified as an unsigned integer value in bits.
        Currently supported values are 32 or 64 bits.
| {CL_DEVICE_MAX_MEM_ALLOC_SIZE_anchor}

include::{generated}/api/version-notes/CL_DEVICE_MAX_MEM_ALLOC_SIZE.asciidoc[]
  | {cl_ulong_TYPE}
      | Max size of memory object allocation in bytes.
        The minimum value is max(min(1024 {times} 1024 {times} 1024, 1/4^th^
        of {CL_DEVICE_GLOBAL_MEM_SIZE}), 32 {times} 1024 {times} 1024) for
        devices that are not of type {CL_DEVICE_TYPE_CUSTOM}.
| {CL_DEVICE_IMAGE_SUPPORT_anchor}

include::{generated}/api/version-notes/CL_DEVICE_IMAGE_SUPPORT.asciidoc[]
  | {cl_bool_TYPE}
      | Is {CL_TRUE} if images are supported by the OpenCL device and {CL_FALSE}
        otherwise.
| {CL_DEVICE_MAX_READ_IMAGE_ARGS_anchor} footnote:[{fn-max-read-image-args}]

include::{generated}/api/version-notes/CL_DEVICE_MAX_READ_IMAGE_ARGS.asciidoc[]
  | {cl_uint_TYPE}
      | Max number of image objects arguments of a kernel declared with the
        read_only qualifier.
        The minimum value is 128 if {CL_DEVICE_IMAGE_SUPPORT} is {CL_TRUE}, the
        value is 0 otherwise.
| {CL_DEVICE_MAX_WRITE_IMAGE_ARGS_anchor}

include::{generated}/api/version-notes/CL_DEVICE_MAX_WRITE_IMAGE_ARGS.asciidoc[]
  | {cl_uint_TYPE}
      | Max number of image objects arguments of a kernel declared with the
        write_only qualifier.
        The minimum value is 64 if {CL_DEVICE_IMAGE_SUPPORT} is {CL_TRUE}, the
        value is 0 otherwise.
| {CL_DEVICE_MAX_READ_WRITE_IMAGE_ARGS_anchor}

include::{generated}/api/version-notes/CL_DEVICE_MAX_READ_WRITE_IMAGE_ARGS.asciidoc[]
  | {cl_uint_TYPE}
      | Max number of image objects arguments of a kernel declared with the
        write_only or read_write qualifier.

        Support for read-write image arguments is required for an OpenCL 2.0, 2.1,
        or 2.2 device if {CL_DEVICE_IMAGE_SUPPORT} is {CL_TRUE}.

        The minimum value is 64 if the device supports read-write images arguments,
        and must be 0 for devices that do not support read-write images.
| {CL_DEVICE_IL_VERSION_anchor}

include::{generated}/api/version-notes/CL_DEVICE_IL_VERSION.asciidoc[]

ifdef::cl_khr_il_program[]
or

{CL_DEVICE_IL_VERSION_KHR_anchor}

include::{generated}/api/version-notes/CL_DEVICE_IL_VERSION_KHR.asciidoc[]
endif::cl_khr_il_program[]
  | {char_TYPE}[]
      | The intermediate languages that can be supported by
        {clCreateProgramWithIL} for this device.
        Returns a space-separated list of IL version strings of the form

        <IL_Prefix>_<Major_Version>.<Minor_Version>

        For an OpenCL 2.1 or 2.2 device, SPIR-V is a required IL prefix.

        If the device does not support intermediate language programs, the
        value must be `""` (an empty string).

ifdef::cl_khr_il_program[]
        A device that supports the `<<cl_khr_il_program>>` extension must
        support the `"SPIR-V"` IL prefix.
endif::cl_khr_il_program[]
| {CL_DEVICE_ILS_WITH_VERSION_anchor}

include::{generated}/api/version-notes/CL_DEVICE_ILS_WITH_VERSION.asciidoc[]

ifdef::cl_khr_extended_versioning[]
or

{CL_DEVICE_ILS_WITH_VERSION_KHR_anchor}

include::{generated}/api/version-notes/CL_DEVICE_ILS_WITH_VERSION_KHR.asciidoc[]
endif::cl_khr_extended_versioning[]
  | {cl_name_version_TYPE}[]

ifdef::cl_khr_extended_versioning[or {cl_name_version_khr_TYPE}[]]
      | Returns an array of descriptions (name and version) for all supported
        intermediate languages.
        Intermediate languages with the same name may be reported more than
        once but each name and major/minor version combination may only be
        reported once.
        The list of intermediate languages reported must match the list
        reported via {CL_DEVICE_IL_VERSION}.

        For an OpenCL 2.1 or 2.2 device, at least one version of SPIR-V must
        be reported.

| {CL_DEVICE_IMAGE2D_MAX_WIDTH_anchor}

include::{generated}/api/version-notes/CL_DEVICE_IMAGE2D_MAX_WIDTH.asciidoc[]
  | {size_t_TYPE}
      | Max width of 2D image or 1D image not created from a buffer object
        in pixels.

        The minimum value is 16384 if {CL_DEVICE_IMAGE_SUPPORT} is {CL_TRUE},
        the value is 0 otherwise.
| {CL_DEVICE_IMAGE2D_MAX_HEIGHT_anchor}

include::{generated}/api/version-notes/CL_DEVICE_IMAGE2D_MAX_HEIGHT.asciidoc[]
  | {size_t_TYPE}
      | Max height of 2D image in pixels.

        The minimum value is 16384 if {CL_DEVICE_IMAGE_SUPPORT} is {CL_TRUE},
        the value is 0 otherwise.
| {CL_DEVICE_IMAGE3D_MAX_WIDTH_anchor}

include::{generated}/api/version-notes/CL_DEVICE_IMAGE3D_MAX_WIDTH.asciidoc[]
  | {size_t_TYPE}
      | Max width of 3D image in pixels.

        The minimum value is 2048 if {CL_DEVICE_IMAGE_SUPPORT} is {CL_TRUE},
        the value is 0 otherwise.
| {CL_DEVICE_IMAGE3D_MAX_HEIGHT_anchor}

include::{generated}/api/version-notes/CL_DEVICE_IMAGE3D_MAX_HEIGHT.asciidoc[]
  | {size_t_TYPE}
      | Max height of 3D image in pixels.

        The minimum value is 2048 if {CL_DEVICE_IMAGE_SUPPORT} is {CL_TRUE},
        the value is 0 otherwise.
| {CL_DEVICE_IMAGE3D_MAX_DEPTH_anchor}

include::{generated}/api/version-notes/CL_DEVICE_IMAGE3D_MAX_DEPTH.asciidoc[]
  | {size_t_TYPE}
      | Max depth of 3D image in pixels.

        The minimum value is 2048 if {CL_DEVICE_IMAGE_SUPPORT} is {CL_TRUE},
        the value is 0 otherwise.
| {CL_DEVICE_IMAGE_MAX_BUFFER_SIZE_anchor}

include::{generated}/api/version-notes/CL_DEVICE_IMAGE_MAX_BUFFER_SIZE.asciidoc[]
  | {size_t_TYPE}
      | Max number of pixels for a 1D image created from a buffer object.

        The minimum value is 65536 if {CL_DEVICE_IMAGE_SUPPORT} is {CL_TRUE},
        the value is 0 otherwise.
| {CL_DEVICE_IMAGE_MAX_ARRAY_SIZE_anchor}

include::{generated}/api/version-notes/CL_DEVICE_IMAGE_MAX_ARRAY_SIZE.asciidoc[]
  | {size_t_TYPE}
      | Max number of images in a 1D or 2D image array.

        The minimum value is 2048 if {CL_DEVICE_IMAGE_SUPPORT} is {CL_TRUE},
        the value is 0 otherwise.
| {CL_DEVICE_MAX_SAMPLERS_anchor}

include::{generated}/api/version-notes/CL_DEVICE_MAX_SAMPLERS.asciidoc[]
  | {cl_uint_TYPE}
      | Maximum number of samplers that can be used in a kernel.

        The minimum value is 16 if {CL_DEVICE_IMAGE_SUPPORT} is {CL_TRUE},
        the value is 0 otherwise.
| {CL_DEVICE_IMAGE_PITCH_ALIGNMENT_anchor}

include::{generated}/api/version-notes/CL_DEVICE_IMAGE_PITCH_ALIGNMENT.asciidoc[]

ifdef::cl_khr_image2d_from_buffer[]
The equivalent {CL_DEVICE_IMAGE_PITCH_ALIGNMENT_KHR_anchor} may be used if
the `<<cl_khr_image2d_from_buffer>>` extension is supported.
endif::cl_khr_image2d_from_buffer[]
  | {cl_uint_TYPE}
      | The row pitch alignment size in pixels for 2D images created from a
        buffer.
        The value returned must be a power of 2.

        Support for 2D images created from a buffer is required for an OpenCL 2.0, 2.1,
        or 2.2 device if {CL_DEVICE_IMAGE_SUPPORT} is {CL_TRUE}.

        This value must be 0 for devices that do not support 2D images created from a buffer.
| {CL_DEVICE_IMAGE_BASE_ADDRESS_ALIGNMENT_anchor}

include::{generated}/api/version-notes/CL_DEVICE_IMAGE_BASE_ADDRESS_ALIGNMENT.asciidoc[]

ifdef::cl_khr_image2d_from_buffer[]
The equivalent {CL_DEVICE_IMAGE_BASE_ADDRESS_ALIGNMENT_anchor} may be used
if the `<<cl_khr_image2d_from_buffer>>` extension is supported.
endif::cl_khr_image2d_from_buffer[]
  | {cl_uint_TYPE}
      | This query specifies the minimum alignment in pixels of the host_ptr
        specified to {clCreateBuffer} or {clCreateBufferWithProperties} when a 2D image
        is created from a buffer which was created using {CL_MEM_USE_HOST_PTR}.
        The value returned must be a power of 2.

        Support for 2D images created from a buffer is required for an OpenCL 2.0, 2.1,
        or 2.2 device if {CL_DEVICE_IMAGE_SUPPORT} is {CL_TRUE}.

        This value must be 0 for devices that do not support 2D images created from a buffer.
| {CL_DEVICE_MAX_PIPE_ARGS_anchor}

include::{generated}/api/version-notes/CL_DEVICE_MAX_PIPE_ARGS.asciidoc[]
  | {cl_uint_TYPE}
      | The maximum number of pipe objects that can be passed as arguments
        to a kernel.
        The minimum value is 16 for devices supporting pipes, and must be
        0 for devices that do not support pipes.
| {CL_DEVICE_PIPE_MAX_ACTIVE_RESERVATIONS_anchor}

include::{generated}/api/version-notes/CL_DEVICE_PIPE_MAX_ACTIVE_RESERVATIONS.asciidoc[]
  | {cl_uint_TYPE}
      | The maximum number of reservations that can be active for a pipe per
        work-item in a kernel.
        A work-group reservation is counted as one reservation per
        work-item.
        The minimum value is 1 for devices supporting pipes, and must be
        0 for devices that do not support pipes.
| {CL_DEVICE_PIPE_MAX_PACKET_SIZE_anchor}

include::{generated}/api/version-notes/CL_DEVICE_PIPE_MAX_PACKET_SIZE.asciidoc[]
  | {cl_uint_TYPE}
      | The maximum size of pipe packet in bytes.

        Support for pipes is required for an OpenCL 2.0, 2.1, or 2.2 device.
        The minimum value is 1024 bytes if the device supports pipes, and must be
        0 for devices that do not support pipes.
| {CL_DEVICE_MAX_PARAMETER_SIZE_anchor}

include::{generated}/api/version-notes/CL_DEVICE_MAX_PARAMETER_SIZE.asciidoc[]
  | {size_t_TYPE}
      | Max size in bytes of all arguments that can be passed to a kernel.

        The minimum value is 1024 for devices that are not of type
        {CL_DEVICE_TYPE_CUSTOM}.
        For this minimum value, only a maximum of 128 arguments can be
        passed to a kernel.
        For all other values, a maximum of 255 arguments can be passed
        to a kernel.
| {CL_DEVICE_MEM_BASE_ADDR_ALIGN_anchor}

include::{generated}/api/version-notes/CL_DEVICE_MEM_BASE_ADDR_ALIGN.asciidoc[]
  | {cl_uint_TYPE}
      | Alignment requirement (in bits) for sub-buffer offsets.
        The minimum value is the size (in bits) of the largest OpenCL
        built-in data type supported by the device (long16 in FULL profile,
        long16 or int16 in EMBEDDED profile) for devices that are not of
        type {CL_DEVICE_TYPE_CUSTOM}.
| {CL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE_anchor}

include::{generated}/api/version-notes/CL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE.asciidoc[]
  | {cl_uint_TYPE}
      | The minimum value is the size (in bytes) of the largest OpenCL data
        type supported by the device (`long16` in FULL profile, `long16` or
        `int16` in EMBEDDED profile).
| {CL_DEVICE_SINGLE_FP_CONFIG_anchor} footnote:native-rounding-modes[{fn-native-rounding-modes}]

include::{generated}/api/version-notes/CL_DEVICE_SINGLE_FP_CONFIG.asciidoc[]
  | {cl_device_fp_config_TYPE}
      | Describes single precision floating-point capability of the device.
        This is a bit-field that describes one or more of the following
        values:

        {CL_FP_DENORM_anchor} - denorms are supported +
        {CL_FP_INF_NAN_anchor} - INF and quiet NaNs are supported +
        {CL_FP_ROUND_TO_NEAREST_anchor}-- round to nearest even rounding mode
        supported +
        {CL_FP_ROUND_TO_ZERO_anchor} - round to zero rounding mode supported +
        {CL_FP_ROUND_TO_INF_anchor} - round to positive and negative infinity
        rounding modes supported +
        {CL_FP_FMA_anchor} - IEEE754-2008 fused multiply-add is supported +
        {CL_FP_CORRECTLY_ROUNDED_DIVIDE_SQRT_anchor} - divide and sqrt are correctly
        rounded as defined by the IEEE754 specification +
        {CL_FP_SOFT_FLOAT_anchor} - Basic floating-point operations (such as
        addition, subtraction, multiplication) are implemented in software

        For the full profile, the mandated minimum floating-point capability
        for devices that are not of type {CL_DEVICE_TYPE_CUSTOM} is:

        {CL_FP_ROUND_TO_NEAREST} \| +
        {CL_FP_INF_NAN}.

        For the embedded profile, see the
        <<embedded-profile-single-fp-config-requirements, dedicated table>>.

| {CL_DEVICE_DOUBLE_FP_CONFIG_anchor} footnote:native-rounding-modes[]

include::{generated}/api/version-notes/CL_DEVICE_DOUBLE_FP_CONFIG.asciidoc[]

Also see `<<cl_khr_fp64>>`.
  | {cl_device_fp_config_TYPE}
      | Describes double precision floating-point capability of the OpenCL
        device.
        This is a bit-field that describes one or more of the following
        values:

        {CL_FP_DENORM} - denorms are supported +
        {CL_FP_INF_NAN} - INF and NaNs are supported +
        {CL_FP_ROUND_TO_NEAREST} - round to nearest even rounding mode
        supported +
        {CL_FP_ROUND_TO_ZERO} - round to zero rounding mode supported +
        {CL_FP_ROUND_TO_INF} - round to positive and negative infinity
        rounding modes supported +
        {CL_FP_FMA} - IEEE754-2008 fused multiply-add is supported +
        {CL_FP_SOFT_FLOAT} - Basic floating-point operations (such as
        addition, subtraction, multiplication) are implemented in software

        Double precision is an optional feature so the mandated minimum
        double precision floating-point capability is 0.

        If double precision is supported by the device, then the minimum
        double precision floating-point capability for OpenCL 2.0 or
        newer devices is:

        {CL_FP_FMA} \| +
        {CL_FP_ROUND_TO_NEAREST} \| +
        {CL_FP_INF_NAN} \| +
        {CL_FP_DENORM}.

        or for OpenCL 1.0, OpenCL 1.1 or OpenCL 1.2 devices:

        {CL_FP_FMA} \| +
        {CL_FP_ROUND_TO_NEAREST} \| +
        {CL_FP_ROUND_TO_ZERO} \| +
        {CL_FP_ROUND_TO_INF} \| +
        {CL_FP_INF_NAN} \| +
        {CL_FP_DENORM}.
| {CL_DEVICE_GLOBAL_MEM_CACHE_TYPE_anchor}

include::{generated}/api/version-notes/CL_DEVICE_GLOBAL_MEM_CACHE_TYPE.asciidoc[]
  | {cl_device_mem_cache_type_TYPE}
      | Type of global memory cache supported.
        Valid values are: {CL_NONE}, {CL_READ_ONLY_CACHE_anchor}, and
        {CL_READ_WRITE_CACHE_anchor}.
| {CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE_anchor}

include::{generated}/api/version-notes/CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE.asciidoc[]
  | {cl_uint_TYPE}
      | Size of global memory cache line in bytes.
| {CL_DEVICE_GLOBAL_MEM_CACHE_SIZE_anchor}

include::{generated}/api/version-notes/CL_DEVICE_GLOBAL_MEM_CACHE_SIZE.asciidoc[]
  | {cl_ulong_TYPE}
      | Size of global memory cache in bytes.
| {CL_DEVICE_GLOBAL_MEM_SIZE_anchor}

include::{generated}/api/version-notes/CL_DEVICE_GLOBAL_MEM_SIZE.asciidoc[]
  | {cl_ulong_TYPE}
      | Size of global device memory in bytes.
| {CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE_anchor}

include::{generated}/api/version-notes/CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE.asciidoc[]
  | {cl_ulong_TYPE}
      | Max size in bytes of a constant buffer allocation.
        The minimum value is 64 KB for devices that are not of type
        {CL_DEVICE_TYPE_CUSTOM}.
| {CL_DEVICE_MAX_CONSTANT_ARGS_anchor}

include::{generated}/api/version-notes/CL_DEVICE_MAX_CONSTANT_ARGS.asciidoc[]
  | {cl_uint_TYPE}
      | Max number of arguments declared with the `+__constant+` qualifier
        in a kernel.
        The minimum value is 8 for devices that are not of type
        {CL_DEVICE_TYPE_CUSTOM}.
| {CL_DEVICE_MAX_GLOBAL_VARIABLE_SIZE_anchor}

include::{generated}/api/version-notes/CL_DEVICE_MAX_GLOBAL_VARIABLE_SIZE.asciidoc[]
  | {size_t_TYPE}
      | The maximum number of bytes of storage that may be allocated for any
        single variable in program scope or inside a function in an OpenCL
        kernel language declared in the global address space.

        Support for program scope global variables is required for an OpenCL 2.0,
        2.1, or 2.2 device.
        The minimum value is 64 KB if the device supports program scope global
        variables, and must be 0 for devices that do not support program scope
        global variables.
| {CL_DEVICE_GLOBAL_VARIABLE_PREFERRED_TOTAL_SIZE_anchor}

include::{generated}/api/version-notes/CL_DEVICE_GLOBAL_VARIABLE_PREFERRED_TOTAL_SIZE.asciidoc[]
  | {size_t_TYPE}
      | Maximum preferred total size, in bytes, of all program variables in
        the global address space.
        This is a performance hint.
        An implementation may place such variables in storage with optimized
        device access.
        This query returns the capacity of such storage.
        The minimum value is 0.
| {CL_DEVICE_LOCAL_MEM_TYPE_anchor}

include::{generated}/api/version-notes/CL_DEVICE_LOCAL_MEM_TYPE.asciidoc[]
  | {cl_device_local_mem_type_TYPE}
      | Type of local memory supported.
        This can be set to {CL_LOCAL_anchor} implying dedicated local memory storage
        such as SRAM , or {CL_GLOBAL_anchor}.

        For custom devices, {CL_NONE} can also be returned indicating no local
        memory support.
| {CL_DEVICE_LOCAL_MEM_SIZE_anchor}

include::{generated}/api/version-notes/CL_DEVICE_LOCAL_MEM_SIZE.asciidoc[]
  | {cl_ulong_TYPE}
      | Size of local memory region in bytes.
        The minimum value is 32 KB for devices that are not of type
        {CL_DEVICE_TYPE_CUSTOM}.
| {CL_DEVICE_ERROR_CORRECTION_SUPPORT_anchor}

include::{generated}/api/version-notes/CL_DEVICE_ERROR_CORRECTION_SUPPORT.asciidoc[]
  | {cl_bool_TYPE}
      | Is {CL_TRUE} if the device implements error correction for all
        accesses to compute device memory (global and constant).
        Is {CL_FALSE} if the device does not implement such error correction.
| {CL_DEVICE_HOST_UNIFIED_MEMORY_anchor}

include::{generated}/api/version-notes/CL_DEVICE_HOST_UNIFIED_MEMORY.asciidoc[]
  | {cl_bool_TYPE}
      | Is {CL_TRUE} if the device and the host have a unified memory subsystem
        and is {CL_FALSE} otherwise.
| {CL_DEVICE_PROFILING_TIMER_RESOLUTION_anchor}

include::{generated}/api/version-notes/CL_DEVICE_PROFILING_TIMER_RESOLUTION.asciidoc[]
  | {size_t_TYPE}
      | Describes the resolution of device timer.
        This is measured in nanoseconds.
        Refer to <<profiling-operations, Profiling Operations>> for details.
| {CL_DEVICE_ENDIAN_LITTLE_anchor}

include::{generated}/api/version-notes/CL_DEVICE_ENDIAN_LITTLE.asciidoc[]
  | {cl_bool_TYPE}
      | Is {CL_TRUE} if the OpenCL device is a little endian device and
        {CL_FALSE} otherwise
| {CL_DEVICE_AVAILABLE_anchor}

include::{generated}/api/version-notes/CL_DEVICE_AVAILABLE.asciidoc[]
  | {cl_bool_TYPE}
      | Is {CL_TRUE} if the device is available and {CL_FALSE} otherwise.
        A device is considered to be available if the device can be expected
        to successfully execute commands enqueued to the device.
| {CL_DEVICE_COMPILER_AVAILABLE_anchor}

include::{generated}/api/version-notes/CL_DEVICE_COMPILER_AVAILABLE.asciidoc[]
  | {cl_bool_TYPE}
      | Is {CL_FALSE} if the implementation does not have a compiler available
        to compile the program source.

        Is {CL_TRUE} if the compiler is available.
        This can be {CL_FALSE} for the embedded platform profile only.
| {CL_DEVICE_LINKER_AVAILABLE_anchor}

include::{generated}/api/version-notes/CL_DEVICE_LINKER_AVAILABLE.asciidoc[]
  | {cl_bool_TYPE}
      | Is {CL_FALSE} if the implementation does not have a linker available.
        Is {CL_TRUE} if the linker is available.

        This can be {CL_FALSE} for the embedded platform profile only.

        This must be {CL_TRUE} if {CL_DEVICE_COMPILER_AVAILABLE} is {CL_TRUE}.
| {CL_DEVICE_EXECUTION_CAPABILITIES_anchor}

include::{generated}/api/version-notes/CL_DEVICE_EXECUTION_CAPABILITIES.asciidoc[]
  | {cl_device_exec_capabilities_TYPE}
      | Describes the execution capabilities of the device.
        This is a bit-field that describes one or more of the following
        values:

        {CL_EXEC_KERNEL_anchor} - The OpenCL device can execute OpenCL kernels. +
        {CL_EXEC_NATIVE_KERNEL_anchor} - The OpenCL device can execute native
        kernels.

        The mandated minimum capability is: {CL_EXEC_KERNEL}.
| {CL_DEVICE_QUEUE_PROPERTIES_anchor}

include::{generated}/api/version-notes/CL_DEVICE_QUEUE_PROPERTIES.asciidoc[]
  | {cl_command_queue_properties_TYPE}
      | See description of {CL_DEVICE_QUEUE_ON_HOST_PROPERTIES}.
| {CL_DEVICE_QUEUE_ON_HOST_PROPERTIES_anchor}

include::{generated}/api/version-notes/CL_DEVICE_QUEUE_ON_HOST_PROPERTIES.asciidoc[]

  | {cl_command_queue_properties_TYPE}
      | Describes the on host command-queue properties supported by the
        device.
        This is a bit-field that describes one or more of the following
        values:

        {CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE} +
        {CL_QUEUE_PROFILING_ENABLE}

        These properties are described in the <<queue-properties-table,
        Queue Properties>> table.

        The mandated minimum capability is: {CL_QUEUE_PROFILING_ENABLE}.
| {CL_DEVICE_QUEUE_ON_DEVICE_PROPERTIES_anchor}

include::{generated}/api/version-notes/CL_DEVICE_QUEUE_ON_DEVICE_PROPERTIES.asciidoc[]
  | {cl_command_queue_properties_TYPE}
      | Describes the on device command-queue properties supported by the
        device.
        This is a bit-field that describes one or more of the following
        values:

        {CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE} +
        {CL_QUEUE_PROFILING_ENABLE}

        These properties are described in the <<queue-properties-table,
        Queue Properties>> table.

        Support for on-device queues is required for an OpenCL 2.0, 2.1, or 2.2 device.
        When on-device queues are supported, the mandated minimum capability is:

        {CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE} \| +
        {CL_QUEUE_PROFILING_ENABLE}.

        Must be 0 for devices that do not support on-device queues.
| {CL_DEVICE_QUEUE_ON_DEVICE_PREFERRED_SIZE_anchor}

include::{generated}/api/version-notes/CL_DEVICE_QUEUE_ON_DEVICE_PREFERRED_SIZE.asciidoc[]
  | {cl_uint_TYPE}
      | The preferred size of the device queue, in bytes.
        Applications should use this size for the device queue to ensure
        good performance.

        The minimum value is 16 KB for devices supporting on-device queues,
        and must be 0 for devices that do not support on-device queues.
| {CL_DEVICE_QUEUE_ON_DEVICE_MAX_SIZE_anchor}

include::{generated}/api/version-notes/CL_DEVICE_QUEUE_ON_DEVICE_MAX_SIZE.asciidoc[]
  | {cl_uint_TYPE}
      | The maximum size of the device queue in bytes.

        The minimum value is 256 KB for the full profile and 64 KB for the
        embedded profile for devices supporting on-device queues,
        and must be 0 for devices that do not support on-device queues.
| {CL_DEVICE_MAX_ON_DEVICE_QUEUES_anchor}

include::{generated}/api/version-notes/CL_DEVICE_MAX_ON_DEVICE_QUEUES.asciidoc[]
  | {cl_uint_TYPE}
      | The maximum number of device queues that can be created for this
        device in a single context.

        The minimum value is 1 for devices supporting on-device queues,
        and must be 0 for devices that do not support on-device queues.
| {CL_DEVICE_MAX_ON_DEVICE_EVENTS_anchor}

include::{generated}/api/version-notes/CL_DEVICE_MAX_ON_DEVICE_EVENTS.asciidoc[]
  | {cl_uint_TYPE}
      | The maximum number of events in use by a device queue.
        These refer to events returned by the `enqueue_` built-in functions
        to a device queue or user events returned by the `create_user_event`
        built-in function that have not been released.

        The minimum value is 1024 for devices supporting on-device queues,
        and must be 0 for devices that do not support on-device queues.
| {CL_DEVICE_BUILT_IN_KERNELS_anchor}

include::{generated}/api/version-notes/CL_DEVICE_BUILT_IN_KERNELS.asciidoc[]
  | {char_TYPE}[]
      | A semi-colon separated list of built-in kernels supported by the
        device.
        An empty string is returned if no built-in kernels are supported by
        the device.

| {CL_DEVICE_BUILT_IN_KERNELS_WITH_VERSION_anchor}

include::{generated}/api/version-notes/CL_DEVICE_BUILT_IN_KERNELS_WITH_VERSION.asciidoc[]

ifdef::cl_khr_extended_versioning[]
or

{CL_DEVICE_BUILT_IN_KERNELS_WITH_VERSION_KHR_anchor}

include::{generated}/api/version-notes/CL_DEVICE_BUILT_IN_KERNELS_WITH_VERSION_KHR.asciidoc[]
endif::cl_khr_extended_versioning[]
  | {cl_name_version_TYPE}[]

ifdef::cl_khr_extended_versioning[or {cl_name_version_khr_TYPE}[]]
      | Returns an array of descriptions for the built-in kernels supported by
        the device.
        Each built-in kernel may only be reported once.
        The list of reported kernels must match the list returned via
        {CL_DEVICE_BUILT_IN_KERNELS}.

| {CL_DEVICE_PLATFORM_anchor}

include::{generated}/api/version-notes/CL_DEVICE_PLATFORM.asciidoc[]
  | {cl_platform_id_TYPE}
      | The platform associated with this device.
| {CL_DEVICE_NAME_anchor}

include::{generated}/api/version-notes/CL_DEVICE_NAME.asciidoc[]
  | {char_TYPE}[]
      | Device name string.
| {CL_DEVICE_VENDOR_anchor}

include::{generated}/api/version-notes/CL_DEVICE_VENDOR.asciidoc[]
  | {char_TYPE}[]
      | Vendor name string.
| {CL_DRIVER_VERSION_anchor}

include::{generated}/api/version-notes/CL_DRIVER_VERSION.asciidoc[]
  | {char_TYPE}[]
      | OpenCL software driver version string.
        Follows a vendor-specific format.
| {CL_DEVICE_PROFILE_anchor}

include::{generated}/api/version-notes/CL_DEVICE_PROFILE.asciidoc[]
  | {char_TYPE}[]
      | OpenCL profile string.
        Returns the profile name supported by the device.
        The profile name returned can be one of the following strings:

        FULL_PROFILE - if the device supports the OpenCL specification
        (functionality defined as part of the core specification and does
        not require any extensions to be supported).

        EMBEDDED_PROFILE - if the device supports the OpenCL embedded
        profile.
| {CL_DEVICE_VERSION_anchor}

include::{generated}/api/version-notes/CL_DEVICE_VERSION.asciidoc[]
  | {char_TYPE}[]
      | OpenCL version string.
        Returns the OpenCL version supported by the device. This version
        string has the following format:

        _OpenCL<space><major_version.minor_version><space><vendor-specific
        information>_

        The major_version.minor_version value returned will be one of 1.0,
        1.1, 1.2, 2.0, 2.1, 2.2, or 3.0.
| {CL_DEVICE_NUMERIC_VERSION_anchor}

include::{generated}/api/version-notes/CL_DEVICE_NUMERIC_VERSION.asciidoc[]

ifdef::cl_khr_extended_versioning[]
or

{CL_DEVICE_NUMERIC_VERSION_KHR_anchor}

include::{generated}/api/version-notes/CL_DEVICE_NUMERIC_VERSION_KHR.asciidoc[]
endif::cl_khr_extended_versioning[]
  | {cl_version_TYPE}

ifdef::cl_khr_extended_versioning[or {cl_version_khr_TYPE}]
      | Returns the detailed (major, minor, patch) version supported by the
        device.
        The major and minor version numbers returned must match those
        returned via {CL_DEVICE_VERSION}.

| {CL_DEVICE_OPENCL_C_VERSION_anchor}

include::{generated}/api/version-notes/CL_DEVICE_OPENCL_C_VERSION.asciidoc[]
  | {char_TYPE}[]
      | Returns the highest fully backwards compatible OpenCL C version
        supported by the compiler for the device.
        For devices supporting compilation from OpenCL C source, this will
        return a version string with the following format:

        _OpenCL<space>C<space><major_version.minor_version><space><vendor-specific
        information>_

        For devices that support compilation from OpenCL C source:

        Because OpenCL 3.0 is backwards compatible with OpenCL C 1.2,
        an OpenCL 3.0 device must support at least OpenCL C 1.2.
        An OpenCL 3.0 device may return an OpenCL C version newer
        than OpenCL C 1.2 if and only if all optional OpenCL C
        features are supported by the device for the newer version.

        Support for OpenCL C 2.0 is required for an OpenCL 2.0, OpenCL 2.1,
        or OpenCL 2.2 device.

        Support for OpenCL C 1.2 is required for an OpenCL 1.2 device.

        Support for OpenCL C 1.1 is required for an OpenCL 1.1 device.

        Support for either OpenCL C 1.0 or OpenCL C 1.1 is required for
        an OpenCL 1.0 device.

        For devices that do not support compilation from OpenCL C source,
        such as when {CL_DEVICE_COMPILER_AVAILABLE} is {CL_FALSE}, this
        query may return an empty string.

        This query has been superseded by the {CL_DEVICE_OPENCL_C_ALL_VERSIONS}
        query, which returns a set of OpenCL C versions supported by a
        device.

| {CL_DEVICE_OPENCL_C_ALL_VERSIONS_anchor}

include::{generated}/api/version-notes/CL_DEVICE_OPENCL_C_ALL_VERSIONS.asciidoc[]
  | {cl_name_version_TYPE}[]
      | Returns an array of name, version descriptions listing all the versions
        of OpenCL C supported by the compiler for the device.
        In each returned description structure, the name field is required to be
        "OpenCL C". The list may include both newer non-backwards compatible
        OpenCL C versions, such as OpenCL C 3.0, and older OpenCL C versions
        with mandatory backwards compatibility.
        The version returned by {CL_DEVICE_OPENCL_C_VERSION} is required to be
        present in the list.

        For devices that support compilation from OpenCL C source:

        Because OpenCL 3.0 is backwards compatible with OpenCL C 1.2,
        and OpenCL C 1.2 is backwards compatible with OpenCL C 1.1 and
        OpenCL C 1.0, support for at least OpenCL C 3.0, OpenCL C 1.2,
        OpenCL C 1.1, and OpenCL C 1.0 is required for an OpenCL 3.0 device.

        Support for OpenCL C 2.0, OpenCL C 1.2, OpenCL C 1.1, and OpenCL C
        1.0 is required for an OpenCL 2.0, OpenCL 2.1, or OpenCL 2.2 device.

        Support for OpenCL C 1.2, OpenCL C 1.1, and OpenCL C 1.0 is required
        for an OpenCL 1.2 device.

        Support for OpenCL C 1.1 and OpenCL C 1.0 is required for an
        OpenCL 1.1 device.

        Support for at least OpenCL C 1.0 is required for an OpenCL 1.0 device.

        For devices that do not support compilation from OpenCL C source,
        this query may return an empty array.

ifdef::cl_khr_extended_versioning[]
| {CL_DEVICE_OPENCL_C_NUMERIC_VERSION_KHR_anchor}

include::{generated}/api/version-notes/CL_DEVICE_OPENCL_C_NUMERIC_VERSION_KHR.asciidoc[]
  | {cl_version_khr_TYPE}
    | Returns detailed (major, minor, patch) numeric version information.
      The major and minor version numbers returned must match those returned
      via {CL_DEVICE_OPENCL_C_VERSION}.

      This query was not promoted to core in OpenCL version 3.0, but the
      core query {CL_DEVICE_OPENCL_C_ALL_VERSIONS} can be used to obtain
      equivalent information.
endif::cl_khr_extended_versioning[]

| {CL_DEVICE_OPENCL_C_FEATURES_anchor}

include::{generated}/api/version-notes/CL_DEVICE_OPENCL_C_FEATURES.asciidoc[]
  | {cl_name_version_TYPE}[]
      | Returns an array of optional OpenCL C features supported by the
        compiler for the device alongside the OpenCL C version that introduced
        the feature macro.
        For example, if a compiler supports an OpenCL C 3.0 feature, the
        returned name will be the full name of the OpenCL C feature macro, and
        the returned version will be 3.0.0.

        For devices that do not support compilation from OpenCL C source,
        this query may return an empty array.

| {CL_DEVICE_EXTENSIONS_anchor}

include::{generated}/api/version-notes/CL_DEVICE_EXTENSIONS.asciidoc[]
  | {char_TYPE}[]
      | Returns a space separated list of extension names (the extension
        names themselves do not contain any spaces) supported by the device.
        The list of extension names may include Khronos approved extension
        names and vendor specified extension names.

        The following Khronos extension names must be returned by
        all devices that support OpenCL 1.1:

        `<<cl_khr_byte_addressable_store>>` +
        `<<cl_khr_global_int32_base_atomics>>` +
        `<<cl_khr_global_int32_extended_atomics>>` +
        `<<cl_khr_local_int32_base_atomics>>` +
        `<<cl_khr_local_int32_extended_atomics*

        Additionally, the following Khronos extension names must be returned
        by all devices that support OpenCL 1.2 when and only when the optional
        feature is supported:

        `<<cl_khr_fp64>>`

        Additionally, the following Khronos extension names must be returned
        by all devices that support OpenCL 2.0, OpenCL 2.1, or OpenCL 2.2.
        For devices that support OpenCL 3.0, these extension names must
        be returned when and only when the optional feature is supported:

        `<<cl_khr_3d_image_writes>>` +
        `<<cl_khr_depth_images>>` +
        `<<cl_khr_image2d_from_buffer>>`

        Please refer to the OpenCL Extension Specification or vendor
        provided documentation for a detailed description of these extensions.

| {CL_DEVICE_EXTENSIONS_WITH_VERSION_anchor}

include::{generated}/api/version-notes/CL_DEVICE_EXTENSIONS_WITH_VERSION.asciidoc[]

ifdef::cl_khr_extended_versioning[]
or

{CL_DEVICE_EXTENSIONS_WITH_VERSION_KHR_anchor}

include::{generated}/api/version-notes/CL_DEVICE_EXTENSIONS_WITH_VERSION_KHR.asciidoc[]
endif::cl_khr_extended_versioning[]
  | {cl_name_version_TYPE}[]

ifdef::cl_khr_extended_versioning[or {cl_name_version_khr_TYPE}[]]
      | Returns an array of description (name and version) structures. The same
        extension name must not be reported more than once. The list of
        extensions reported must match the list reported via
        {CL_DEVICE_EXTENSIONS}.

        See {CL_DEVICE_EXTENSIONS} for a list of extensions that are
        required to be reported for a given OpenCL version.

| {CL_DEVICE_PRINTF_BUFFER_SIZE_anchor}

include::{generated}/api/version-notes/CL_DEVICE_PRINTF_BUFFER_SIZE.asciidoc[]
  | {size_t_TYPE}
      | Maximum size in bytes of the internal buffer that holds the output
        of printf calls from a kernel.
        The minimum value for the FULL profile is 1 MB.
| {CL_DEVICE_PREFERRED_INTEROP_USER_SYNC_anchor}

include::{generated}/api/version-notes/CL_DEVICE_PREFERRED_INTEROP_USER_SYNC.asciidoc[]
  | {cl_bool_TYPE}
      | Is {CL_TRUE} if the devices preference is for the user to be
        responsible for synchronization, when sharing memory objects between
        OpenCL and other APIs such as DirectX, {CL_FALSE} if the device /
        implementation has a performant path for performing synchronization
        of memory object shared between OpenCL and other APIs such as
        DirectX.
| {CL_DEVICE_PARENT_DEVICE_anchor}

include::{generated}/api/version-notes/CL_DEVICE_PARENT_DEVICE.asciidoc[]
  | {cl_device_id_TYPE}
      | Returns the {cl_device_id_TYPE} of the parent device to which this
        sub-device belongs.
        If _device_ is a root-level device, a `NULL` value is returned.
| {CL_DEVICE_PARTITION_MAX_SUB_DEVICES_anchor}

include::{generated}/api/version-notes/CL_DEVICE_PARTITION_MAX_SUB_DEVICES.asciidoc[]
  | {cl_uint_TYPE}
      | Returns the maximum number of sub-devices that can be created when a
        device is partitioned.

        The value returned cannot exceed {CL_DEVICE_MAX_COMPUTE_UNITS}.
| {CL_DEVICE_PARTITION_PROPERTIES_anchor}

include::{generated}/api/version-notes/CL_DEVICE_PARTITION_PROPERTIES.asciidoc[]
  | {cl_device_partition_property_TYPE}[]
      | Returns the list of partition types supported by _device_.
        This is an array of {cl_device_partition_property_TYPE} values drawn from
        the following list:

        {CL_DEVICE_PARTITION_EQUALLY} +
        {CL_DEVICE_PARTITION_BY_COUNTS} +
        {CL_DEVICE_PARTITION_BY_AFFINITY_DOMAIN}

        If the device cannot be partitioned (i.e. there is no partitioning
        scheme supported by the device that will return at least two
        sub-devices), a value of 0 will be returned.
| {CL_DEVICE_PARTITION_AFFINITY_DOMAIN_anchor}

include::{generated}/api/version-notes/CL_DEVICE_PARTITION_AFFINITY_DOMAIN.asciidoc[]
  | {cl_device_affinity_domain_TYPE}
      | Returns the list of supported affinity domains for partitioning the
        device using {CL_DEVICE_PARTITION_BY_AFFINITY_DOMAIN}.
        This is a bit-field that describes one or more of the following
        values:

        {CL_DEVICE_AFFINITY_DOMAIN_NUMA_anchor} +
        {CL_DEVICE_AFFINITY_DOMAIN_L4_CACHE_anchor} +
        {CL_DEVICE_AFFINITY_DOMAIN_L3_CACHE_anchor} +
        {CL_DEVICE_AFFINITY_DOMAIN_L2_CACHE_anchor} +
        {CL_DEVICE_AFFINITY_DOMAIN_L1_CACHE_anchor} +
        {CL_DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE_anchor}

        If the device does not support any affinity domains, a value of 0
        will be returned.
| {CL_DEVICE_PARTITION_TYPE_anchor}

include::{generated}/api/version-notes/CL_DEVICE_PARTITION_TYPE.asciidoc[]
  | {cl_device_partition_property_TYPE}[]
      | Returns the properties argument specified in {clCreateSubDevices} if
        device is a sub-device.
        In the case where the properties argument to {clCreateSubDevices} is
        {CL_DEVICE_PARTITION_BY_AFFINITY_DOMAIN},
        {CL_DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE}, the affinity domain
        used to perform the partition will be returned.
        This can be one of the following values:

        {CL_DEVICE_AFFINITY_DOMAIN_NUMA} +
        {CL_DEVICE_AFFINITY_DOMAIN_L4_CACHE} +
        {CL_DEVICE_AFFINITY_DOMAIN_L3_CACHE} +
        {CL_DEVICE_AFFINITY_DOMAIN_L2_CACHE} +
        {CL_DEVICE_AFFINITY_DOMAIN_L1_CACHE}

        Otherwise the implementation may either return a
        _param_value_size_ret_ of 0 i.e. there is no partition type
        associated with device or can return a property value of 0 (where 0
        is used to terminate the partition property list) in the memory that
        _param_value_ points to.
| {CL_DEVICE_REFERENCE_COUNT_anchor} footnote:[{fn-reference-count-usage}]

include::{generated}/api/version-notes/CL_DEVICE_REFERENCE_COUNT.asciidoc[]
  | {cl_uint_TYPE}
      | Returns the _device_ reference count.
        If the device is a root-level device, a reference count of one is
        returned.
| {CL_DEVICE_SVM_CAPABILITIES_anchor}

include::{generated}/api/version-notes/CL_DEVICE_SVM_CAPABILITIES.asciidoc[]
  | {cl_device_svm_capabilities_TYPE}
      | Describes the various shared virtual memory (SVM) memory
        allocation types the device supports.
        This is a bit-field that describes a combination of the following
        values:

        {CL_DEVICE_SVM_COARSE_GRAIN_BUFFER_anchor} - Support for coarse-grain buffer
        sharing using {clSVMAlloc}.
        Memory consistency is guaranteed at synchronization points and the
        host must use calls to {clEnqueueMapBuffer} and
        {clEnqueueUnmapMemObject}. +
        {CL_DEVICE_SVM_FINE_GRAIN_BUFFER_anchor} - Support for fine-grain buffer
        sharing using {clSVMAlloc}.
        Memory consistency is guaranteed at synchronization points without
        need for {clEnqueueMapBuffer} and {clEnqueueUnmapMemObject}. +
        {CL_DEVICE_SVM_FINE_GRAIN_SYSTEM_anchor} - Support for sharing the host's
        entire virtual memory including memory allocated using *malloc*.
        Memory consistency is guaranteed at synchronization points. +
        {CL_DEVICE_SVM_ATOMICS_anchor} - Support for the OpenCL 2.0 atomic
        operations that provide memory consistency across the host and all
        OpenCL devices supporting fine-grain SVM allocations.

        The mandated minimum capability for an OpenCL 2.0, 2.1, or 2.2 device is
        {CL_DEVICE_SVM_COARSE_GRAIN_BUFFER}.

        For other device versions there is no mandated minimum capability.
| {CL_DEVICE_PREFERRED_PLATFORM_ATOMIC_ALIGNMENT_anchor}

include::{generated}/api/version-notes/CL_DEVICE_PREFERRED_PLATFORM_ATOMIC_ALIGNMENT.asciidoc[]
  | {cl_uint_TYPE}
      | Returns the value representing the preferred alignment in bytes for
        OpenCL 2.0 fine-grained SVM atomic types.
        This query can return 0 which indicates that the preferred alignment
        is aligned to the natural size of the type.
| {CL_DEVICE_PREFERRED_GLOBAL_ATOMIC_ALIGNMENT_anchor}

include::{generated}/api/version-notes/CL_DEVICE_PREFERRED_GLOBAL_ATOMIC_ALIGNMENT.asciidoc[]
  | {cl_uint_TYPE}
      | Returns the value representing the preferred alignment in bytes for
        OpenCL 2.0 atomic types to global memory.
        This query can return 0 which indicates that the preferred alignment
        is aligned to the natural size of the type.
| {CL_DEVICE_PREFERRED_LOCAL_ATOMIC_ALIGNMENT_anchor}

include::{generated}/api/version-notes/CL_DEVICE_PREFERRED_LOCAL_ATOMIC_ALIGNMENT.asciidoc[]
  | {cl_uint_TYPE}
      | Returns the value representing the preferred alignment in bytes for
        OpenCL 2.0 atomic types to local memory.
        This query can return 0 which indicates that the preferred alignment
        is aligned to the natural size of the type.
| {CL_DEVICE_MAX_NUM_SUB_GROUPS_anchor}

// Note: This sub-group property is not in cl_khr_subgroups.
include::{generated}/api/version-notes/CL_DEVICE_MAX_NUM_SUB_GROUPS.asciidoc[]
  | {cl_uint_TYPE}
      | Maximum number of sub-groups in a work-group that a device is
        capable of executing on a single compute unit, for any given
        kernel-instance running on the device.

        The minimum value is 1 if the device supports sub-groups, and must be
        0 for devices that do not support sub-groups.
        Support for sub-groups is required for an OpenCL 2.1 or 2.2 device.

        (Refer also to {clGetKernelSubGroupInfo}.)
| {CL_DEVICE_SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS_anchor}

// Note: This sub-group property is not in cl_khr_subgroups.
include::{generated}/api/version-notes/CL_DEVICE_SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS.asciidoc[]
  | {cl_bool_TYPE}
      | Is {CL_TRUE} if this device supports independent forward progress of
        sub-groups, {CL_FALSE} otherwise.

        This query must return {CL_TRUE} for devices that support the
        `<<cl_khr_subgroups>>` extension, and must return {CL_FALSE} for
        devices that do not support sub-groups.

| {CL_DEVICE_ATOMIC_MEMORY_CAPABILITIES_anchor}

include::{generated}/api/version-notes/CL_DEVICE_ATOMIC_MEMORY_CAPABILITIES.asciidoc[]
  | {cl_device_atomic_capabilities_TYPE}
      | Describes the various memory orders and scopes that the device supports for atomic memory operations.
        This is a bit-field that describes a combination of the following
        values:

        {CL_DEVICE_ATOMIC_ORDER_RELAXED_anchor} - Support for the *relaxed* memory order. +
        {CL_DEVICE_ATOMIC_ORDER_ACQ_REL_anchor} - Support for the *acquire*, *release*, and *acquire-release* memory orders. +
        {CL_DEVICE_ATOMIC_ORDER_SEQ_CST_anchor} - Support for the *sequentially consistent* memory order.

        Because atomic memory orders are hierarchical, a device that supports a strong memory order must also support all weaker memory orders.

        {CL_DEVICE_ATOMIC_SCOPE_WORK_ITEM_anchor} footnote:[{fn-atomic-scope-work-item}] - Support for memory ordering constraints that apply to a single work-item. +
        {CL_DEVICE_ATOMIC_SCOPE_WORK_GROUP_anchor} - Support for memory ordering constraints that apply to all work-items in a work-group. +
        {CL_DEVICE_ATOMIC_SCOPE_DEVICE_anchor} - Support for memory ordering constraints that apply to all work-items executing on the device. +
        {CL_DEVICE_ATOMIC_SCOPE_ALL_DEVICES_anchor} - Support for memory ordering constraints that apply to all work-items executing across all devices that can share SVM memory with each other and the host process.

        Because atomic scopes are hierarchical, a device that supports a wide scope must also support all narrower scopes, except for the work-item scope, which is a special case.

        The mandated minimum capability is:

        {CL_DEVICE_ATOMIC_ORDER_RELAXED} \| +
        {CL_DEVICE_ATOMIC_SCOPE_WORK_GROUP}

| {CL_DEVICE_ATOMIC_FENCE_CAPABILITIES_anchor}

include::{generated}/api/version-notes/CL_DEVICE_ATOMIC_FENCE_CAPABILITIES.asciidoc[]
  | {cl_device_atomic_capabilities_TYPE}
      | Describes the various memory orders and scopes that the device supports for atomic fence operations.
        This is a bit-field that has the same set of possible values as described for {CL_DEVICE_ATOMIC_MEMORY_CAPABILITIES}.

        The mandated minimum capability is:

        {CL_DEVICE_ATOMIC_ORDER_RELAXED} \| +
        {CL_DEVICE_ATOMIC_ORDER_ACQ_REL} \| +
        {CL_DEVICE_ATOMIC_SCOPE_WORK_GROUP}

| {CL_DEVICE_NON_UNIFORM_WORK_GROUP_SUPPORT_anchor}

include::{generated}/api/version-notes/CL_DEVICE_NON_UNIFORM_WORK_GROUP_SUPPORT.asciidoc[]
  | {cl_bool_TYPE}
      | Is {CL_TRUE} if the device supports non-uniform work-groups, and {CL_FALSE} otherwise.
// This query didn't exist pre-OpenCL 3.0, but:
//Support for non-uniform work-groups is required for an OpenCL 2.0, 2.1, or 2.2 device.

| {CL_DEVICE_WORK_GROUP_COLLECTIVE_FUNCTIONS_SUPPORT_anchor}

include::{generated}/api/version-notes/CL_DEVICE_WORK_GROUP_COLLECTIVE_FUNCTIONS_SUPPORT.asciidoc[]
  | {cl_bool_TYPE}
      | Is {CL_TRUE} if the device supports work-group collective functions e.g. `work_group_broadcast`, `work_group_reduce`, and `work_group_scan`, and {CL_FALSE} otherwise.
// This query didn't exist pre-OpenCL 3.0, but:
//Support for work-group collective functions is required for an OpenCL 2.0, 2.1, or 2.2 device.

| {CL_DEVICE_GENERIC_ADDRESS_SPACE_SUPPORT_anchor}

include::{generated}/api/version-notes/CL_DEVICE_GENERIC_ADDRESS_SPACE_SUPPORT.asciidoc[]
  | {cl_bool_TYPE}
      | Is {CL_TRUE} if the device supports the generic address space and its associated built-in functions, and {CL_FALSE} otherwise.
// This query didn't exist pre-OpenCL 3.0, but:
//Support for the generic address space is required for an OpenCL 2.0, 2.1, or 2.2 device.

| {CL_DEVICE_DEVICE_ENQUEUE_CAPABILITIES_anchor}

include::{generated}/api/version-notes/CL_DEVICE_DEVICE_ENQUEUE_CAPABILITIES.asciidoc[]
  | {cl_device_device_enqueue_capabilities_TYPE}
      | Describes device-side enqueue capabilities of the device.
        This is a bit-field that describes one or more of the following
        values:

        {CL_DEVICE_QUEUE_SUPPORTED_anchor} - Device supports device-side enqueue and on-device queues. +
        {CL_DEVICE_QUEUE_REPLACEABLE_DEFAULT_anchor} - Device supports a replaceable default on-device queue.

        If {CL_DEVICE_QUEUE_REPLACEABLE_DEFAULT} is set, {CL_DEVICE_QUEUE_SUPPORTED} must also be set.

        Devices that set {CL_DEVICE_QUEUE_SUPPORTED} for {CL_DEVICE_DEVICE_ENQUEUE_CAPABILITIES} must also return {CL_TRUE} for {CL_DEVICE_GENERIC_ADDRESS_SPACE_SUPPORT}.

// This query didn't exist pre-OpenCL 3.0, but:
//Support for device-side enqueue and on-device queues is required for an OpenCL 2.0, 2.1, or 2.2 device.

| {CL_DEVICE_PIPE_SUPPORT_anchor}

include::{generated}/api/version-notes/CL_DEVICE_PIPE_SUPPORT.asciidoc[]
  | {cl_bool_TYPE}
      | Is {CL_TRUE} if the device supports pipes, and {CL_FALSE} otherwise.

      Devices that return {CL_TRUE} for {CL_DEVICE_PIPE_SUPPORT} must also return {CL_TRUE} for {CL_DEVICE_GENERIC_ADDRESS_SPACE_SUPPORT}.
// This query didn't exist pre-OpenCL 3.0, but:
//Support for pipes is required for an OpenCL 2.0, 2.1, or 2.2 device.

| {CL_DEVICE_PREFERRED_WORK_GROUP_SIZE_MULTIPLE_anchor}

include::{generated}/api/version-notes/CL_DEVICE_PREFERRED_WORK_GROUP_SIZE_MULTIPLE.asciidoc[]
  | {size_t_TYPE}
      | Returns the preferred multiple of work-group size for the given device.
        This is a performance hint intended as a guide when specifying the local work size argument to {clEnqueueNDRangeKernel}.

        (Refer also to {clGetKernelWorkGroupInfo} where {CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE}
        can return a different value to {CL_DEVICE_PREFERRED_WORK_GROUP_SIZE_MULTIPLE} which may be more optimal.)

| {CL_DEVICE_LATEST_CONFORMANCE_VERSION_PASSED_anchor}

include::{generated}/api/version-notes/CL_DEVICE_LATEST_CONFORMANCE_VERSION_PASSED.asciidoc[]
  | {char_TYPE}[]
      | Returns the latest version of the conformance test suite that this device
        has fully passed in accordance with the official conformance process.

ifdef::cl_khr_command_buffer[]
| {CL_DEVICE_COMMAND_BUFFER_CAPABILITIES_KHR_anchor}

include::{generated}/api/version-notes/CL_DEVICE_COMMAND_BUFFER_CAPABILITIES_KHR.asciidoc[]

  | {cl_device_command_buffer_capabilities_khr_TYPE}
      | Describes device command-buffer capabilities, encoded as bits in a bitfield.
        Supported capabilities are:

        {CL_COMMAND_BUFFER_CAPABILITY_KERNEL_PRINTF_KHR_anchor} Device
        supports the ability to record commands that execute kernels which
        contain printf calls.

include::{generated}/api/version-notes/CL_COMMAND_BUFFER_CAPABILITY_KERNEL_PRINTF_KHR.asciidoc[]

        {CL_COMMAND_BUFFER_CAPABILITY_DEVICE_SIDE_ENQUEUE_KHR_anchor} Device
        supports the ability to record commands that execute kernels which
        contain device-side kernel-enqueue calls.

include::{generated}/api/version-notes/CL_COMMAND_BUFFER_CAPABILITY_DEVICE_SIDE_ENQUEUE_KHR.asciidoc[]

        {CL_COMMAND_BUFFER_CAPABILITY_SIMULTANEOUS_USE_KHR_anchor} Device
        supports the command-buffers having a <<pending_count, Pending
        Count>> that exceeds 1.

include::{generated}/api/version-notes/CL_COMMAND_BUFFER_CAPABILITY_SIMULTANEOUS_USE_KHR.asciidoc[]

        {CL_COMMAND_BUFFER_CAPABILITY_OUT_OF_ORDER_KHR_anchor} Device
        supports the ability to record command-buffers to out-of-order
        command-queues.

include::{generated}/api/version-notes/CL_COMMAND_BUFFER_CAPABILITY_OUT_OF_ORDER_KHR.asciidoc[]

ifdef::cl_khr_command_buffer_multi_device[]
        {CL_COMMAND_BUFFER_CAPABILITY_MULTIPLE_QUEUE_KHR_anchor} Device
        supports the ability to record commands to more than one
        command-queue associated with _device_ in a single command-buffer.

include::{generated}/api/version-notes/CL_COMMAND_BUFFER_CAPABILITY_MULTIPLE_QUEUE_KHR.asciidoc[]
endif::cl_khr_command_buffer_multi_device[]

| {CL_DEVICE_COMMAND_BUFFER_REQUIRED_QUEUE_PROPERTIES_KHR_anchor}

include::{generated}/api/version-notes/CL_DEVICE_COMMAND_BUFFER_REQUIRED_QUEUE_PROPERTIES_KHR.asciidoc[]

  | {cl_command_queue_properties_TYPE}
      | Bitmask of the minimum properties with which a command-queue must be created
        to allow a command-buffer to be executed on it.
        It is valid for a command-queue to be created with extra properties
        in addition to this base requirement and still be compatible with
        command-buffer execution.
endif::cl_khr_command_buffer[]

ifdef::cl_khr_command_buffer_multi_device[]
| {CL_DEVICE_COMMAND_BUFFER_NUM_SYNC_DEVICES_KHR_anchor}

include::{generated}/api/version-notes/CL_DEVICE_COMMAND_BUFFER_NUM_SYNC_DEVICES_KHR.asciidoc[]
  | {cl_uint_TYPE}
    | Return the number of root devices listed in
      {CL_DEVICE_COMMAND_BUFFER_SYNC_DEVICES_KHR} that _device_ can use
      device-side synchronization with.

| {CL_DEVICE_COMMAND_BUFFER_SYNC_DEVICES_KHR_anchor}

include::{generated}/api/version-notes/CL_DEVICE_COMMAND_BUFFER_SYNC_DEVICES_KHR.asciidoc[]
  | {cl_device_id_TYPE}[]
    | Return the list of root devices _device_ can use device-side
      synchronization with.
      A device should list itself only if it has native support for
      synchronizing commands.
      Sub-devices are not listed to avoid non-deterministic results as
      sub-devices are created.
      Instead if a root device is listed, then any of its partitioned
      sub-devices can also be natively synchronized with.
endif::cl_khr_command_buffer_multi_device[]

ifdef::cl_khr_command_buffer_mutable_dispatch[]
| {CL_DEVICE_MUTABLE_DISPATCH_CAPABILITIES_KHR_anchor}

include::{generated}/api/version-notes/CL_DEVICE_MUTABLE_DISPATCH_CAPABILITIES_KHR.asciidoc[]
  | {cl_mutable_dispatch_fields_khr_TYPE}
    | Describes device mutable-dispatch capabilities, encoded as bits in a
      bitfield.
      Supported capabilities are:

      {CL_MUTABLE_DISPATCH_GLOBAL_OFFSET_KHR_anchor} - Device supports the
      ability to modify the _global_work_offset_ of kernel execution after
      command recording.

include::{generated}/api/version-notes/CL_MUTABLE_DISPATCH_GLOBAL_OFFSET_KHR.asciidoc[]

      {CL_MUTABLE_DISPATCH_GLOBAL_SIZE_KHR_anchor} - Device supports the
      ability to modify the _global_work_size_ of kernel execution after
      command recording.

include::{generated}/api/version-notes/CL_MUTABLE_DISPATCH_GLOBAL_SIZE_KHR.asciidoc[]

      {CL_MUTABLE_DISPATCH_LOCAL_SIZE_KHR_anchor} - Device supports the
      ability to modify the _local_work_size_ of kernel execution after
      command recording.

include::{generated}/api/version-notes/CL_MUTABLE_DISPATCH_LOCAL_SIZE_KHR.asciidoc[]

      {CL_MUTABLE_DISPATCH_ARGUMENTS_KHR_anchor} - Device supports the
      ability to modify arguments set on a kernel after command recording.

include::{generated}/api/version-notes/CL_MUTABLE_DISPATCH_ARGUMENTS_KHR.asciidoc[]

      {CL_MUTABLE_DISPATCH_EXEC_INFO_KHR_anchor} - Device supports the
      ability to modify execution information set on a kernel after command
      recording.

include::{generated}/api/version-notes/CL_MUTABLE_DISPATCH_EXEC_INFO_KHR.asciidoc[]
endif::cl_khr_command_buffer_mutable_dispatch[]

ifdef::cl_khr_device_uuid[]
| {CL_DEVICE_UUID_KHR_anchor}

include::{generated}/api/version-notes/CL_DEVICE_UUID_KHR.asciidoc[]

  | {cl_uchar_TYPE}[{CL_UUID_SIZE_KHR}]
      | Returns a universally unique identifier (UUID) for the device.

        Device UUIDs must be immutable for a given device across processes,
        driver APIs, driver versions, and system reboots.
| {CL_DRIVER_UUID_KHR_anchor}

include::{generated}/api/version-notes/CL_DRIVER_UUID_KHR.asciidoc[]

  | {cl_uchar_TYPE}[{CL_UUID_SIZE_KHR}]
      | Returns a universally unique identifier (UUID) for the software driver
        for the device.
| {CL_DEVICE_LUID_VALID_KHR_anchor}

include::{generated}/api/version-notes/CL_DEVICE_LUID_VALID_KHR.asciidoc[]

  | {cl_bool_TYPE}
      | Returns {CL_TRUE} if the device has a valid LUID and {CL_FALSE}
        otherwise.
| {CL_DEVICE_LUID_KHR_anchor}

include::{generated}/api/version-notes/CL_DEVICE_LUID_KHR.asciidoc[]

  | {cl_uchar_TYPE}[{CL_LUID_SIZE_KHR}]
      | Returns a locally unique identifier (LUID) for the device.

        It is not an error to query {CL_DEVICE_LUID_KHR} when
        {CL_DEVICE_LUID_VALID_KHR} returns {CL_FALSE}, but in this case the
        returned LUID value is undefined.

        When {CL_DEVICE_LUID_VALID_KHR} returns {CL_TRUE}, and the OpenCL
        device is running on the Windows operating system, the returned LUID
        value can be cast to an `LUID` object and must be equal to the locally
        unique identifier of an `IDXGIAdapter1` object that corresponds to the
        OpenCL device.
| {CL_DEVICE_NODE_MASK_KHR_anchor}

include::{generated}/api/version-notes/CL_DEVICE_NODE_MASK_KHR.asciidoc[]

  | {cl_uint_TYPE}
      | Returns a node mask for the device.

        It is not an error to query {CL_DEVICE_NODE_MASK_KHR} when
        {CL_DEVICE_LUID_VALID_KHR} returns {CL_FALSE}, but in this case the
        returned node mask is undefined.

        When {CL_DEVICE_LUID_VALID_KHR} returns {CL_TRUE}, the returned node
        mask must contain exactly one bit.
        If the OpenCL device is running on an operating system that supports
        the Direct3D 12 API and the OpenCL device corresponds to an individual
        device in a linked device adapter, the returned node mask identifies
        the Direct3D 12 node corresponding to the OpenCL device.
        Otherwise, the returned node mask must be `1`.
endif::cl_khr_device_uuid[]

ifdef::cl_khr_external_memory[]
| {CL_DEVICE_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES_KHR_anchor}

include::{generated}/api/version-notes/CL_DEVICE_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES_KHR.asciidoc[]

  | {cl_external_memory_handle_type_khr_TYPE}[]
      | Returns the list of importable external memory handle types
        supported by _device_.

        Must return a non-empty list of external memory handle types for at
        least one of the devices in the platform.

| {CL_DEVICE_EXTERNAL_MEMORY_IMPORT_ASSUME_LINEAR_IMAGES_HANDLE_TYPES_KHR_anchor}

include::{generated}/api/version-notes/CL_DEVICE_EXTERNAL_MEMORY_IMPORT_ASSUME_LINEAR_IMAGES_HANDLE_TYPES_KHR.asciidoc[]

  | {cl_external_memory_handle_type_khr_TYPE}[]
      | Returns the list of importable external memory handle types
        supported by _device_, that are assumed to apply linear layout to
        imported images when no other tiling information is provided.

        This list contains a subset of
        {CL_DEVICE_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES_KHR}.
        The returned list may be empty.

        External memory handle types not in
        {CL_DEVICE_EXTERNAL_MEMORY_IMPORT_ASSUME_LINEAR_IMAGES_HANDLE_TYPES_KHR}
        may have any memory layout.
        The layout interpretation of images imported with these handle types
        is implementation defined.
endif::cl_khr_external_memory[]

ifdef::cl_khr_fp16[]
| {CL_DEVICE_HALF_FP_CONFIG_anchor}

include::{generated}/api/version-notes/CL_DEVICE_HALF_FP_CONFIG.asciidoc[]
  | {cl_device_fp_config_TYPE}
      | Describes half-precision floating-point capability of the OpenCL
        device.
        This is a bit-field that describes one or more of the following
        values:

        {CL_FP_DENORM} - denorms are supported +
        {CL_FP_INF_NAN} - INF and NaNs are supported +
        {CL_FP_ROUND_TO_NEAREST} - round to nearest even rounding mode
        supported +
        {CL_FP_ROUND_TO_ZERO} - round to zero rounding mode supported +
        {CL_FP_ROUND_TO_INF} - round to positive and negative infinity
        rounding modes supported +
        {CL_FP_FMA} - IEEE754-2008 fused multiply-add is supported +
        {CL_FP_SOFT_FLOAT} - Basic floating-point operations (such as
        addition, subtraction, multiplication) are implemented in software

        If half-precision is supported by the device, then the minimum
        half-precision floating-point capability for OpenCL 2.0 or newer
        devices is:

        {CL_FP_ROUND_TO_ZERO}

        or

        {CL_FP_ROUND_TO_NEAREST} \| +
        {CL_FP_INF_NAN}.
endif::cl_khr_fp16[]

ifdef::cl_khr_integer_dot_product[]
| {CL_DEVICE_INTEGER_DOT_PRODUCT_CAPABILITIES_KHR_anchor}

include::{generated}/api/version-notes/CL_DEVICE_INTEGER_DOT_PRODUCT_CAPABILITIES_KHR.asciidoc[]
  | {cl_device_integer_dot_product_capabilities_khr_type}
      | Returns the integer dot product capabilities supported by the
        device.

        {CL_DEVICE_INTEGER_DOT_PRODUCT_INPUT_4x8BIT_PACKED_KHR} is always
        set, indicating that all implementations that support
        `<<cl_khr_integer_dot_product>>` must support dot product built-in
        functions and, when SPIR-V is supported, SPIR-V instructions that
        take four-component vectors of 8-bit integers packed into 32-bit
        integers as input.

        {CL_DEVICE_INTEGER_DOT_PRODUCT_INPUT_4x8BIT_KHR} is set when dot
        product built-in functions and, when SPIR-V is supported, SPIR-V
        instructions that take four-component of 8-bit elements as input are
        supported.
        NOTE: {CL_DEVICE_INTEGER_DOT_PRODUCT_INPUT_4x8BIT_KHR}
        must be set in version 2.x of the extension.

| {CL_DEVICE_INTEGER_DOT_PRODUCT_ACCELERATION_PROPERTIES_8BIT_KHR_anchor}

include::{generated}/api/version-notes/CL_DEVICE_INTEGER_DOT_PRODUCT_ACCELERATION_PROPERTIES_8BIT_KHR.asciidoc[]

  | {cl_device_integer_dot_product_acceleration_properties_khr_TYPE}
      | Returns a structure describing the exact 8-bit dot product
        combinations that are <<integer-dot-product-acceleration-properties,
        accelerated>> on the device.
        Each member is {CL_TRUE} if the combination it corresponds to is
        accelerated, {CL_FALSE} otherwise.
        NOTE:
        {CL_DEVICE_INTEGER_DOT_PRODUCT_ACCELERATION_PROPERTIES_8BIT_KHR} is
        missing before version 2.0 of the extension.

| {CL_DEVICE_INTEGER_DOT_PRODUCT_ACCELERATION_PROPERTIES_4x8BIT_PACKED_KHR_anchor}

include::{generated}/api/version-notes/CL_DEVICE_INTEGER_DOT_PRODUCT_ACCELERATION_PROPERTIES_4x8BIT_PACKED_KHR.asciidoc[]

  | {cl_device_integer_dot_product_acceleration_properties_khr_TYPE}
      | Returns a structure describing the exact 4x8-bit packed dot product
        combinations that are <<integer-dot-product-acceleration-properties,
        accelerated>> on the device.
        Each member is {CL_TRUE} if the combination it corresponds to is
        accelerated, {CL_FALSE} otherwise.
        NOTE:
        {CL_DEVICE_INTEGER_DOT_PRODUCT_ACCELERATION_PROPERTIES_4x8BIT_PACKED_KHR}
        is missing before version 2.0 of the extension.
endif::cl_khr_integer_dot_product[]

ifdef::cl_khr_pci_bus_info[]
| {CL_DEVICE_PCI_BUS_INFO_KHR_anchor}

include::{generated}/api/version-notes/CL_DEVICE_PCI_BUS_INFO_KHR.asciidoc[]
  | {cl_device_pci_bus_info_khr_TYPE}
    | Returns PCI bus information for the device.

      The PCI bus information is returned as a single structure that
      includes the PCI bus domain, the PCI bus identifier, the PCI device
      identifier, and the PCI device function identifier.
endif::cl_khr_pci_bus_info[]

ifdef::cl_khr_semaphore[]
| {CL_DEVICE_SEMAPHORE_TYPES_KHR_anchor}

include::{generated}/api/version-notes/CL_DEVICE_SEMAPHORE_TYPES_KHR.asciidoc[]
  | {cl_semaphore_type_khr_TYPE}[]
      | Returns the list of the semaphore types supported by _device_.

        Must return a non-empty list for at least one of the devices in the
        platform, meeting the minimum requirements described for
        {cl_semaphore_type_khr_TYPE}.
endif::cl_khr_semaphore[]

ifdef::cl_khr_external_semaphore[]
| {CL_DEVICE_SEMAPHORE_IMPORT_HANDLE_TYPES_KHR_anchor}

include::{generated}/api/version-notes/CL_DEVICE_SEMAPHORE_IMPORT_HANDLE_TYPES_KHR.asciidoc[]
  | {cl_external_semaphore_handle_type_khr_TYPE}[]
    | Returns the list of importable external semaphore handle types
      supported by _device_.

      This size of this query may be 0 indicating that the device does not
      support importing semaphores.
| {CL_DEVICE_SEMAPHORE_EXPORT_HANDLE_TYPES_KHR_anchor}

include::{generated}/api/version-notes/CL_DEVICE_SEMAPHORE_EXPORT_HANDLE_TYPES_KHR.asciidoc[]
  | {cl_external_semaphore_handle_type_khr_TYPE}[]
    | Returns the list of exportable external semaphore handle types
      supported by _device_.

      This size of this query may be 0 indicating that the device does not
      support exporting semaphores.
endif::cl_khr_external_semaphore[]

ifdef::cl_khr_spir[]
| {CL_DEVICE_SPIR_VERSIONS_anchor}

include::{generated}/api/version-notes/CL_DEVICE_SPIR_VERSIONS.asciidoc[]
  | {char_TYPE}[]
    | A space separated list of SPIR versions supported by the device.

      For example, returning `"1.2"` in this query implies that SPIR version
      1.2 is supported by the implementation.
endif::cl_khr_spir[]

ifdef::cl_khr_subgroup_named_barrier[]
| {CL_DEVICE_MAX_NAMED_BARRIER_COUNT_KHR_anchor}

include::{generated}/api/version-notes/CL_DEVICE_MAX_NAMED_BARRIER_COUNT_KHR.asciidoc[]
  | {cl_uint_TYPE}
    | Maximum number of named barriers in a work-group for any given
      kernel-instance running on the device.
      The minimum value is 8.
endif::cl_khr_subgroup_named_barrier[]

ifdef::cl_khr_terminate_context[]
| {CL_DEVICE_TERMINATE_CAPABILITY_KHR_anchor}

include::{generated}/api/version-notes/CL_DEVICE_TERMINATE_CAPABILITY_KHR.asciidoc[]
  | {cl_device_terminate_capability_khr_TYPE}
    | Describes the termination capability of the OpenCL device.
      This is a bit-field, where the following values are currently
      supported:

      {CL_DEVICE_TERMINATE_CAPABILITY_CONTEXT_KHR_anchor} - Indicates that
      context termination is supported.
endif::cl_khr_terminate_context[]
|====

ifdef::cl_khr_integer_dot_product[]
OpenCL 3 devices must report the following feature macros via
{CL_DEVICE_OPENCL_C_FEATURES} when the corresponding bit is set in the bitfield
returned for {CL_DEVICE_INTEGER_DOT_PRODUCT_CAPABILITIES_KHR}:

[cols="1,1",options="header"]
|====
| Feature Bit | Feature Macro
| {CL_DEVICE_INTEGER_DOT_PRODUCT_INPUT_4x8BIT_PACKED_KHR}
  | `__opencl_c_integer_dot_product_input_4x8bit_packed`
| {CL_DEVICE_INTEGER_DOT_PRODUCT_INPUT_4x8BIT_KHR}
  | `__opencl_c_integer_dot_product_input_4x8bit`
|====
endif::cl_khr_integer_dot_product[]

ifdef::cl_khr_external_semaphore[]
One of the two queries {CL_DEVICE_SEMAPHORE_IMPORT_HANDLE_TYPES_KHR} and
{CL_DEVICE_SEMAPHORE_EXPORT_HANDLE_TYPES_KHR} must return a non-empty list
indicating support for at least one of the valid semaphore handle types
either for import, for export, or both.
endif::cl_khr_external_semaphore[]

ifdef::cl_khr_device_uuid[]
[NOTE]
.Note
====
While {CL_DEVICE_UUID_KHR} is specified to remain consistent across driver
versions and system reboots, it is not intended to be usable as a
serializable persistent identifier for a device.
It may change when a device is physically added to, removed from, or moved
to a different connector in a system while that system is powered down.
Further, there is no reasonable way to verify with conformance testing that
a given device retains the same UUID in a given system across all driver
versions supported in that system.
While implementations should make every effort to report consistent device
UUIDs across driver versions, applications should avoid relying on the
persistence of this value for uses other than identifying compatible devices
for external object sharing purposes.
====
endif::cl_khr_device_uuid[]

// refError

{clGetDeviceInfo} returns {CL_SUCCESS} if the function is executed
successfully.
Otherwise, it returns one of the following errors:

  * {CL_INVALID_DEVICE} if _device_ is not a valid device.
  * {CL_INVALID_VALUE} if _param_name_ is not one of the supported values or
    if size in bytes specified by _param_value_size_ is < size of return
    type as specified in the <<device-queries-table, Device Queries>> table
    and _param_value_ is not a `NULL` value or if _param_name_ is a value
    that is available as an extension and the corresponding extension is not
    supported by the device.
  * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources required
    by the OpenCL implementation on the device.
  * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources
    required by the OpenCL implementation on the host.
--

ifdef::cl_khr_integer_dot_product[]
[open,refpage='cl_device_integer_dot_product_acceleration_properties_khr',desc='Structure describing supported dot product operations',type='structs']
--
[[integer-dot-product-acceleration-properties]]
The {cl_device_integer_dot_product_acceleration_properties_khr_TYPE} structure
describes the exact dot product operations that are accelerated on the device:

include::{generated}/api/structs/cl_device_integer_dot_product_acceleration_properties_khr.txt[]

 * _signed_accelerated_ is {CL_TRUE} when signed dot product operations are
   accelerated, {CL_FALSE} otherwise.
 * _unsigned_accelerated_ is {CL_TRUE} when unsigned dot product operations
   are accelerated, {CL_FALSE} otherwise.
 * _mixed_signedness_accelerated_ is {CL_TRUE} when mixed signedness dot
   product operations are accelerated, {CL_FALSE} otherwise.
 * _accumulating_saturating_signed_accelerated_ is {CL_TRUE} when accumulating
   saturating signed dot product operations are accelerated, {CL_FALSE}
   otherwise.
 * _accumulating_saturating_unsigned_accelerated_ is {CL_TRUE} when accumulating
   saturating unsigned dot product operations are accelerated, {CL_FALSE}
   otherwise.
 * _accumulating_saturating_mixed_signedness_accelerated_ is {CL_TRUE} when
   accumulating saturating mixed signedness dot product operations are
   accelerated, {CL_FALSE} otherwise.

A dot product operation is deemed accelerated if its implementation provides
a performance advantage over application-provided code composed from elementary
instructions and/or other dot product instructions, either because the
implementation uses optimized machine code sequences whose generation from
application-provided code cannot be guaranteed or because it uses hardware
features that cannot otherwise be targeted from application-provided code.
--
endif::cl_khr_integer_dot_product[]

ifdef::cl_khr_pci_bus_info[]
[open,refpage='cl_device_pci_bus_info_khr',desc='Structure describing PCI bus information',type='structs']
--
The {cl_device_pci_bus_info_khr_TYPE} structure describes PCI bus
information for a device:

include::{generated}/api/structs/cl_device_pci_bus_info_khr.txt[]

  * _pci_domain_ is the PCI bus domain of the device.
  * _pci_bus_ is the PCI bus identified of the device.
  * _pci_device_ is the PCI device identifier of the device.
  * _pci_function_ is the PCI device function identifier of the device.
--
endif::cl_khr_pci_bus_info[]

[open,refpage='clGetDeviceAndHostTimer',desc='Query synchronized host and device timestamps',type='protos']
--
To query device and host timestamps, call the function:

include::{generated}/api/protos/clGetDeviceAndHostTimer.txt[]
include::{generated}/api/version-notes/clGetDeviceAndHostTimer.asciidoc[]

  * _device_ is a device returned by {clGetDeviceIDs}.
  * _device_timestamp_ will be updated with the value of the device timer in
    nanoseconds.
    The resolution of the timer is the same as the device profiling timer
    returned by {clGetDeviceInfo} and the {CL_DEVICE_PROFILING_TIMER_RESOLUTION}
    query.
  * _host_timestamp_ will be updated with the value of the host timer in
    nanoseconds at the closest possible point in time to that at which
    _device_timer_ was returned.
    The resolution of the timer may be queried via {clGetPlatformInfo} and the
    flag {CL_PLATFORM_HOST_TIMER_RESOLUTION}.

{clGetDeviceAndHostTimer} returns a reasonably synchronized pair of
timestamps from the device timer and the host timer as seen by _device_.
Implementations may need to execute this query with a high latency in order
to provide reasonable synchronization of the timestamps.
The host timestamp and device timestamp returned by this function and
{clGetHostTimer} each have an implementation-defined timebase.
The timestamps will always be in their respective timebases regardless of
which query function is used.
The timestamp returned from {clGetEventProfilingInfo} for an event on a
device and a device timestamp queried from the same device will always be in
the same timebase.

// refError

{clGetDeviceAndHostTimer} will return {CL_SUCCESS} with a time value in
_host_timestamp_ if provided.
Otherwise, it returns one of the following errors:

  * {CL_INVALID_DEVICE} if _device_ is not a valid device.
  * {CL_INVALID_OPERATION} if the platform associated with _device_ does not
    support device and host timer synchronization.
  * {CL_INVALID_VALUE} if _host_timestamp_ or _device_timestamp_ is `NULL`.
  * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources required
    by the OpenCL implementation on the device.
  * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources
    required by the OpenCL implementation on the host.
--

[open,refpage='clGetHostTimer',desc='Query the host clock',type='protos']
--
To query the host clock, call the function:

include::{generated}/api/protos/clGetHostTimer.txt[]
include::{generated}/api/version-notes/clGetHostTimer.asciidoc[]

  * _device_ is a device returned by {clGetDeviceIDs}.
  * _host_timestamp_ will be updated with the value of the current timer in
    nanoseconds.
    The resolution of the timer may be queried via {clGetPlatformInfo} and the
    flag {CL_PLATFORM_HOST_TIMER_RESOLUTION}.

{clGetHostTimer} returns the current value of the host clock as seen by
_device_.
This value is in the same timebase as the _host_timestamp_ returned from
{clGetDeviceAndHostTimer}.
The implementation will return with as low a latency as possible to allow a
correlation with a subsequent application sampled time.
The host timestamp and device timestamp returned by this function and
{clGetDeviceAndHostTimer} each have an implementation-defined timebase.
The timestamps will always be in their respective timebases regardless of
which query function is used.
The timestamp returned from {clGetEventProfilingInfo} for an event on a
device and a device timestamp queried from the same device will always be in
the same timebase.

{clGetHostTimer} will return {CL_SUCCESS} with a time value in
_host_timestamp_ if provided.
Otherwise, it returns one of the following errors:

  * {CL_INVALID_DEVICE} if _device_ is not a valid device.
  * {CL_INVALID_OPERATION} if the platform associated with _device_ does not
    support device and host timer synchronization.
  * {CL_INVALID_VALUE} if _host_timestamp_ is `NULL`.
  * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources required
    by the OpenCL implementation on the device.
  * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources
    required by the OpenCL implementation on the host.
--


ifdef::cl_khr_dx9_media_sharing[]
=== Sharing DirectX9 Media Surfaces With OpenCL Images

This section discusses OpenCL functions that allow applications to use media
surfaces as OpenCL memory objects.
This allows efficient sharing of data between OpenCL and media surface APIs.
The OpenCL API may be used to execute kernels that read and/or write memory
objects that are also media surfaces.
An OpenCL image object may be created from a media surface.
OpenCL memory objects may be created from media surfaces if and only if the
OpenCL context has been created from a media adapter.


==== Querying OpenCL Devices Corresponding to Media Adapters

Media adapters are an abstraction associated with devices that provide media
capabilities.
Adapters with associated OpenCL devices can enable media surface sharing
between the two.


[open,refpage='clGetDeviceIDsFromDX9MediaAdapterKHR',desc='Query media adapter for any associated OpenCL devices',type='protos']
--
To query a media adapter for any associated OpenCL devices, call the
function

include::{generated}/api/protos/clGetDeviceIDsFromDX9MediaAdapterKHR.txt[]
include::{generated}/api/version-notes/clGetDeviceIDsFromDX9MediaAdapterKHR.asciidoc[]

  * _platform_ refers to the platform ID returned by {clGetPlatformIDs}.
  * _num_media_adapters_ specifies the number of media adapters.
  * _media_adapters_type_ is an array of _num_media_adapters_ entries.
    Each entry specifies the type of media adapter and must be one of the
    values described in the <<dx9-media-adapter-types, media adapter type
    table>> below.
  * _media_adapters_ is an array of _num_media_adapters_ entries.
    Each entry specifies the actual adapter whose type is specified by
    _media_adapter_type_.
    The _media_adapters_ must be one of the types described in the
    <<dx9-media-adapter-types, cl_dx9_media_adapter_type_khr values>>
    table.
  * _media_adapter_set_ specifies the set of adapters to return and must be
    one of the values described in the <<dx9-media-adapter-sets,
    cl_dx9_media_adapter_set_khr values>> table.
  * _num_entries_ is the number of {cl_device_id_TYPE} entries that can be
    added to _devices_.
    If _devices_ is not `NULL`, the _num_entries_ must be greater than zero.
  * _devices_ returns a list of OpenCL devices found that support the list
    of media adapters specified.
    The {cl_device_id_TYPE} values returned in _devices_ can be used to
    identify a specific OpenCL device.
    If _devices_ argument is `NULL`, this argument is ignored.
    The number of OpenCL devices returned is the minimum of the value
    specified by _num_entries_ or the number of OpenCL devices whose type
    matches _device_type_.
  * _num_devices_ returns the number of OpenCL devices.
    If _num_devices_ is `NULL`, this argument is ignored.

[[dx9-media-adapter-types]]
.DirectX 9 object types that may be used by {clGetDeviceIDsFromDX9MediaAdapterKHR}
[cols=",",options="header",]
|====
| {cl_dx9_media_adapter_type_khr_TYPE} | Type of Media Adapter
| {CL_ADAPTER_D3D9_KHR_anchor}

include::{generated}/api/version-notes/CL_ADAPTER_D3D9_KHR.asciidoc[]
  | `IDirect3DDevice9 *`
| {CL_ADAPTER_D3D9EX_KHR_anchor}

include::{generated}/api/version-notes/CL_ADAPTER_D3D9EX_KHR.asciidoc[]
  | `IDirect3DDevice9Ex *`
| {CL_ADAPTER_DXVA_KHR_anchor}

include::{generated}/api/version-notes/CL_ADAPTER_DXVA_KHR.asciidoc[]
  | `IDXVAHD_Device *`
|====

[[dx9-media-adapter-sets]]
.Sets of devices queriable using {clGetDeviceIDsFromDX9MediaAdapterKHR}
[cols=",",options="header",]
|====
| {cl_dx9_media_adapter_set_khr_TYPE} | Description
| {CL_PREFERRED_DEVICES_FOR_DX9_MEDIA_ADAPTER_KHR_anchor}

include::{generated}/api/version-notes/CL_PREFERRED_DEVICES_FOR_DX9_MEDIA_ADAPTER_KHR.asciidoc[]
    | The preferred OpenCL devices associated with the media adapter.
| {CL_ALL_DEVICES_FOR_DX9_MEDIA_ADAPTER_KHR_anchor}

include::{generated}/api/version-notes/CL_ALL_DEVICES_FOR_DX9_MEDIA_ADAPTER_KHR.asciidoc[]
    | All OpenCL devices that may interoperate with the media adapter
|====

// refError

{clGetDeviceIDsFromDX9MediaAdapterKHR} returns {CL_SUCCESS} if the function
is executed successfully.
Otherwise, it returns one of the following errors:

  * {CL_INVALID_PLATFORM} if _platform_ is not a valid platform.
  * {CL_INVALID_VALUE} if _num_media_adapters_ is zero or if
    _media_adapters_type_ is `NULL` or if _media_adapters_ is `NULL`.
  * {CL_INVALID_VALUE} if any of the entries in _media_adapters_type_ or
    _media_adapters_ is not a valid value.
  * {CL_INVALID_VALUE} if _media_adapter_set_ is not a valid value.
  * {CL_INVALID_VALUE} if _num_entries_ is equal to zero and _devices_ is
    not `NULL` or if both _num_devices_ and _devices_ are `NULL`.
  * {CL_DEVICE_NOT_FOUND} if no OpenCL devices that correspond to adapters
    specified in _media_adapters_ and _media_adapters_type_ were found.
  * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources
    required by the OpenCL implementation on the device.
  * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources
    required by the OpenCL implementation on the host.
--
endif::cl_khr_dx9_media_sharing[]


ifdef::cl_khr_d3d10_sharing[]
=== Sharing Direct3D 10 Resources With OpenCL Memory Objects

This section discusses OpenCL functions that allow applications to use
Direct3D 10 resources as OpenCL memory objects.
This allows efficient sharing of data between OpenCL and Direct3D 10.
The OpenCL API may be used to execute kernels that read and/or write memory
objects that are also Direct3D 10 resources.
An OpenCL image object may be created from a Direct3D 10 texture resource.
An OpenCL buffer object may be created from a Direct3D 10 buffer resource.
OpenCL memory objects may be created from Direct3D 10 objects if and only if
the OpenCL context has been created from a Direct3D 10 device.

==== Querying OpenCL Devices Corresponding to Direct3D 10 Devices

The OpenCL devices corresponding to a Direct3D 10 device may be queried.
The OpenCL devices corresponding to a DXGI adapter may also be queried.
The OpenCL devices corresponding to a Direct3D 10 device will be a subset of
the OpenCL devices corresponding to the DXGI adapter against which the
Direct3D 10 device was created.

[open,refpage='clGetDeviceIDsFromD3D10KHR',desc='Query OpenCL devices corresponding to a Direct3D 10 or DXGI device',type='protos']
--
To query OpenCL devices corresponding to a Direct3D 10 device or a DXGI
device, call the function

include::{generated}/api/protos/clGetDeviceIDsFromD3D10KHR.txt[]
include::{generated}/api/version-notes/clGetDeviceIDsFromD3D10KHR.asciidoc[]

  * _platform_ refers to the platform ID returned by {clGetPlatformIDs}.
  * _d3d_device_source_ specifies the type of _d3d_object_, and must be one
    of the values shown in the <<d3d10-device-object-types-table, Direct3D
    10 object types that may be used by {clGetDeviceIDsFromD3D10KHR}>>
    table.
  * _d3d_object_ specifies the object whose corresponding OpenCL devices are
    being queried.
    The type of _d3d_object_ must be as specified in the
    <<d3d10-device-object-types-table, Direct3D 10 object types that may be
    used by {clGetDeviceIDsFromD3D10KHR}>> table.
  * _d3d_device_set_ specifies the set of devices to return, and must be one
    of the values shown in the <<d3d10-device-sets-table, Sets of devices
    queriable using {clGetDeviceIDsFromD3D10KHR}>> table.
  * _num_entries_ is the number of {cl_device_id_TYPE} entries that can be
    added to _devices_.
    If _devices_ is not `NULL` then _num_entries_ must be greater than zero.
  * _devices_ returns a list of OpenCL devices found.
    The {cl_device_id_TYPE} values returned in _devices_ can be used to
    identify a specific OpenCL device.
    If _devices_ is `NULL`, this argument is ignored.
    The number of OpenCL devices returned is the minimum of the value
    specified by _num_entries_ and the number of OpenCL devices
    corresponding to _d3d_object_.
  * _num_devices_ returns the number of OpenCL devices available that
    correspond to _d3d_object_.
    If _num_devices_ is `NULL`, this argument is ignored.

[[d3d10-device-object-types-table]]
.Direct3D 10 object types that may be used by {clGetDeviceIDsFromD3D10KHR}
[cols=",",options="header",]
|====
| {cl_d3d10_device_source_khr_TYPE} | Type of _d3d_object_
| {CL_D3D10_DEVICE_KHR_anchor}

include::{generated}/api/version-notes/CL_D3D10_DEVICE_KHR.asciidoc[]
  | `ID3D10Device *`
| {CL_D3D10_DXGI_ADAPTER_KHR_anchor}

include::{generated}/api/version-notes/CL_D3D10_DXGI_ADAPTER_KHR.asciidoc[]
  | `IDXGIAdapter *`
|====

[[d3d10-device-sets-table]]
.Sets of devices queriable using {clGetDeviceIDsFromD3D10KHR}
[cols=",",options="header",]
|====
| {cl_d3d10_device_set_khr_TYPE} | Devices returned in _devices_
| {CL_PREFERRED_DEVICES_FOR_D3D10_KHR_anchor}

include::{generated}/api/version-notes/CL_PREFERRED_DEVICES_FOR_D3D10_KHR.asciidoc[]
  | The preferred OpenCL devices associated with the specified Direct3D
    object.
| {CL_ALL_DEVICES_FOR_D3D10_KHR_anchor}

include::{generated}/api/version-notes/CL_ALL_DEVICES_FOR_D3D10_KHR.asciidoc[]
  | All OpenCL devices which may interoperate with the specified Direct3D
    object.
    Performance of sharing data on these devices may be considerably less
    than on the preferred devices.
|====

// refError

{clGetDeviceIDsFromD3D10KHR} returns {CL_SUCCESS} if the function is
executed successfully.
Otherwise it may return

  * {CL_INVALID_PLATFORM} if _platform_ is not a valid platform.
  * {CL_INVALID_VALUE} if _d3d_device_source_ is not a valid value,
    _d3d_device_set_ is not a valid value, _num_entries_ is equal to zero
    and _devices_ is not `NULL`, or if both _num_devices_ and _devices_ are
    `NULL`.
  * {CL_DEVICE_NOT_FOUND} if no OpenCL devices that correspond to
    _d3d_object_ were found.
--
endif::cl_khr_d3d10_sharing[]


ifdef::cl_khr_d3d11_sharing[]
=== Sharing Direct3D 11 Resources With OpenCL Memory Objects

This section discusses OpenCL functions that allow applications to use
Direct3D 11 resources as OpenCL memory objects.
This allows efficient sharing of data between OpenCL and Direct3D 11.
The OpenCL API may be used to execute kernels that read and/or write memory
objects that are also Direct3D 11 resources.
An OpenCL image object may be created from a Direct3D 11 texture resource.
An OpenCL buffer object may be created from a Direct3D 11 buffer resource.
OpenCL memory objects may be created from Direct3D 11 objects if and only if
the OpenCL context has been created from a Direct3D 11 device.

==== Querying OpenCL Devices Corresponding to Direct3D 11 Devices

The OpenCL devices corresponding to a Direct3D 11 device may be queried.
The OpenCL devices corresponding to a DXGI adapter may also be queried.
The OpenCL devices corresponding to a Direct3D 11 device will be a subset of
the OpenCL devices corresponding to the DXGI adapter against which the
Direct3D 11 device was created.

[open,refpage='clGetDeviceIDsFromD3D11KHR',desc='Query OpenCL devices corresponding to a Direct3D 11 or DXGI device',type='protos']
--
To query OpenCL devices corresponding to a Direct3D 11 device or a DXGI
device, call the function

include::{generated}/api/protos/clGetDeviceIDsFromD3D11KHR.txt[]
include::{generated}/api/version-notes/clGetDeviceIDsFromD3D11KHR.asciidoc[]

  * _platform_ refers to the platform ID returned by {clGetPlatformIDs}.
  * _d3d_device_source_ specifies the type of _d3d_object_, and must be one
    of the values shown in the <<d3d11-device-object-types-table, Direct3D
    11 object types that may be used by {clGetDeviceIDsFromD3D11KHR}>>
    table.
  * _d3d_object_ specifies the object whose corresponding OpenCL devices are
    being queried.
    The type of _d3d_object_ must be as specified in the
    <<d3d11-device-object-types-table, Direct3D 11 object types that may be
    used by {clGetDeviceIDsFromD3D11KHR}>> table.
  * _d3d_device_set_ specifies the set of devices to return, and must be one
    of the values shown in the <<d3d11-device-sets-table, Sets of devices
    queriable using {clGetDeviceIDsFromD3D11KHR}>> table.
  * _num_entries_ is the number of {cl_device_id_TYPE} entries that can be
    added to _devices_.
    If _devices_ is not `NULL` then _num_entries_ must be greater than zero.
  * _devices_ returns a list of OpenCL devices found.
    The {cl_device_id_TYPE} values returned in _devices_ can be used to
    identify a specific OpenCL device.
    If _devices_ is `NULL`, this argument is ignored.
    The number of OpenCL devices returned is the minimum of the value
    specified by _num_entries_ and the number of OpenCL devices
    corresponding to _d3d_object_.
  * _num_devices_ returns the number of OpenCL devices available that
    correspond to _d3d_object_.
    If _num_devices_ is `NULL`, this argument is ignored.

[[d3d11-device-object-types-table]]
.Direct3D 11 object types that may be used by {clGetDeviceIDsFromD3D11KHR}
[cols=",",options="header",]
|====
| {cl_d3d11_device_source_khr_TYPE} | Type of _d3d_object_
| {CL_D3D11_DEVICE_KHR_anchor}

include::{generated}/api/version-notes/CL_D3D11_DEVICE_KHR.asciidoc[]
  | `ID3D11Device *`
| {CL_D3D11_DXGI_ADAPTER_KHR_anchor}

include::{generated}/api/version-notes/CL_D3D11_DXGI_ADAPTER_KHR.asciidoc[]
  | `IDXGIAdapter *`
|====

[[d3d11-device-sets-table]]
.Sets of devices queriable using {clGetDeviceIDsFromD3D11KHR}
[cols=",",options="header",]
|====
| {cl_d3d11_device_set_khr_TYPE} | Devices returned in _devices_
| {CL_PREFERRED_DEVICES_FOR_D3D11_KHR_anchor}

include::{generated}/api/version-notes/CL_PREFERRED_DEVICES_FOR_D3D11_KHR.asciidoc[]
  | The preferred OpenCL devices associated with the specified Direct3D
    object.
| {CL_ALL_DEVICES_FOR_D3D11_KHR_anchor}

include::{generated}/api/version-notes/CL_ALL_DEVICES_FOR_D3D11_KHR.asciidoc[]
  | All OpenCL devices which may interoperate with the specified Direct3D
    object.
    Performance of sharing data on these devices may be considerably less
    than on the preferred devices.
|====

// refError

{clGetDeviceIDsFromD3D11KHR} returns {CL_SUCCESS} if the function is
executed successfully.
Otherwise it may return

  * {CL_INVALID_PLATFORM} if _platform_ is not a valid platform.
  * {CL_INVALID_VALUE} if _d3d_device_source_ is not a valid value,
    _d3d_device_set_ is not a valid value, _num_entries_ is equal to zero
    and _devices_ is not `NULL`, or if both _num_devices_ and _devices_ are
    `NULL`.
  * {CL_DEVICE_NOT_FOUND} if no OpenCL devices that correspond to
    _d3d_object_ were found.
--
endif::cl_khr_d3d11_sharing[]


== Partitioning a Device

NOTE: Partitioning devices is <<unified-spec, missing before>> version 1.2.

[open,refpage='clCreateSubDevices',desc='Create sub-devices partitioning an OpenCL device',type='protos']
--
To create sub-devices partitioning an OpenCL device, call the function:

include::{generated}/api/protos/clCreateSubDevices.txt[]
include::{generated}/api/version-notes/clCreateSubDevices.asciidoc[]

  * _in_device_ is the device to be partitioned.
  * _properties_ specifies how _in_device_ is to be partitioned, described by a
    partition name and its corresponding value.
    Each partition name is immediately followed by the corresponding desired
    value.
    The list is terminated with 0.
    The list of supported partitioning schemes is described in the
    <<sub-device-partition-table, Sub-device Partition>> table.
    Only one of the listed partitioning schemes can be specified in
    _properties_.
  * _num_devices_ is the size of memory pointed to by _out_devices_ specified as
    the number of {cl_device_id_TYPE} entries.
  * _out_devices_ is the buffer where the OpenCL sub-devices will be returned.
    If _out_devices_ is `NULL`, this argument is ignored.
    If _out_devices_ is not `NULL`, _num_devices_ must be greater than or equal
    to the number of sub-devices that _device_ may be partitioned into according
    to the partitioning scheme specified in _properties_.
  * _num_devices_ret_ returns the number of sub-devices that _device_ may be
    partitioned into according to the partitioning scheme specified in
    _properties_.
    If _num_devices_ret_ is `NULL`, it is ignored.

{clCreateSubDevices} creates an array of sub-devices that each reference a
non-intersecting set of compute units within _in_device_, according to the
partition scheme given by _properties_.
The output sub-devices may be used in every way that the root (or parent)
device can be used, including creating contexts, building programs, further
calls to {clCreateSubDevices} and creating command-queues.
When a command-queue is created against a sub-device, the commands enqueued
on the queue are executed only on the sub-device.

[[sub-device-partition-table]]
.List of supported partition schemes by {clCreateSubDevices}
[width="100%",cols="<33%,<17%,<50%",options="header"]
|====
| Partition Property | Partition Value | Description
| {CL_DEVICE_PARTITION_EQUALLY_anchor}

include::{generated}/api/version-notes/CL_DEVICE_PARTITION_EQUALLY.asciidoc[]
  | {cl_uint_TYPE}
      | Split the aggregate device into as many smaller aggregate devices as
        can be created, each containing _n_ compute units.
        The value _n_ is passed as the value accompanying this property.
        If _n_ does not divide evenly into
        {CL_DEVICE_MAX_COMPUTE_UNITS}, then the remaining compute
        units are not used.
| {CL_DEVICE_PARTITION_BY_COUNTS_anchor}

include::{generated}/api/version-notes/CL_DEVICE_PARTITION_BY_COUNTS.asciidoc[]
  | {cl_uint_TYPE}
      | This property is followed by a list of compute unit counts
        terminated with 0 or {CL_DEVICE_PARTITION_BY_COUNTS_LIST_END_anchor}.
        For each non-zero count _m_ in the list, a sub-device is created
        with _m_ compute units in it.

        The number of non-zero count entries in the list may not exceed
        {CL_DEVICE_PARTITION_MAX_SUB_DEVICES}.

        The total number of compute units specified may not exceed
        {CL_DEVICE_MAX_COMPUTE_UNITS}.
| {CL_DEVICE_PARTITION_BY_AFFINITY_DOMAIN_anchor}

include::{generated}/api/version-notes/CL_DEVICE_PARTITION_BY_AFFINITY_DOMAIN.asciidoc[]
  | {cl_device_affinity_domain_TYPE}
     | Split the device into smaller aggregate devices containing one or
        more compute units that all share part of a cache hierarchy.
        The value accompanying this property may be drawn from the following
        list:

        {CL_DEVICE_AFFINITY_DOMAIN_NUMA} - Split the device into sub-devices
        comprised of compute units that share a NUMA node.

        {CL_DEVICE_AFFINITY_DOMAIN_L4_CACHE} - Split the device into
        sub-devices comprised of compute units that share a level 4 data
        cache.

        {CL_DEVICE_AFFINITY_DOMAIN_L3_CACHE} - Split the device into
        sub-devices comprised of compute units that share a level 3 data
        cache.

        {CL_DEVICE_AFFINITY_DOMAIN_L2_CACHE} - Split the device into
        sub-devices comprised of compute units that share a level 2 data
        cache.

        {CL_DEVICE_AFFINITY_DOMAIN_L1_CACHE} - Split the device into
        sub-devices comprised of compute units that share a level 1 data
        cache.

        {CL_DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE} - Split the device
        along the next partitionable affinity domain.
        The implementation shall find the first level along which the device
        or sub-device may be further subdivided in the order NUMA, L4, L3,
        L2, L1, and partition the device into sub-devices comprised of
        compute units that share memory subsystems at this level.

        The user may determine what happened by calling
        {clGetDeviceInfo}({CL_DEVICE_PARTITION_TYPE}) on the sub-devices.
|====

// refError

{clCreateSubDevices} returns {CL_SUCCESS} if the partition is created
successfully.
Otherwise, it returns a `NULL` value with the following error values
returned in _errcode_ret_:

  * {CL_INVALID_DEVICE} if _in_device_ is not a valid device.
  * {CL_INVALID_VALUE} if values specified in _properties_ are not valid or if
    values specified in _properties_ are valid but not supported by the
    device.
  * {CL_INVALID_VALUE} if _out_devices_ is not `NULL` and _num_devices_ is
    less than the number of sub-devices created by the partition scheme.
  * {CL_DEVICE_PARTITION_FAILED} if the partition name is supported by the
    implementation but in_device could not be further partitioned.
  * {CL_INVALID_DEVICE_PARTITION_COUNT} if the partition name specified in
    _properties_ is {CL_DEVICE_PARTITION_BY_COUNTS} and the number of
    sub-devices requested exceeds {CL_DEVICE_PARTITION_MAX_SUB_DEVICES} or the
    total number of compute units requested exceeds
    {CL_DEVICE_MAX_COMPUTE_UNITS} for _in_device_, or the number of
    compute units requested for one or more sub-devices is less than zero or
    the number of sub-devices requested exceeds
    {CL_DEVICE_MAX_COMPUTE_UNITS} for _in_device_.
  * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources required
    by the OpenCL implementation on the device.
  * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources
    required by the OpenCL implementation on the host.

A few examples that describe how to specify partition properties in
_properties_ argument to {clCreateSubDevices} are given below:

To partition a device containing 16 compute units into two sub-devices, each
containing 8 compute units, pass the following in _properties_:

[source,opencl]
----
{ CL_DEVICE_PARTITION_EQUALLY, 8,
  0 } // 0 terminates the property list
----

To partition a device with four compute units into two sub-devices with one
sub-device containing 3 compute units and the other sub-device 1 compute
unit, pass the following in properties argument:

[source,opencl]
----
{ CL_DEVICE_PARTITION_BY_COUNTS,
    3, 1, CL_DEVICE_PARTITION_BY_COUNTS_LIST_END,
  0 } // 0 terminates the property list
----

To split a device along the outermost cache line (if any), pass the
following in properties argument:

[source,opencl]
----
{ CL_DEVICE_PARTITION_BY_AFFINITY_DOMAIN,
    CL_DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE,
  0 } // 0 terminates the property list
----
--

[open,refpage='clRetainDevice',desc='Retain an OpenCL device',type='protos',xrefs='clReleaseDevice']
--
To retain a device, call the function:

include::{generated}/api/protos/clRetainDevice.txt[]
include::{generated}/api/version-notes/clRetainDevice.asciidoc[]

  * _device_ is the OpenCL device to retain.

{clRetainDevice} increments the _device_ reference count if _device_ is a
valid sub-device created by a call to {clCreateSubDevices}.
If _device_ is a root level device i.e. a {cl_device_id_TYPE} returned by
{clGetDeviceIDs}, the _device_ reference count remains unchanged.

// refError

{clRetainDevice} returns {CL_SUCCESS} if the function is executed successfully
or the device is a root-level device.
Otherwise, it returns one of the following errors:

  * {CL_INVALID_DEVICE} if _device_ is not a valid device.
  * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources required
    by the OpenCL implementation on the device.
  * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources
    required by the OpenCL implementation on the host.
--

[open,refpage='clReleaseDevice',desc='Release an OpenCL device',type='protos',xrefs='clRetainDevice']
--
To release a device, call the function:

include::{generated}/api/protos/clReleaseDevice.txt[]
include::{generated}/api/version-notes/clReleaseDevice.asciidoc[]

  * _device_ is the OpenCL device to release.

{clReleaseDevice} decrements the _device_ reference count if device is a
valid sub-device created by a call to {clCreateSubDevices}.
If _device_ is a root level device i.e. a {cl_device_id_TYPE} returned by
{clGetDeviceIDs}, the _device_ reference count remains unchanged.

// refError

{clReleaseDevice} returns {CL_SUCCESS} if the function is executed
successfully.
Otherwise, it returns one of the following errors:

  * {CL_INVALID_DEVICE} if _device_ is not a valid device.
  * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources required
    by the OpenCL implementation on the device.
  * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources
    required by the OpenCL implementation on the host.

After the _device_ reference count becomes zero and all the objects attached
to _device_ (such as command-queues) are released, the _device_ object is
deleted.
Using this function to release a reference that was not obtained by creating
the object or by calling {clRetainDevice} causes undefined behavior.
--


== Contexts

[open,refpage='clCreateContext',desc='Create an OpenCL context',type='protos']
--
To create an OpenCL context, call the function:

include::{generated}/api/protos/clCreateContext.txt[]
include::{generated}/api/version-notes/clCreateContext.asciidoc[]

  * _properties_ specifies a list of context property names and their
    corresponding values.
    Each property name is immediately followed by the corresponding desired
    value.
    The list is terminated with 0.
    The list of supported properties, and their default values if not
    present in _properties_, is described in the <<context-properties-table,
    Context Properties>> table.
    _properties_ can be `NULL`, in which case all properties take on their
    default values.
  * _num_devices_ is the number of devices specified in the _devices_ argument.
  * _devices_ is a pointer to a list of unique devices returned by
    {clGetDeviceIDs} or sub-devices created by {clCreateSubDevices} for a
    platform. footnote:[{fn-duplicate-devices}]
  * _pfn_notify_ is a callback function that can be registered by the
    application.
    This callback function will be used by the OpenCL implementation to report
    information on errors during context creation as well as errors that occur
    at runtime in this context.
    This callback function may be called asynchronously by the OpenCL
    implementation.
    It is the application's responsibility to ensure that the callback function
    is thread-safe.
    If _pfn_notify_ is `NULL`, no callback function is registered.
  * _user_data_ will be passed as the _user_data_ argument when _pfn_notify_ is
    called.
    _user_data_ can be `NULL`.
  * _errcode_ret_ will return an appropriate error code.
    If _errcode_ret_ is `NULL`, no error code is returned.

The parameters to the callback function _pfn_notify_ are:

  * _errinfo_ is a pointer to an error string.
  * _private_info_ and _cb_ represent a pointer to binary data that is
    returned by the OpenCL implementation that can be used to log additional
    information helpful in debugging the error.
  * _user_data_ is a pointer to user supplied data.

Contexts are used by the OpenCL runtime for managing objects such as
command-queues, memory, program and kernel objects and for executing kernels
on one or more devices specified in the context.

[[context-properties-table]]
.List of supported context creation properties by {clCreateContext}
[width="100%",cols="<33%,<17%,<50%",options="header"]
|====
| Context Property | Property Value | Description
| {CL_CONTEXT_PLATFORM_anchor}

include::{generated}/api/version-notes/CL_CONTEXT_PLATFORM.asciidoc[]
  | {cl_platform_id_TYPE}
      | Specifies the platform to use.

        Defaults to an implementation-defined platform if not specified.
| {CL_CONTEXT_INTEROP_USER_SYNC_anchor}

include::{generated}/api/version-notes/CL_CONTEXT_INTEROP_USER_SYNC.asciidoc[]
  | {cl_bool_TYPE}
      | Specifies whether the user is responsible for synchronization
        between OpenCL and other APIs.
        Please refer to the specific sections in the OpenCL Extension
        Specification that describe sharing with other APIs for restrictions
        on using this flag.

        Defaults to {CL_FALSE} if not specified.

ifdef::cl_khr_dx9_media_sharing[]
| {CL_CONTEXT_ADAPTER_D3D9_KHR_anchor}

include::{generated}/api/version-notes/CL_CONTEXT_ADAPTER_D3D9_KHR.asciidoc[]
  | `IDirect3DDevice9 *`
    | Specifies an `IDirect3DDevice9` to use for D3D9 interop.
| {CL_CONTEXT_ADAPTER_D3D9EX_KHR_anchor}

include::{generated}/api/version-notes/CL_CONTEXT_ADAPTER_D3D9EX_KHR.asciidoc[]
  | `IDirect3DDeviceEx*`
    | Specifies an `IDirect3DDevice9Ex` to use for D3D9 interop.
| {CL_CONTEXT_ADAPTER_DXVA_KHR_anchor}

include::{generated}/api/version-notes/CL_CONTEXT_ADAPTER_DXVA_KHR.asciidoc[]
  | `IDXVAHD_Device *`
    | Specifies an `IDXVAHD_Device` to use for DXVA interop.
endif::cl_khr_dx9_media_sharing[]

ifdef::cl_khr_d3d10_sharing[]
| {CL_CONTEXT_D3D10_DEVICE_KHR_anchor}

include::{generated}/api/version-notes/CL_CONTEXT_D3D10_DEVICE_KHR.asciidoc[]
  | `ID3D10Device *`
    | Specifies the `ID3D10Device *` to use for Direct3D 10 interoperability.

      The default value is `NULL`.
endif::cl_khr_d3d10_sharing[]

ifdef::cl_khr_d3d11_sharing[]
| {CL_CONTEXT_D3D11_DEVICE_KHR_anchor}

include::{generated}/api/version-notes/CL_CONTEXT_D3D11_DEVICE_KHR.asciidoc[]
  | `ID3D11Device *`
    | Specifies the `ID3D11Device *` to use for Direct3D 11 interoperability.

      The default value is `NULL`.
endif::cl_khr_d3d11_sharing[]

ifdef::cl_khr_gl_sharing[]
| {CL_GL_CONTEXT_KHR_anchor}

include::{generated}/api/version-notes/CL_GL_CONTEXT_KHR.asciidoc[]
  | OpenGL context handle
    | OpenGL context to associate the OpenCL context with

      Defaults to 0 if not specified.
| {CL_CGL_SHAREGROUP_KHR_anchor}

include::{generated}/api/version-notes/CL_CGL_SHAREGROUP_KHR.asciidoc[]
  | CGL share group handle
    | CGL share group to associate the OpenCL context with

      Defaults to 0 if not specified.
| {CL_EGL_DISPLAY_KHR_anchor}

include::{generated}/api/version-notes/CL_EGL_DISPLAY_KHR.asciidoc[]
  | EGL `EGLDisplay` handle
    | `EGLDisplay` an OpenGL context was created with respect to

      Defaults to `EGL_NO_DISPLAY` if not specified.
| {CL_GLX_DISPLAY_KHR_anchor}

include::{generated}/api/version-notes/CL_GLX_DISPLAY_KHR.asciidoc[]
  | X handle
    | X Display an OpenGL context was created with respect to

      Defaults to `None` if not specified.
| {CL_WGL_HDC_KHR_anchor}

include::{generated}/api/version-notes/CL_WGL_HDC_KHR.asciidoc[]
  | Windows HDC handle
    | HDC an OpenGL context was created with respect to

      Defaults to 0 if not specified.
endif::cl_khr_gl_sharing[]

ifdef::cl_khr_initialize_memory[]
| {CL_CONTEXT_MEMORY_INITIALIZE_KHR_anchor}

include::{generated}/api/version-notes/CL_CONTEXT_MEMORY_INITIALIZE_KHR.asciidoc[]
  | {cl_context_memory_initialize_khr_TYPE}
    | Describes which memory types for the context must be initialized.
      This is a bit-field, where the following values are currently
      supported:

      {CL_CONTEXT_MEMORY_INITIALIZE_LOCAL_KHR_anchor} -- Initialize local
      memory to zeros.

      {CL_CONTEXT_MEMORY_INITIALIZE_PRIVATE_KHR_anchor} -- Initialize
      private memory to zeros.
endif::cl_khr_initialize_memory[]

ifdef::cl_khr_terminate_context[]
| {CL_CONTEXT_TERMINATE_KHR_anchor}

include::{generated}/api/version-notes/CL_CONTEXT_TERMINATE_KHR.asciidoc[]
  | {cl_bool_TYPE}
    | Specifies whether the context can be terminated.
      The default value is {CL_FALSE}.
endif::cl_khr_terminate_context[]
|====

ifdef::cl_khr_gl_sharing[]
Some of the properties specified in the <<context-properties-table, Context
Properties>> table control sharing of OpenCL memory objects with OpenGL
buffer, texture, and renderbuffer objects.

[[specifying-gl-context]]
Depending on the platform-specific API used to bind OpenGL contexts to the
window system, the following properties may be set to identify an OpenGL
context:

  * When the CGL binding API is supported, the property
    {CL_CGL_SHAREGROUP_KHR} should be set to a CGLShareGroup handle to a CGL
    share group object.
  * When the EGL binding API is supported, the property {CL_GL_CONTEXT_KHR}
    should be set to an EGLContext handle to an OpenGL ES or OpenGL context,
    and the property {CL_EGL_DISPLAY_KHR} should be set to the `EGLDisplay`
    handle of the display used to create the OpenGL ES or OpenGL context.
  * When the GLX binding API is supported, the property {CL_GL_CONTEXT_KHR}
    should be set to a GLXContext handle to an OpenGL context, and the
    property {CL_GLX_DISPLAY_KHR} should be set to the `Display` handle of
    the X Window System display used to create the OpenGL context.
  * When the WGL binding API is supported, the property {CL_GL_CONTEXT_KHR}
    should be set to an HGLRC handle to an OpenGL context, and the property
    {CL_WGL_HDC_KHR} should be set to the HDC handle of the display used to
    create the OpenGL context.

Memory objects created in the context so specified may be shared with the
specified OpenGL or OpenGL ES context (as well as with any other OpenGL
contexts on the share list of that context, according to the description of
sharing in the GLX 1.4 and EGL 1.5 specifications, and the WGL documentation
for OpenGL implementations on Microsoft Windows), or with the explicitly
identified OpenGL share group for CGL.
If no OpenGL or OpenGL ES context or share group is specified in the
property list, then memory objects may not be shared, and attempts to create
such objects will result in a {CL_INVALID_GL_SHAREGROUP_REFERENCE_KHR}
error.

OpenCL / OpenGL sharing does not support the {CL_CONTEXT_INTEROP_USER_SYNC}
property defined in the <<context-properties-table, Context Properties>>
table.
Specifying this property when creating a context with OpenCL / OpenGL
sharing will return an appropriate error.
endif::cl_khr_gl_sharing[]

NOTE: There are a number of cases where error notifications need to be
delivered due to an error that occurs outside a context.
Such notifications may not be delivered through the _pfn_notify_ callback.
Where these notifications go is implementation-defined.

// refError

{clCreateContext} returns a valid non-zero context and _errcode_ret_ is set
to {CL_SUCCESS} if the context is created successfully.
Otherwise, it returns a `NULL` value with the following error values
returned in _errcode_ret_:

  * {CL_INVALID_PLATFORM} if no platform is specified in _properties_ and no
    platform could be selected, or if the platform specified in _properties_ is
    not a valid platform.
  * {CL_INVALID_PROPERTY} if a context property name in _properties_ is not a
    supported property name, if the value specified for a supported property
    name is not valid, or if the same property name is specified more than
    once.
    This error code is <<unified-spec, missing before>> version 1.1.
  * {CL_INVALID_VALUE} if _devices_ is `NULL`.
  * {CL_INVALID_VALUE} if _num_devices_ is equal to zero.
  * {CL_INVALID_VALUE} if _pfn_notify_ is `NULL` but _user_data_ is not
    `NULL`.
  * {CL_INVALID_DEVICE} if any device in _devices_ is not a valid device.
  * {CL_DEVICE_NOT_AVAILABLE} if a device in _devices_ is currently not
    available even though the device was returned by {clGetDeviceIDs}.
  * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources required
    by the OpenCL implementation on the device.
  * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources
    required by the OpenCL implementation on the host.

ifdef::cl_khr_dx9_media_sharing[]
The following errors may be returned if the `<<cl_khr_dx9_media_sharing>>`
extension is supported:

  * {CL_INVALID_DX9_MEDIA_ADAPTER_KHR} if any of the values of the
    properties {CL_CONTEXT_ADAPTER_D3D9_KHR},
    {CL_CONTEXT_ADAPTER_D3D9EX_KHR} or {CL_CONTEXT_ADAPTER_DXVA_KHR} is
    non-`NULL` and does not specify a valid media adapter with which the
    _cl_device_ids_ against which this context is to be created may
    interoperate.
endif::cl_khr_dx9_media_sharing[]

ifdef::cl_khr_d3d10_sharing[]
The following errors may be returned if the `<<cl_khr_d3d10_sharing>>`
extension is supported:

  * {CL_INVALID_D3D10_DEVICE_KHR} if the value of the property
    {CL_CONTEXT_D3D10_DEVICE_KHR} is non-`NULL` and does not specify a valid
    Direct3D 10 device with which the _cl_device_ids_ against which this
    context is to be created may interoperate.
  * {CL_INVALID_OPERATION} if Direct3D 10 interoperability is specified by
    setting {CL_INVALID_D3D10_DEVICE_KHR} to a non-`NULL` value, and
    interoperability with another graphics API is also specified.
endif::cl_khr_d3d10_sharing[]

ifdef::cl_khr_d3d11_sharing[]
The following errors may be returned if the `<<cl_khr_d3d11_sharing>>`
extension is supported:

  * {CL_INVALID_D3D11_DEVICE_KHR} if the value of the property
    {CL_CONTEXT_D3D11_DEVICE_KHR} is non-`NULL` and does not specify a valid
    Direct3D 11 device with which the _cl_device_ids_ against which this
    context is to be created may interoperate.
  * {CL_INVALID_OPERATION} if Direct3D 11 interoperability is specified by
    setting {CL_INVALID_D3D11_DEVICE_KHR} to a non-`NULL` value, and
    interoperability with another graphics API is also specified.
endif::cl_khr_d3d11_sharing[]

ifdef::cl_khr_gl_sharing[]
The following errors may be returned if the `<<cl_khr_gl_sharing>>`
extension is supported:

  * {CL_INVALID_GL_SHAREGROUP_REFERENCE_KHR} if a context was specified for
    an OpenGL or OpenGL ES implementation using the EGL, GLX, or WGL binding
    APIs, as <<specifying-gl-context, described above>>; and any of the
    following conditions hold:
  ** The specified display and context properties do not identify a valid
     OpenGL or OpenGL ES context.
  ** The specified context does not support buffer and renderbuffer objects.
  ** The specified context is not compatible with the OpenCL context being
     created (for example, it exists in a physically distinct address space,
     such as another hardware device; or it does not support sharing data
     with OpenCL due to implementation restrictions).
  * {CL_INVALID_GL_SHAREGROUP_REFERENCE_KHR} if a share group was specified
    for a CGL-based OpenGL implementation by setting the property
    {CL_CGL_SHAREGROUP_KHR}, and the specified share group does not identify
    a valid CGL share group object.
  * {CL_INVALID_OPERATION} if a context was specified as described above and
    any of the following conditions hold:
  ** A context or share group object was specified for one of CGL, EGL, GLX,
     or WGL and the OpenGL implementation does not support that
     window-system binding API.
  ** More than one of the properties {CL_CGL_SHAREGROUP_KHR},
     {CL_EGL_DISPLAY_KHR}, {CL_GLX_DISPLAY_KHR}, and {CL_WGL_HDC_KHR} is set
     to a non-default value.
  ** Both of the properties {CL_CGL_SHAREGROUP_KHR} and {CL_GL_CONTEXT_KHR}
     are set to non-default values.
  ** Any of the devices specified in the _devices_ argument cannot support
     OpenCL objects which share the data store of an OpenGL object.
  * {CL_INVALID_PROPERTY} if both {CL_CONTEXT_INTEROP_USER_SYNC}, and any of
    the properties defined by the `<<cl_khr_gl_sharing>>` extension are
    defined in _properties_.
endif::cl_khr_gl_sharing[]

ifdef::cl_khr_terminate_context[]
The following errors may be returned if the `<<cl_khr_terminate_context>>`
extension is supported:

  * {CL_INVALID_PROPERTY} if the `<<cl_khr_terminate_context>>` extension is
    supported and {CL_CONTEXT_TERMINATE_KHR} is set to {CL_TRUE} in
    _properties_, but not all of the devices associated with the context
    support the ability to support context termination (i.e.
    {CL_DEVICE_TERMINATE_CAPABILITY_CONTEXT_KHR} is set for
    {CL_DEVICE_TERMINATE_CAPABILITY_KHR}).
endif::cl_khr_terminate_context[]

[NOTE]
====
It is possible that a device(s) becomes unavailable after a context and
command-queues that use this device(s) have been created and commands have
been queued to command-queues.
In this case the behavior of OpenCL API calls that use this context (and
command-queues) are considered to be implementation-defined.
The user callback function, if specified, when the context is created can be
used to record appropriate information in the _errinfo_, _private_info_
arguments passed to the callback function when the device becomes
unavailable.
====
--

[open,refpage='clCreateContextFromType',desc='Create an OpenCL context from a device type',type='protos']
--
To create an OpenCL context from a specific device
type footnote:[{fn-create-context-all-or-subset}], call the function:

include::{generated}/api/protos/clCreateContextFromType.txt[]
include::{generated}/api/version-notes/clCreateContextFromType.asciidoc[]

  * _properties_ specifies a list of context property names and their
    corresponding values.
    Each property name is immediately followed by the corresponding desired
    value.
    The list of supported properties, and their default values if not
    present in _properties_, is described in the <<context-properties-table,
    Context Properties>> table.
    _properties_ can be `NULL`, in which case all properties take on their
    default values.
  * _device_type_ is a bit-field that identifies the type of device and is
    described in the <<device-types-table, Device Types>> table.
  * _pfn_notify_ and _user_data_ are described in {clCreateContext}.
  * _errcode_ret_ will return an appropriate error code.
    If _errcode_ret_ is `NULL`, no error code is returned.

Only devices that are returned by {clGetDeviceIDs} for _device_type_ are
used to create the context.
The context does not reference any sub-devices that may have been created
from these devices.

// refError

{clCreateContextFromType} returns a valid non-zero context and _errcode_ret_
is set to {CL_SUCCESS} if the context is created successfully.
Otherwise, it returns a `NULL` value with the following error values
returned in _errcode_ret_:

  * {CL_INVALID_PLATFORM} if no platform is specified in _properties_ and no
    platform could be selected, or if the platform specified in _properties_ is
    not a valid platform.
  * {CL_INVALID_PROPERTY} if a context property name in _properties_ is not a
    supported property name, if the value specified for a supported property
    name is not valid, or if the same property name is specified more than
    once.
    This error code is <<unified-spec, missing before>> version 1.1.
  * {CL_INVALID_VALUE} if _pfn_notify_ is `NULL` but _user_data_ is not
    `NULL`.
  * {CL_INVALID_DEVICE_TYPE} if _device_type_ is not a valid value.
  * {CL_DEVICE_NOT_AVAILABLE} if no devices that match _device_type_ and
    property values specified in _properties_ are currently available.
  * {CL_DEVICE_NOT_FOUND} if no devices that match _device_type_ and property
    values specified in _properties_ were found.
  * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources required
    by the OpenCL implementation on the device.
  * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources
    required by the OpenCL implementation on the host.

ifdef::cl_khr_dx9_media_sharing[]
The following errors may be returned if the `<<cl_khr_dx9_media_sharing>>`
extension is supported:

  * {CL_INVALID_DX9_MEDIA_ADAPTER_KHR} if any of the values of the
    properties {CL_CONTEXT_ADAPTER_D3D9_KHR},
    {CL_CONTEXT_ADAPTER_D3D9EX_KHR} or {CL_CONTEXT_ADAPTER_DXVA_KHR} is
    non-`NULL` and does not specify a valid media adapter with which the
    _cl_device_ids_ against which this context is to be created may
    interoperate.
endif::cl_khr_dx9_media_sharing[]

ifdef::cl_khr_d3d10_sharing[]
The following errors may be returned if the `<<cl_khr_d3d10_sharing>>`
extension is supported:

  * {CL_INVALID_D3D10_DEVICE_KHR} if the value of the property
    {CL_CONTEXT_D3D10_DEVICE_KHR} is non-`NULL` and does not specify a valid
    Direct3D 10 device with which the _cl_device_ids_ against which this
    context is to be created may interoperate.
  * {CL_INVALID_OPERATION} if Direct3D 10 interoperability is specified by
    setting {CL_INVALID_D3D10_DEVICE_KHR} to a non-`NULL` value, and
    interoperability with another graphics API is also specified.
endif::cl_khr_d3d10_sharing[]

ifdef::cl_khr_d3d11_sharing[]
The following errors may be returned if the `<<cl_khr_d3d11_sharing>>`
extension is supported:

  * {CL_INVALID_D3D11_DEVICE_KHR} if the value of the property
    {CL_CONTEXT_D3D11_DEVICE_KHR} is non-`NULL` and does not specify a valid
    Direct3D 11 device with which the _cl_device_ids_ against which this
    context is to be created may interoperate.
  * {CL_INVALID_OPERATION} if Direct3D 11 interoperability is specified by
    setting {CL_INVALID_D3D11_DEVICE_KHR} to a non-`NULL` value, and
    interoperability with another graphics API is also specified.
endif::cl_khr_d3d11_sharing[]

ifdef::cl_khr_gl_sharing[]
The following errors may be returned if the `<<cl_khr_gl_sharing>>`
extension is supported:

  * {CL_INVALID_GL_SHAREGROUP_REFERENCE_KHR} if a context was specified for
    an OpenGL or OpenGL ES implementation using the EGL, GLX, or WGL binding
    APIs, as <<specifying-gl-context, described for `clCreateContext`>>; and
    any of the following conditions hold:
  ** The specified display and context properties do not identify a valid
     OpenGL or OpenGL ES context.
  ** The specified context does not support buffer and renderbuffer objects.
  ** The specified context is not compatible with the OpenCL context being
     created (for example, it exists in a physically distinct address space,
     such as another hardware device; or it does not support sharing data
     with OpenCL due to implementation restrictions).
  * {CL_INVALID_GL_SHAREGROUP_REFERENCE_KHR} if a share group was specified
    for a CGL-based OpenGL implementation by setting the property
    {CL_CGL_SHAREGROUP_KHR}, and the specified share group does not identify
    a valid CGL share group object.
  * {CL_INVALID_OPERATION} if a context was specified as described above and
    any of the following conditions hold:
  ** A context or share group object was specified for one of CGL, EGL, GLX,
     or WGL and the OpenGL implementation does not support that
     window-system binding API.
  ** More than one of the properties {CL_CGL_SHAREGROUP_KHR},
     {CL_EGL_DISPLAY_KHR}, {CL_GLX_DISPLAY_KHR}, and {CL_WGL_HDC_KHR} is set
     to a non-default value.
  ** Both of the properties {CL_CGL_SHAREGROUP_KHR} and {CL_GL_CONTEXT_KHR}
     are set to non-default values.
  ** Any of the devices specified in the _devices_ argument cannot support
     OpenCL objects which share the data store of an OpenGL object.
  * {CL_INVALID_PROPERTY} if both {CL_CONTEXT_INTEROP_USER_SYNC}, and any of
    the properties defined by the `<<cl_khr_gl_sharing>>` extension are
    defined in _properties_.
endif::cl_khr_gl_sharing[]

--

[open,refpage='clRetainContext',desc='Retain an OpenCL context',type='protos',xrefs='clCreateContext clReleaseContext']
--
To retain a context, call the function:

include::{generated}/api/protos/clRetainContext.txt[]
include::{generated}/api/version-notes/clRetainContext.asciidoc[]

  * _context_ specifies the OpenCL context to retain.

{clRetainContext} increments the _context_ reference count.

{clCreateContext} and {clCreateContextFromType} perform an implicit retain.
This is very helpful for 3^rd^ party libraries, which typically get a
context passed to them by the application.
However, it is possible that the application may delete the context without
informing the library.
Allowing functions to attach to (i.e. retain) and release a context solves
the problem of a context being used by a library no longer being valid.

// refError

{clRetainContext} returns {CL_SUCCESS} if the function is executed
successfully.
Otherwise, it returns one of the following errors:

  * {CL_INVALID_CONTEXT} if _context_ is not a valid OpenCL context.
  * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources required
    by the OpenCL implementation on the device.
  * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources
    required by the OpenCL implementation on the host.
--

[open,refpage='clReleaseContext',desc='Release an OpenCL context',type='protos',xrefs='clCreateContext clRetainContext']
--
To release a context, call the function:

include::{generated}/api/protos/clReleaseContext.txt[]
include::{generated}/api/version-notes/clReleaseContext.asciidoc[]

  * _context_ specifies the OpenCL context to release.

{clReleaseContext} decrements the _context_ reference count.
After the reference count becomes zero and all the objects attached to
_context_ (such as memory objects, command-queues) are released, the
_context_ is deleted.
Using this function to release a reference that was not obtained by creating
the object or by calling {clRetainContext} causes undefined behavior.

// refError

{clReleaseContext} returns {CL_SUCCESS} if the function is executed
successfully.
Otherwise, it returns one of the following errors:

  * {CL_INVALID_CONTEXT} if _context_ is not a valid OpenCL context.
  * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources required
    by the OpenCL implementation on the device.
  * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources
    required by the OpenCL implementation on the host.
--

ifdef::cl_khr_terminate_context[]
[open,refpage='clTerminateContextKHR',desc='Terminate pending work associated with a context and render data owned by the context invalid',type='protos']
--
To terminate all pending work associated with a context and render all data
owned by the context invalid, call the function

include::{generated}/api/protos/clTerminateContextKHR.txt[]
include::{generated}/api/version-notes/clTerminateContextKHR.asciidoc[]

  * _context_ must be a valid OpenCL context.

It is the responsibility of the application to release all objects
associated with the context being terminated.

When a context is terminated:

  * The execution status of enqueued commands will be
    {CL_CONTEXT_TERMINATED_KHR_anchor}.
    Event objects can be queried using {clGetEventInfo}.
    Event callbacks can be registered and registered event callbacks will be
    called with _event_command_status_ set to {CL_CONTEXT_TERMINATED_KHR}.
    {clWaitForEvents} will return as immediately for commands associated
    with event objects specified in event_list.
    The status of user events can be set.
    Event objects can be retained and released.
    {clGetEventProfilingInfo} returns {CL_PROFILING_INFO_NOT_AVAILABLE}.
  * The context is considered to be terminated.
    A callback function registered when the context was created will be
    called.
    Only queries, retain and release operations can be performed on the
    context.
    All other APIs that use a context as an argument will return
    {CL_CONTEXT_TERMINATED_KHR}.
  * The contents of the memory regions of the memory objects is undefined.
    Queries, registering a destructor callback, retain and release
    operations can be performed on the memory objects.
  * Once a context has been terminated, all OpenCL API calls that create
    objects or enqueue commands will return {CL_CONTEXT_TERMINATED_KHR}.
    APIs that release OpenCL objects will continue to operate as though
    {clTerminateContextKHR} was not called.
  * The behavior of callbacks will remain unchanged, and will report
    appropriate error, if executing after termination of context.
    This behavior is similar to enqueued commands, after the command-queue
    has become invalid.

// refError

{clTerminateContextKHR} returns {CL_SUCCESS} if the function is executed
successfully.
Otherwise, it returns one of the following errors:

  * {CL_INVALID_CONTEXT} if _context_ is not a valid OpenCL context.
  * {CL_CONTEXT_TERMINATED_KHR} if _context_ has already been terminated.
  * {CL_INVALID_OPERATION} if _context_ was not created with
    {CL_CONTEXT_TERMINATE_KHR} set to {CL_TRUE}.
  * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources
    required by the OpenCL implementation on the device.
  * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources
    required by the OpenCL implementation on the host.

An implementation that supports this extension must be able to terminate
commands currently executing on devices or queued across all command-queues
associated with the context that is being terminated.
The implementation cannot implement this extension by waiting for currently
executing (or queued) commands to finish execution on devices associated
with this context (i.e. doing a {clFinish}).
--
endif::cl_khr_terminate_context[]

[open,refpage='clGetContextInfo',desc='Query information about an OpenCL context',type='protos']
--
To query information about a context, call the function:

include::{generated}/api/protos/clGetContextInfo.txt[]
include::{generated}/api/version-notes/clGetContextInfo.asciidoc[]

  * _context_ specifies the OpenCL context being queried.
  * _param_name_ is an enumeration constant that specifies the information to
    query.
  * _param_value_ is a pointer to memory where the appropriate result being
    queried is returned.
    If _param_value_ is `NULL`, it is ignored.
  * _param_value_size_ specifies the size in bytes of memory pointed to by
    _param_value_.
    This size must be greater than or equal to the size of return type as
    described in the <<context-info-table, Context Attributes>> table.
  * _param_value_size_ret_ returns the actual size in bytes of data being
    queried by _param_name_.
    If _param_value_size_ret_ is `NULL`, it is ignored.

The list of supported _param_name_ values and the information returned in
_param_value_ by {clGetContextInfo} is described in the
<<context-info-table, Context Attributes>> table.

[[context-info-table]]
.List of supported param_names by {clGetContextInfo}
[width="100%",cols="<33%,<17%,<50%",options="header"]
|====
| Context Info | Return Type | Description
| {CL_CONTEXT_REFERENCE_COUNT_anchor} footnote:[{fn-reference-count-usage}]

include::{generated}/api/version-notes/CL_CONTEXT_REFERENCE_COUNT.asciidoc[]
  | {cl_uint_TYPE}
      | Return the _context_ reference count.
| {CL_CONTEXT_NUM_DEVICES_anchor}

include::{generated}/api/version-notes/CL_CONTEXT_NUM_DEVICES.asciidoc[]
  | {cl_uint_TYPE}
      | Return the number of devices in _context_.
| {CL_CONTEXT_DEVICES_anchor}

include::{generated}/api/version-notes/CL_CONTEXT_DEVICES.asciidoc[]
  | {cl_device_id_TYPE}[]
      | Return the list of devices and sub-devices in _context_.
| {CL_CONTEXT_PROPERTIES_anchor}

include::{generated}/api/version-notes/CL_CONTEXT_PROPERTIES.asciidoc[]
  | {cl_context_properties_TYPE}[]
      | Return the properties argument specified in {clCreateContext} or
        {clCreateContextFromType}.

        If the _properties_ argument specified in {clCreateContext} or
        {clCreateContextFromType} used to create _context_ was not `NULL`,
        the implementation must return the values specified in the
        properties argument in the same order and without including
        additional properties.

        If the _properties_ argument specified in {clCreateContext} or
        {clCreateContextFromType} used to create _context_ was `NULL`, the
        implementation must return _param_value_size_ret_ equal to 0,
        indicating that there are no properties to be returned.

ifdef::cl_khr_d3d10_sharing[]
| {CL_CONTEXT_D3D10_PREFER_SHARED_RESOURCES_KHR_anchor}

include::{generated}/api/version-notes/CL_CONTEXT_D3D10_PREFER_SHARED_RESOURCES_KHR.asciidoc[]
  | {cl_bool_TYPE}
    | Returns {CL_TRUE} if Direct3D 10 resources created as shared by
      setting _MiscFlags_ to include `D3D10_RESOURCE_MISC_SHARED` will
      perform faster when shared with OpenCL, compared with resources which
      have not set this flag.
      Otherwise returns {CL_FALSE}.
endif::cl_khr_d3d10_sharing[]

ifdef::cl_khr_d3d11_sharing[]
| {CL_CONTEXT_D3D11_PREFER_SHARED_RESOURCES_KHR_anchor}

include::{generated}/api/version-notes/CL_CONTEXT_D3D11_PREFER_SHARED_RESOURCES_KHR.asciidoc[]
  | {cl_bool_TYPE}
    | Returns {CL_TRUE} if Direct3D 11 resources created as shared by
      setting _MiscFlags_ to include `D3D11_RESOURCE_MISC_SHARED` will
      perform faster when shared with OpenCL, compared with resources which
      have not set this flag.
      Otherwise returns {CL_FALSE}.
endif::cl_khr_d3d11_sharing[]

|====

// refError

{clGetContextInfo} returns {CL_SUCCESS} if the function is executed
successfully.
Otherwise, it returns one of the following errors:

  * {CL_INVALID_CONTEXT} if _context_ is not a valid context.
  * {CL_INVALID_VALUE} if _param_name_ is not one of the supported values or
    if size in bytes specified by _param_value_size_ is < size of return
    type as specified in the <<context-info-table, Context Attributes>>
    table and _param_value_ is not a `NULL` value.
  * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources required
    by the OpenCL implementation on the device.
  * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources
    required by the OpenCL implementation on the host.
--

[open,refpage='clSetContextDestructorCallback',desc='Registers a destructor callback function with a context.',type='protos']
--
To register a callback function with a context that is called when
the context is destroyed, call the function

include::{generated}/api/protos/clSetContextDestructorCallback.txt[]
include::{generated}/api/version-notes/clSetContextDestructorCallback.asciidoc[]

  * _context_ specifies the OpenCL context to register the callback to.
  * _pfn_notify_ is the callback function to register.
    This callback function may be called asynchronously by the OpenCL
    implementation.
    It is the application's responsibility to ensure that the callback function
    is thread-safe.
    The parameters to this callback function are:
  ** _context_ is the OpenCL context being deleted.
     When the callback function is called by the implementation, this context
     is no longer valid.
     _context_ is only provided for reference purposes.
  ** _user_data_ is a pointer to user-supplied data.
  * _user_data_ will be passed as the _user_data_ argument when _pfn_notify_ is
    called.
    _user_data_ can be `NULL`.

Each call to {clSetContextDestructorCallback} registers the specified
callback function on a destructor callback stack associated with _context_.
The registered callback functions are called in the reverse order in
which they were registered.
If a context callback function was specified when _context_ was created,
it will not be called after any context destructor callback is called.
Therefore, the context destructor callback provides a mechanism for an
application to safely re-use or free any _user_data_ specified for the
context callback function when _context_ was created.

// refError

{clSetContextDestructorCallback} returns {CL_SUCCESS} if the function is
executed successfully.
Otherwise, it returns one of the following errors:

  * {CL_INVALID_CONTEXT} if _context_ is not a valid context.
  * {CL_INVALID_VALUE} if _pfn_notify_ is `NULL`.
  * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources required
    by the OpenCL implementation on the device.
  * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources
    required by the OpenCL implementation on the host.
--

