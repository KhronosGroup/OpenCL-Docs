// Copyright 2017-2023 The Khronos Group.
// SPDX-License-Identifier: CC-BY-4.0

include::{generated}/meta/{refprefix}cl_khr_gl_sharing.txt[]

=== Other Extension Metadata

*Last Modified Date*::
    2020-04-21
*IP Status*::
    No known IP claims.
*Contributors*::
    TBD

=== Description

`cl_khr_gl_sharing` associates an OpenCL context with an OpenGL context or
share group object.
Once an OpenCL context is associated with an OpenGL context or share group
object, the functionality described in the section
<<cl_khr_gl_sharing__memobjs, Creating OpenCL Memory Objects from OpenGL
Objects>> may be used to share OpenGL buffer, texture, and renderbuffer
objects with the OpenCL context.

An OpenGL implementation supporting buffer objects and sharing of texture
and buffer object images with OpenCL is required by this extension.

=== New Commands

  * {clGetGLContextInfoKHR}

=== New Tokens

  * New Error Codes
  ** {CL_INVALID_GL_SHAREGROUP_REFERENCE_KHR}
  * {cl_gl_context_info_TYPE}
  ** {CL_CURRENT_DEVICE_FOR_GL_CONTEXT_KHR}
  ** {CL_DEVICES_FOR_GL_CONTEXT_KHR}
  * {cl_context_properties_TYPE}
  ** {CL_GL_CONTEXT_KHR}
  ** {CL_EGL_DISPLAY_KHR}
  ** {CL_GLX_DISPLAY_KHR}
  ** {CL_WGL_HDC_KHR}
  ** {CL_CGL_SHAREGROUP_KHR}

=== Issues

  . How should the OpenGL context be identified when creating an associated
    OpenCL context?
+
--
*RESOLVED*: by using a (display,context handle) attribute pair to identify
an arbitrary OpenGL or OpenGL ES context with respect to one of the
window-system binding layers EGL, GLX, or WGL, or a share group handle to
identify a CGL share group.
If a context is specified, it need not be current to the thread calling
clCreateContext*.

A previously suggested approach would use a single boolean attribute
CL_USE_GL_CONTEXT_KHR to allow creating a context associated with the
currently bound OpenGL context.
This may still be implemented as a separate extension, and might allow more
efficient acquire/release behavior in the special case where they are being
executed in the same thread as the bound GL context used to create the CL
context.
--

  . What should the format of an attribute list be?
+
--
After considerable discussion, we think we can live with a list of
<attribute name,value> pairs terminated by zero.
The list is passed as 'cl_context_properties *_properties'_, where
cl_context_properties is typedefed to be 'intptr_t' in cl.h.

This effectively allows encoding all scalar integer, pointer, and handle
values in the host API into the argument list and is analogous to the
structure and type of EGL attribute lists.
`NULL` attribute lists are also allowed.
Again as for EGL, any attributes not explicitly passed in the list will take
on a defined default value that does something reasonable.

Experience with EGL, GLX, and WGL has shown attribute lists to be a
sufficiently flexible and general mechanism to serve the needs of management
calls such as context creation.
It is not completely general (encoding floating-point and non-scalar
attribute values is not straightforward), and other approaches were
suggested such as opaque attribute lists with getter/setter methods, or
arrays of varadic structures.
--

  . What's the behavior of an associated OpenGL or OpenCL context when using
    resources defined by the other associated context, and that context is
    destroyed?
+
--
*RESOLVED*: OpenCL objects place a reference on the data store underlying
the corresponding GL object when they're created.
The GL name corresponding to that data store may be deleted, but the data
store itself remains so long as any CL object has a reference to it.
However, destroying all GL contexts in the share group corresponding to a CL
context results in implementation-dependent behavior when using a
corresponding CL object, up to and including program termination.
--

  . How about sharing with D3D?
+
--
Sharing between D3D and OpenCL should use the same attribute list mechanism,
though obviously with different parameters, and be exposed as a similar
parallel OpenCL extension.
There may be an interaction between that extension and this one since it's
not yet clear if it will be possible to create a CL context simultaneously
sharing GL and D3D objects.
--

  . Under what conditions will context creation fail due to sharing?
+
--
*RESOLVED*: Several cross-platform failure conditions are described (GL
context or CGL share group doesn't exist, GL context doesn't support types
of GL objects, GL context implementation doesn't allow sharing), but
additional failures may result due to implementation-dependent reasons and
should be added to this extension as such failures are discovered.
Sharing between OpenCL and OpenGL requires integration at the driver
internals level.
--

  . What command-queues can *clEnqueueAcquire/ReleaseGLObjects* be placed
    on?
+
--
*RESOLVED*: All command-queues.
This restriction is enforced at context creation time.
If any device passed to context creation cannot support shared CL/GL
objects, context creation will fail with a {CL_INVALID_OPERATION} error.
--

  . How can applications determine which command-queue to place an
    Acquire/Release on?
+
--
*RESOLVED*: The {clGetGLContextInfoKHR} returns either the CL device
currently corresponding to a specified GL context (typically the display
it's running on), or a list of all the CL devices the specified context
might run on (potentially useful in multiheaded / "`virtual screen`"
environments).
This command is not simply placed in <<cl_khr_gl_sharing__memobjs,Creating
OpenCL Memory Objects from OpenGL Objects>> because it relies on the same
property-list method of specifying a GL context introduced by this
extension.

If no devices are returned, it means that the GL context exists on an older
GPU not capable of running OpenCL, but still capable of sharing objects
between GL running on that GPU and CL running elsewhere.
--

  . What is the meaning of the {CL_DEVICES_FOR_GL_CONTEXT_KHR} query?
+
--
*RESOLVED*: The list of all CL devices that may ever be associated with a
specific GL context.
On platforms such as MacOS X, the "`virtual screen`" concept allows multiple
GPUs to back a single virtual display.
Similar functionality might be implemented on other windowing systems, such
as a transparent heterogenous multiheaded X server.
Therefore the exact meaning of this query is interpreted relative to the
binding layer API in use.
--

=== Version History

  * Revision 1.0.0, 2020-04-21
  ** First assigned version.
