ifdef::cl_khr_gl_event[]
endif::cl_khr_gl_event[]

=== Additions to Chapter 5 of the OpenCL 2.2 Specification

Add following to the fourth paragraph of _section 5.11_ (prior to the
description of {clWaitForEvents}):

Event objects can also be used to reflect the status of an OpenGL sync
object.
The sync object in turn refers to a fence command executing in an OpenGL
command stream.
This provides another method of coordinating sharing of buffers and images
between OpenGL and OpenCL.

Add {CL_COMMAND_GL_FENCE_SYNC_OBJECT_KHR} to the valid _param_value_ values
returned by {clGetEventInfo} for _param_name_ {CL_EVENT_COMMAND_TYPE} (in
the third row and third column of _table 5.22_).

Add new _subsection 5.11.1_:

*5.11.1 Linking Event Objects to OpenGL Synchronization Objects*

An event object may be created by linking to an OpenGL *sync object*.
Completion of such an event object is equivalent to waiting for completion
of the fence command associated with the linked GL sync object.

[open,refpage='clCreateEventFromGLsyncKHR',desc='Create OpenCL event object linked to an OpenGL sync object',type='protos']
--
To create an OpenCL event object linked to an OpenGL sync object, call the
function

include::{generated}/api/protos/clCreateEventFromGLsyncKHR.txt[]

  * _context_ is a valid OpenCL context created from an OpenGL context or
    share group, using the `<<cl_khr_gl_sharing>>` extension.
  * _sync_ is the name of a sync object in the GL share group associated
    with _context_.

// refError

{clCreateEventFromGLsyncKHR} returns a valid OpenCL event object and
_errcode_ret_ is set to {CL_SUCCESS} if the event object is created
successfully.
Otherwise, it returns a `NULL` value with one of the following error values
returned in _errcode_ret_:

  * {CL_INVALID_CONTEXT} if _context_ is not a valid context, or was not
    created from a GL context.
  * {CL_INVALID_GL_OBJECT} if _sync_ is not the name of a sync object in the
    GL share group associated with _context_.

The parameters of an event object linked to a GL sync object will return the
following values when queried with {clGetEventInfo}:

  * The {CL_EVENT_COMMAND_QUEUE} of a linked event is `NULL`, because the
    event is not associated with any OpenCL command-queue.
  * The {CL_EVENT_COMMAND_TYPE} of a linked event is
    {CL_COMMAND_GL_FENCE_SYNC_OBJECT_KHR}, indicating that the event is
    associated with a GL sync object, rather than an OpenCL command.
  * The {CL_EVENT_COMMAND_EXECUTION_STATUS} of a linked event is either
    {CL_SUBMITTED}, indicating that the fence command associated with the
    sync object has not yet completed, or {CL_COMPLETE}, indicating that the
    fence command has completed.

{clCreateEventFromGLsyncKHR} performs an implicit {clRetainEvent} on the
returned event object.
Creating a linked event object also places a reference on the linked GL sync
object.
When the event object is deleted, the reference will be removed from the GL
sync object.

Events returned from {clCreateEventFromGLsyncKHR} can be used in the
_event_wait_list_ argument to {clEnqueueAcquireGLObjects} and CL APIs that
take a {cl_event} as an argument but do not enqueue commands.
Passing such events to any other CL API that enqueues commands will generate
a {CL_INVALID_EVENT} error.
--

=== Additions to the OpenCL Extension Specification

Add following the paragraph describing parameter _event_ to
{clEnqueueAcquireGLObjects}:

If an OpenGL context is bound to the current thread, then any OpenGL
commands which

  . affect or access the contents of a memory object listed in the
    _mem_objects_ list, and
  . were issued on that OpenGL context prior to the call to
    {clEnqueueAcquireGLObjects}

will complete before execution of any OpenCL commands following the
{clEnqueueAcquireGLObjects} which affect or access any of those memory
objects.
If a non-`NULL` _event_ object is returned, it will report completion only
after completion of such OpenGL commands.

Add following the paragraph describing parameter _event_ to
{clEnqueueReleaseGLObjects}:

If an OpenGL context is bound to the current thread, then then any OpenGL
commands which

  . affect or access the contents of the memory objects listed in the
    _mem_objects_ list, and
  . are issued on that context after the call to {clEnqueueReleaseGLObjects}

will not execute until after execution of any OpenCL commands preceding the

{clEnqueueReleaseGLObjects} which affect or access any of those memory
objects.
If a non-`NULL` _event_ object is returned, it will report completion before
execution of such OpenGL commands.

Replace the second paragraph of
<<cl_khr_gl_sharing__memobjs-synchronizing-opencl-and-opengl-access-to-shared-objects,
Synchronizing OpenCL and OpenGL Access to Shared Objects>> with:

Prior to calling {clEnqueueAcquireGLObjects}, the application must ensure
that any pending OpenGL operations which access the objects specified in
_mem_objects_ have completed.

If the `<<cl_khr_gl_event>>` extension is supported, then the OpenCL
implementation will ensure that any such pending OpenGL operations are
complete for an OpenGL context bound to the same thread as the OpenCL
context.
This is referred to as _implicit synchronization_.

If the `<<cl_khr_gl_event>>` extension is supported and the OpenGL context
in question supports fence sync objects, completion of OpenGL commands may
also be determined by placing a GL fence command after those commands using
`glFenceSync`, creating an event from the resulting GL sync object using
{clCreateEventFromGLsyncKHR}, and determining completion of that event
object via {clEnqueueAcquireGLObjects}.
This method may be considerably more efficient than calling `glFinish`, and
is referred to as _explicit synchronization_.
Explicit synchronization is most useful when an OpenGL context bound to
another thread is accessing the memory objects.

If the `<<cl_khr_gl_event>>` extension is not supported, completion of
OpenGL commands may be determined by issuing and waiting for completion of a
`glFinish` command on all OpenGL contexts with pending references to these
objects.
Some implementations may offer other efficient synchronization methods.
If such methods exist they will be described in platform-specific
documentation.

Note that no synchronization method other than `glFinish` is portable
between all OpenGL implementations and all OpenCL implementations.
While this is the only way to ensure completion that is portable to all
platforms, `glFinish` is an expensive operation and its use should be
avoided if the `<<cl_khr_gl_event>>` extension is supported on a platform.
