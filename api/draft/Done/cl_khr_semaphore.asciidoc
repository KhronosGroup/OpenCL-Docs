DONE as of 2023-10-26, except for beefing up type descriptions to include
refpage/API include stuff

OK> // Copyright 2021-2023 The Khronos Group. This work is licensed under a
OK> // Creative Commons Attribution 4.0 International License; see
OK> // http://creativecommons.org/licenses/by/4.0/
OK>
OK> [[cl_khr_semaphore]]
OK> == Semaphores (Provisional)
OK>
OK> OpenCL provides {cl_event_TYPE} as a primary mechanism of synchronization between host and device as well as across devices.
OK> While events can be waited on or can be passed as dependencies across work-submissions, they suffer from following limitations:
OK>
OK> * They are immutable.
OK>
OK> * They are not reusable.
OK>
OK> This extension introduces a new type of synchronization object to represent semaphores that can be reused, waited on, and signaled multiple times by OpenCL work-submissions.
OK>
OK> In particular, this extension defines:
OK>
OK> * A new type called {cl_semaphore_khr_TYPE} to represent the semaphore objects.
OK>
OK> * A new type called {cl_semaphore_properties_khr_TYPE} to specify metadata associated with semaphores.
OK>
OK> * Routines to create, retain, and release semaphores.
OK>
OK> * Routines to wait on and signal semaphore objects.
OK>
OK> * Routine to query the properties of semaphore objects.
OK>
OK> === General Information
OK>
OK> ==== Name Strings
OK>
OK> `cl_khr_semaphore`
OK>
OK> ==== Version History
OK>
OK> [cols="1,1,3",options="header",]
OK> |====
OK> | *Date*     | *Version* | *Description*
OK> | 2023-08-01 | 0.9.1     | Changed device handle list enum to the semaphore-specific {CL_SEMAPHORE_DEVICE_HANDLE_LIST_KHR} (provisional).
OK> | 2021-09-10 | 0.9.0     | Initial version (provisional).
OK> |====
OK>
OK> NOTE: This is a preview of an OpenCL provisional extension specification that has been Ratified under the Khronos Intellectual Property Framework. It is being made publicly available prior to being uploaded to the Khronos registry to enable review and feedback from the community. If you have feedback please create an issue on https://github.com/KhronosGroup/OpenCL-Docs/
OK>
OK> ==== Dependencies
OK>
OK> This extension is written against the OpenCL Specification Version 3.0.8.
OK>
OK> This extension requires OpenCL 1.2.
OK>
OK> ==== Contributors
OK>
OK> // spell-checker: disable
OK> Ajit Hakke-Patil,  NVIDIA +
OK> Amit Rao, NVIDIA +
OK> Balaji Calidas, QUALCOMM +
OK> Ben Ashbaugh, INTEL +
OK> Carsten Rohde, NVIDIA +
OK> Christoph Kubisch, NVIDIA +
OK> Debalina Bhattacharjee, NVIDIA +
OK> Faith Ekstrand, INTEL +
OK> James Jones,  NVIDIA +
OK> Jeremy Kemp, IMAGINATION +
OK> Joshua Kelly, QUALCOMM +
OK> Karthik Raghavan Ravi, NVIDIA +
OK> Kedar Patil, NVIDIA +
OK> Kevin Petit, ARM +
OK> Nikhil Joshi, NVIDIA +
OK> Sharan Ashwathnarayan, NVIDIA +
OK> Vivek Kini,  NVIDIA +
OK> // spell-checker: enable
OK>
OK> === New Types
OK>
OK> [source]
OK> ----
OK> typedef struct _cl_semaphore_khr* cl_semaphore_khr;
OK>
OK> typedef cl_properties cl_semaphore_properties_khr;
OK> typedef cl_uint cl_semaphore_info_khr;
OK> typedef cl_uint cl_semaphore_type_khr;
OK> typedef cl_ulong cl_semaphore_payload_khr;
OK> ----
OK>
OK> === New API Functions
OK>
OK> [source]
OK> ----
OK> cl_semaphore_khr clCreateSemaphoreWithPropertiesKHR(
OK>     cl_context context,
OK>     const cl_semaphore_properties_khr *sema_props,
OK>     cl_int *errcode_ret);
OK>
OK> cl_int clEnqueueWaitSemaphoresKHR(
OK>     cl_command_queue command_queue,
OK>     cl_uint num_sema_objects,
OK>     const cl_semaphore_khr *sema_objects,
OK>     const cl_semaphore_payload_khr *sema_payload_list,
OK>     cl_uint num_events_in_wait_list,
OK>     const cl_event *event_wait_list,
OK>     cl_event *event);
OK>
OK> cl_int clEnqueueSignalSemaphoresKHR(
OK>     cl_command_queue command_queue,
OK>     cl_uint num_sema_objects,
OK>     const cl_semaphore_khr *sema_objects,
OK>     const cl_semaphore_payload_khr *sema_payload_list,
OK>     cl_uint num_events_in_wait_list,
OK>     const cl_event *event_wait_list,
OK>     cl_event *event);
OK>
OK> cl_int clGetSemaphoreInfoKHR(
OK>     cl_semaphore_khr sema_object,
OK>     cl_semaphore_info_khr param_name,
OK>     size_t param_value_size,
OK>     void *param_value,
OK>     size_t *param_value_size_ret);
OK>
OK> cl_int clReleaseSemaphoreKHR(cl_semaphore_khr sema_object);
OK>
OK> cl_int clRetainSemaphoreKHR(cl_semaphore_khr sema_object);
OK> ----
OK>
OK> === New API Enums
OK>
OK> Accepted value for the _param_name_ parameter to {clGetPlatformInfo} to query the semaphore types supported by an OpenCL platform:
OK>
OK> [source]
OK> ----
OK> CL_PLATFORM_SEMAPHORE_TYPES_KHR                             0x2036
OK> ----
OK>
OK> Accepted value for the _param_name_ parameter to {clGetDeviceInfo} to query the semaphore types supported by an OpenCL device:
OK>
OK> [source]
OK> ----
OK> CL_DEVICE_SEMAPHORE_TYPES_KHR                               0x204C
OK> ----
OK>
OK> Semaphore types:
OK>
OK> [source]
OK> ----
OK> CL_SEMAPHORE_TYPE_BINARY_KHR                                1
OK> ----
OK>
OK> New attributes that can be passed as part of {cl_semaphore_info_khr_TYPE}:
OK>
OK> [source]
OK> ----
OK> CL_SEMAPHORE_CONTEXT_KHR                                    0x2039
OK> CL_SEMAPHORE_REFERENCE_COUNT_KHR                            0x203A
OK> CL_SEMAPHORE_PROPERTIES_KHR                                 0x203B
OK> CL_SEMAPHORE_PAYLOAD_KHR                                    0x203C
OK> ----
OK>
OK> // TODO: We don't need an enum assigned for CL_SEMAPHORE_DEVICE_HANDLE_LIST_END_KHR and should just use 0.
OK> // TODO: Do we need to define CL_SEMAPHORE_DEVICE_HANDLE_LIST here or should it be in the external semaphore spec instead?
OK>
OK> New attributes that can be passed as part of {cl_semaphore_info_khr_TYPE} or {cl_semaphore_properties_khr_TYPE}:
OK>
OK> [source]
OK> ----
OK> CL_SEMAPHORE_TYPE_KHR                                       0x203D
OK> CL_SEMAPHORE_DEVICE_HANDLE_LIST_KHR                         0x2053
OK> CL_SEMAPHORE_DEVICE_HANDLE_LIST_END_KHR                     0
OK> ----
OK>
OK> New return values from {clGetEventInfo} when _param_name_ is {CL_EVENT_COMMAND_TYPE}:
OK>
OK> [source]
OK> ----
OK> CL_COMMAND_SEMAPHORE_WAIT_KHR                               0x2042
OK> CL_COMMAND_SEMAPHORE_SIGNAL_KHR                             0x2043
OK> ----
OK>
OK> The following error codes can be returned by APIs introduced as part of this specification or the specifications that depend on this:
OK> [source]
OK> ----
OK> CL_INVALID_SEMAPHORE_KHR                                    -1142
OK> ----

OK> === Modifications to existing APIs added by this spec
OK>
OK> Following new enums are added to the list of supported _param_names_ by {clGetPlatformInfo}:
OK>
OK> .List of supported param_names by {clGetPlatformInfo}
OK> [width="100%",cols="<33%,<17%,<50%",options="header"]
OK> |====
OK> | Platform Info | Return Type | Description
OK> | {CL_PLATFORM_SEMAPHORE_TYPES_KHR}
OK>   | {cl_semaphore_type_khr_TYPE}[]
OK>       | Returns the list of the semaphore types supported all devices in _platform_.
OK> |====

OK> {clGetPlatformInfo} when called with _param_name_ {CL_PLATFORM_SEMAPHORE_TYPES_KHR} must return common list of semaphore types supported by all devices in the platform.
OK>
OK> Following new enums are added to the list of supported _param_names_ by {clGetDeviceInfo}:
OK>
OK> .List of supported param_names by {clGetDeviceInfo}
OK> [width="100%",cols="<33%,<17%,<50%",options="header"]
OK> |====
OK> | Device Info | Return Type | Description
OK> | {CL_DEVICE_SEMAPHORE_TYPES_KHR}
OK>   | {cl_semaphore_type_khr_TYPE}[]
OK>       | Returns the list of the semaphore types supported by _device_.
OK> |====
OK>
OK> {clGetDeviceInfo} when called with param_name {CL_DEVICE_SEMAPHORE_TYPES_KHR} must return a non-empty list of semaphore types for at least one of the devices in the platform.
OK> The results of this query should meet minimum requirements for {cl_semaphore_type_khr_TYPE} as described by <<Description of new types added by this spec>>.
OK>
OK> === Description of new types added by this spec
OK>
OK> Following new types are added:
OK>
OK> * {cl_semaphore_type_khr_TYPE} to represent the different types of semaphores.
OK>     ** It is mandatory to support {CL_SEMAPHORE_TYPE_BINARY_KHR}.
OK>
OK> * {cl_semaphore_properties_khr_TYPE} to represent properties associated with semaphores.
OK>     ** {CL_SEMAPHORE_TYPE_KHR} must be supported.
OK>
OK> * {cl_semaphore_info_khr_TYPE} to represent queries to get additional information about semaphores.
OK>     ** All enums described in New API Enums for {cl_semaphore_info_khr_TYPE} must be supported.
OK>
OK> * {cl_semaphore_payload_khr_TYPE} to represent payload values of semaphores.
OK>
OK> * {cl_semaphore_khr_TYPE} to represent semaphore objects.
OK>
OK> Note that above types can be extended in future based on the need for additional types of semaphore and properties required by them.
OK> The specifics of the same can be added as a newer version of this specification or by a separate specification that depends on this for basic semaphore support.
OK>
OK> === Description of new APIs added by this spec
OK>
OK> The following new APIs are added as part of this spec. The details of each are described below:
OK>
OK> ==== Creating semaphores
OK>
OK> A *semaphore object* may be created using the function
OK>
OK> include::{generated}/api/protos/clCreateSemaphoreWithPropertiesKHR.txt[]
OK>
OK> _context_ identifies a valid OpenCL context that the created {cl_semaphore_khr_TYPE} will belong to.
OK>
OK> // TODO: Do we want the same "all devices in the context" behavior if CL_SEMAPHORE_DEVICE_HANDLE_LIST_KHR is not specified?
OK>
OK> _sema_props_ specifies additional semaphore properties in the form list of <property_name, property_value> pairs terminated with 0.
OK> {CL_SEMAPHORE_TYPE_KHR} must be part of the list of properties specified by _sema_props_.
OK>
OK> Following new properties are added to the list of possible supported properties by {cl_semaphore_properties_khr_TYPE} that can be passed to {clCreateSemaphoreWithPropertiesKHR}:
OK>
OK> .List of supported semaphore creation properties by {clCreateSemaphoreWithPropertiesKHR}
OK> [width="100%",cols="<33%,<17%,<50%",options="header"]
OK> |====
OK> | Semaphore Property | Property Value | Description
OK> | {CL_SEMAPHORE_TYPE_KHR}
OK>   | {cl_semaphore_type_khr_TYPE}
OK>       | Specifies the type of semaphore to create. This property is always required.
OK> | {CL_SEMAPHORE_DEVICE_HANDLE_LIST_KHR}
OK>   | {cl_device_id_TYPE}[]
OK>       | Specifies the list of OpenCL devices (terminated with {CL_SEMAPHORE_DEVICE_HANDLE_LIST_END_KHR}) to associate with the semaphore.
OK> |====
OK>
OK> If {CL_SEMAPHORE_DEVICE_HANDLE_LIST_KHR} is not specified as part of _sema_props_, the semaphore object created by {clCreateSemaphoreWithPropertiesKHR} is by default accessible to all devices in the _context_.
OK>
OK> _errcode_ret_ returns an appropriate error code. If _errcode_ret_ is `NULL`, no error code is returned.
OK>
OK> {clCreateSemaphoreWithPropertiesKHR} returns a valid semaphore object in an un-signaled state and and _errcode_ret_ is set to {CL_SUCCESS} if the function is executed successfully.
OK> Otherwise, it returns a `NULL` value with one of the following error values returned in _errcode_ret_:
OK>
OK> * {CL_INVALID_CONTEXT} if _context_ is not a valid context.
OK> * {CL_INVALID_PROPERTY} if a property name in _sema_props_ is not a supported property name, if the value specified for a supported property name is not valid, or if the same property name is specified more than once.
OK> * {CL_INVALID_DEVICE} if {CL_SEMAPHORE_DEVICE_HANDLE_LIST_KHR} is specified as part of _sema_props_, but it does not identify a valid device or if a device identified by {CL_SEMAPHORE_DEVICE_HANDLE_LIST_KHR} is not one of the devices within _context_.
OK> * {CL_INVALID_VALUE}
OK> ** if _sema_props_ is `NULL`, or
OK> ** if _sema_props_ do not specify <property, value> pairs for minimum set of properties (i.e. {CL_SEMAPHORE_TYPE_KHR}) required for successful creation of a {cl_semaphore_khr_TYPE}, or
OK> * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources required by the OpenCL implementation on the device.
OK> * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources required by the OpenCL implementation on the host.
OK>
OK> ==== Waiting on and signaling semaphores
OK>
OK> To enqueue a command to wait on a set of semaphores, call the function
OK>
OK> include::{generated}/api/protos/clEnqueueWaitSemaphoresKHR.txt[]
OK>
OK> _command_queue_ specifies a valid command-queue.
OK>
OK> _num_sema_objects_ specifies the number of semaphore objects to wait on.
OK>
OK> _sema_objects_ points to the list of semaphore objects to wait on.
OK> The length of the list must be at least _num_sema_objects_.
OK>
OK> _sema_payload_list_ points to the list of values of type {cl_semaphore_payload_khr_TYPE} containing valid semaphore payload values to wait on.
OK> This can be set to `NULL` or will be ignored when all semaphores in the list of _sema_objects_ are of type {CL_SEMAPHORE_TYPE_BINARY_KHR}.
OK>
OK> _num_events_in_wait_list_ specifies the number of events in _event_wait_list_.
OK>
OK> _event_wait_list_ specifies list of events that need to complete before {clEnqueueWaitSemaphoresKHR} can be executed.
OK> If _event_wait_list_ is `NULL`, then {clEnqueueWaitSemaphoresKHR} does not wait on any event to complete.
OK> If _event_wait_list_ is `NULL`, _num_events_in_wait_list_ must be 0.
OK> If _event_wait_list_ is not `NULL`, the list of events pointed to by _event_wait_list_ must be valid and _num_events_in_wait_list_ must be greater than 0.
OK> The events specified in _event_wait_list_ act as synchronization points.
OK> The context associated with events in _event_wait_list_ and that associated with _command_queue_ must be the same.
OK>
OK> _event_ returns an event object that identifies this particular command and can be used to query or queue a wait for this particular command to complete.
OK> _event_ can be `NULL` in which case it will not be possible for the application to query the status of this command or queue a wait for this command to complete.
OK>
OK> The semaphore wait command waits for a list of events to complete and a list of semaphore objects to become signaled.
OK> The semaphore wait command returns an _event_ which can be waited on to ensure that all events in the _event_wait_list_ have completed and all semaphores in _sema_objects_ have been signaled.
OK> {clEnqueueWaitSemaphoresKHR} will not return until the binary semaphores in _sema_objects_ are in a state that makes them safe to re-signal. If necessary, implementations may block in {clEnqueueWaitSemaphoresKHR} to ensure the correct state of semaphores when returning. There are no implications from this behavior for the state of _event_ or the events in _event_wait_list_ when {clEnqueueWaitSemaphoresKHR} returns. Waiting on the same binary semaphore twice without an interleaving signal may lead to undefined behavior.
OK>
OK> {clEnqueueWaitSemaphoresKHR} returns {CL_SUCCESS} if the function is executed successfully.
OK> Otherwise, it returns one of the following errors:
OK>
OK> * {CL_INVALID_COMMAND_QUEUE}
OK> ** if _command_queue_ is not a valid command-queue, or
OK> ** if the device associated with _command_queue_ is not same as one of the devices specified by {CL_SEMAPHORE_DEVICE_HANDLE_LIST_KHR} at the time of creating one or more of _sema_objects_, or
OK> ** if one or more of _sema_objects_ belong to a context that does not contain a device associated with _command_queue_.
OK> * {CL_INVALID_VALUE} if _num_sema_objects_ is 0.
OK> * {CL_INVALID_SEMAPHORE_KHR} if any of the semaphore objects specified by _sema_objects_ is not valid.
OK> * {CL_INVALID_CONTEXT} if the context associated with _command_queue_ and any of the semaphore objects in _sema_objects_ are not the same or if the context associated with _command_queue_ and that associated with events in _event_wait_list_ are not the same.
OK> * {CL_INVALID_VALUE} if any of the semaphore objects specified by _sema_objects_ requires a semaphore payload and _sema_payload_list_ is `NULL`.
OK> * {CL_INVALID_EVENT_WAIT_LIST}
OK>      ** if _event_wait_list_ is `NULL` and _num_events_in_wait_list_ is not 0, or
OK>      ** if _event_wait_list_ is not `NULL` and _num_events_in_wait_list_ is 0, or
OK>      ** if event objects in _event_wait_list_ are not valid events.
OK> * {CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST} if the execution status of any of the events in _event_wait_list_ is a negative integer value.
OK> * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources required by the OpenCL implementation on the device.
OK> * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources required by the OpenCL implementation on the host.
OK>
OK> To enqueue a command to signal a set of semaphores, call the function
OK>
OK> include::{generated}/api/protos/clEnqueueSignalSemaphoresKHR.txt[]
OK>
OK> _command_queue_ specifies a valid command-queue.
OK>
OK> _num_sema_objects_ specifies the number of semaphore objects to signal.
OK>
OK> _sema_objects_ points to the list of semaphore objects to signal.
OK> The length of the list must be at least _num_sema_objects_.
OK>
OK> _sema_payload_list_ points to the list of values of type {cl_semaphore_payload_khr_TYPE} containing semaphore payload values to signal.
OK> This can be set to `NULL` or will be ignored when all semaphores in the list of _sema_objects_ are of type {CL_SEMAPHORE_TYPE_BINARY_KHR}.
OK>
OK> _num_events_in_wait_list_ specifies the number of events in event_wait_list.
OK>
OK> _event_wait_list_ points to the list of events that need to complete before {clEnqueueSignalSemaphoresKHR} can be executed.
OK> If _event_wait_list_ is `NULL`, then {clEnqueueSignalSemaphoresKHR} does not wait on any event to complete.
OK> If _event_wait_list_ is `NULL`, _num_events_in_wait_list_ must be 0.
OK> If _event_wait_list_ is not `NULL`, the list of events pointed to by _event_wait_list_ must be valid and
OK> _num_events_in_wait_list_ must be greater than 0.
OK> The events specified in _event_wait_list_ act as synchronization points.
OK> The context associated with events in _event_wait_list_ and that associated with _command_queue_ must be the same.
OK>
OK> _event_ returns an event object that identifies this particular command and can be used to query or queue a wait for this particular command to complete.
OK> _event_ can be `NULL` in which case it will not be possible for the application to query the status of this command
OK> or queue a wait for this command to complete.
OK>
OK> The semaphore signal command waits for a list of events to complete and then signals a list of semaphore objects.
OK> The semaphore signal command returns an _event_ which can be waited on to ensure that all events in the _event_wait_list_ have completed and all semaphores in _sema_objects_ have been signaled.
OK> The successful completion of the event generated by {clEnqueueSignalSemaphoresKHR} called on one or more semaphore objects of type {CL_SEMAPHORE_TYPE_BINARY_KHR} changes the state of the corresponding semaphore objects to signaled.  {clEnqueueSignalSemaphoresKHR} will not return until the binary semaphores in _sema_objects_ are in a state that makes them safe to wait on again.  If necessary, implementations may block in {clEnqueueSignalSemaphoresKHR} to ensure the correct state of semaphores when returning.  There are no implications from this behavior for the state of _event_ or the events in _event_wait_list_ when {clEnqueueSignalSemaphoresKHR} returns. Signaling the same binary semaphore twice without an interleaving wait may lead to undefined behavior.
OK>
OK> {clEnqueueSignalSemaphoresKHR} returns {CL_SUCCESS} if the function is executed successfully.
OK> Otherwise, it returns one of the following errors:
OK>
OK> * {CL_INVALID_COMMAND_QUEUE}
OK> ** if _command_queue_ is not a valid command-queue, or
OK> ** if the device associated with _command_queue_ is not same as one of the devices specified by {CL_SEMAPHORE_DEVICE_HANDLE_LIST_KHR} at the time of creating one or more of _sema_objects_, or
OK> ** if one or more of _sema_objects_ belong to a context that does not contain a device associated with _command_queue_.
OK> * {CL_INVALID_VALUE} if _num_sema_objects_ is 0
OK> * {CL_INVALID_SEMAPHORE_KHR} if any of the semaphore objects specified by _sema_objects_ is not valid.
OK> * {CL_INVALID_CONTEXT} if the context associated with _command_queue_ and any of the semaphore objects in _sema_objects_ are not the same or if the context associated with _command_queue_ and that associated with events in _event_wait_list_ are not the same.
OK> * {CL_INVALID_VALUE} if any of the semaphore objects specified by _sema_objects_ requires a semaphore payload and _sema_payload_list_ is `NULL`.
OK> * {CL_INVALID_EVENT_WAIT_LIST}
OK>     ** if _event_wait_list_ is `NULL` and _num_events_in_wait_list_ is not 0, or
OK>     ** if _event_wait_list_ is not `NULL` and _num_events_in_wait_list_ is 0, or
OK>     ** if event objects in _event_wait_list_ are not valid events.
OK> * {CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST} if the execution status of any of the events in _event_wait_list_ is a negative integer value.
OK> * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources required by the OpenCL implementation on the device.
OK> * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources required by the OpenCL implementation on the host.
OK>
OK> ==== Semaphore Queries
OK>
OK> To query information about a semaphore object, call the function
OK>
OK> include::{generated}/api/protos/clGetSemaphoreInfoKHR.txt[]
OK>
OK> _sema_object_ specifies the semaphore object being queried.
OK>
OK> _param_name_ is a constant that specifies the semaphore information to query, and must be one of the values shown in <<cl_khr_semaphore_info-table>>.
OK>
OK> _param_value_ is a pointer to memory where the result of the query is returned as described in <<cl_khr_semaphore_info-table>>. If _param_value_ is `NULL`, it is ignored.
OK>
OK> _param_value_size_ specifies the size in bytes of memory pointed to _param_value_. This size must be greater than or equal to the size of the return type described in table <<cl_khr_semaphore_info-table>>.
OK>
OK> _param_value_size_ret_ returns the actual size in bytes of data
OK> being queried by _param_value_. If _param_value_size_ret_ is `NULL`, it is ignored.
OK>
OK> [[cl_khr_semaphore_info-table]]
OK> .List of supported param_names by {clGetSemaphoreInfoKHR}
OK> [width="100%",cols="<33%,<17%,<50%",options="header"]
OK> |====
OK> | Semaphore Info | Return Type | Description
OK> | {CL_SEMAPHORE_CONTEXT_KHR}
OK>   | {cl_context_TYPE}
OK>       | Returns the context specified when the semaphore is created.
OK>
OK> | {CL_SEMAPHORE_REFERENCE_COUNT_KHR} footnote:[{fn-reference-count-usage}]
OK>   | {cl_uint_TYPE}
OK>       | Returns the semaphore reference count.
OK>
OK> | {CL_SEMAPHORE_PROPERTIES_KHR}
OK>   | {cl_semaphore_properties_khr_TYPE}[]
OK>       | Return the properties argument specified in
OK>         {clCreateSemaphoreWithPropertiesKHR}.
OK>
OK>         The implementation must return the values specified in the properties
OK>         argument in the same order and without including additional properties.
OK>
OK> | {CL_SEMAPHORE_TYPE_KHR}
OK>   | {cl_semaphore_type_khr_TYPE}
OK>       | Returns the semaphore type.
OK>
OK> | {CL_SEMAPHORE_PAYLOAD_KHR}
OK>   | {cl_semaphore_payload_khr_TYPE}
OK>       | Returns the semaphore payload value. For semaphores of type
OK>         {CL_SEMAPHORE_TYPE_BINARY_KHR}, the payload value returned will be `0`
OK>         if the semaphore is in an un-signaled state and `1` if it is in a
OK>         signaled state.
OK>
OK> | {CL_SEMAPHORE_DEVICE_HANDLE_LIST_KHR}
OK>   | {cl_device_id_TYPE}[]
OK>       | Returns the list of OpenCL devices the semaphore is associated with.
OK> |====
OK>
OK> {clGetSemaphoreInfoKHR} returns {CL_SUCCESS} if the information is queried successfully.
OK> Otherwise, it returns one of the following errors:
OK>
OK> * {CL_INVALID_SEMAPHORE_KHR}
OK> ** if _sema_object_ is not a valid semaphore
OK> * {CL_INVALID_VALUE}
OK> ** if _param_name_ is not one of the attribute defined in table <<cl_khr_semaphore_info-table>> or
OK> ** if _param_value_size_ is less than the size of Return Type of the corresponding _param_name_ attribute as defined in table <<cl_khr_semaphore_info-table>>.
OK> * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources required by the OpenCL implementation on the device.
OK> * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources required by the OpenCL implementation on the host.
OK>
OK> ==== Retaining and Releasing Semaphores
OK>
OK> To release a semaphore object, call the function
OK>
OK> include::{generated}/api/protos/clReleaseSemaphoreKHR.txt[]
OK>
OK> _sema_object_ specifies the semaphore object to be released.
OK>
OK> The _sema_object_ reference count is decremented.
OK>
OK> {clReleaseSemaphoreKHR} returns {CL_SUCCESS} if the function is executed successfully.
OK> Otherwise, it returns one of the following errors:
OK>
OK> * {CL_INVALID_SEMAPHORE_KHR} if _sema_object_ is not a valid semaphore object.
OK> * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources required by the OpenCL implementation on the device.
OK> * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources required by the OpenCL implementation on the host.
OK>
OK> After the reference count becomes zero and commands queued for execution on a
OK> command-queue(s) that use _sema_object_ have finished, the semaphore object is
OK> deleted.
OK> Using this function to release a reference that was not obtained by creating the
OK> object via {clCreateSemaphoreWithPropertiesKHR} or by calling
OK> {clRetainSemaphoreKHR} causes undefined behavior.
OK>
OK> To retain a semaphore object, call the function
OK>
OK> include::{generated}/api/protos/clRetainSemaphoreKHR.txt[]
OK>
OK> _sema_object_ specifies the semaphore object to be retained.
OK>
OK> increments the reference count of _sema_object_.
OK>
OK> {clRetainSemaphoreKHR} returns {CL_SUCCESS} if the function is executed successfully.
OK> Otherwise, it returns one of the following errors:
OK>
OK> * {CL_INVALID_SEMAPHORE_KHR} if _sema_object_ is not a valid semaphore object.
OK> * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources required by the OpenCL implementation on the device.
OK> * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources required by the OpenCL implementation on the host.
OK>
OK> [[cl_khr_semaphore-Sample-Code]]
OK> === Sample Code
OK>
OK> . Example for semaphore creation in a single device context
OK> +
OK> --
OK> [source]
OK> ----
OK> // Get cl_devices of the platform.
OK> clGetDeviceIDs(..., &devices, &deviceCount);
OK>
OK> // Create cl_context with just first device
OK> context = clCreateContext(..., 1, devices, ...);
OK>
OK> // Create clSema of type cl_semaphore_khr usable on single device in the context
OK>
OK> cl_semaphore_properties_khr sema_props[] =
OK>         {(cl_semaphore_properties_khr)CL_SEMAPHORE_TYPE_KHR,
OK>          (cl_semaphore_properties_khr)CL_SEMAPHORE_TYPE_BINARY_KHR,
OK>           0};
OK>
OK> int errcode_ret = 0;
OK>
OK> cl_semaphore_khr clSema = clCreateSemaphoreWithPropertiesKHR(context,
OK>                                                              sema_props,
OK>                                                              &errcode_ret);
OK> ----
OK> --
OK>
OK> . Example for semaphore creation for a single device in a multi-device context
OK> +
OK> --
OK> [source]
OK> ----
OK> // Get cl_devices of the platform.
OK> clGetDeviceIDs(..., &devices, &deviceCount);
OK>
OK> // Create cl_context with first two devices
OK> clCreateContext(..., 2, devices, ...);
OK>
OK> // Create clSema of type cl_semaphore_khr usable only on device 0
OK> cl_semaphore_properties_khr sema_props[] = {
OK>     (cl_semaphore_properties_khr)CL_SEMAPHORE_TYPE_KHR,
OK>     (cl_semaphore_properties_khr)CL_SEMAPHORE_TYPE_BINARY_KHR,
OK>     (cl_semaphore_properties_khr)CL_SEMAPHORE_DEVICE_HANDLE_LIST_KHR,
OK>     (cl_semaphore_properties_khr)devices[0],
OK>     CL_SEMAPHORE_DEVICE_HANDLE_LIST_END_KHR,
OK>     0
OK> };
OK>
OK> int errcode_ret = 0;
OK>
OK> cl_semaphore_khr clSema = clCreateSemaphoreWithPropertiesKHR(context,
OK>                                                              sema_props,
OK>                                                              &errcode_ret);
OK> ----
OK> --
OK> . Example for synchronization using Wait and Signal
OK> +
OK> --
OK> [source]
OK> ----
OK> // clSema is created using clCreateSemaphoreWithPropertiesKHR
OK> // using one of the examples for semaphore creation.
OK>
OK> cl_semaphore_khr clSema = clCreateSemaphoreWithPropertiesKHR(context,
OK>                                                              sema_props,
OK>                                                              &errcode_ret);
OK>
OK> // Start the main loop
OK>
OK> while (true) {
OK>     // (not shown) Signal the semaphore from other work
OK>
OK>     // Wait for the semaphore in OpenCL
OK>     // by calling clEnqueueWaitSemaphoresKHR on 'clSema'
OK>     clEnqueueWaitSemaphoresKHR(/*command_queue*/              command_queue,
OK>                                /*num_sema_objects*/           1,
OK>                                /*sema_objects*/               &clSema,
OK>                                /*sema_payload_list*/          NULL,
OK>                                /*num_events_in_wait_list*/    0,
OK>                                /*event_wait_list*/            NULL,
OK>                                /*event*/                      NULL);
OK>
OK>     // Launch kernel that accesses extMem
OK>     clEnqueueNDRangeKernel(command_queue, ...);
OK>
OK>     // Signal the semaphore in OpenCL
OK>     clEnqueueSignalSemaphoresKHR(/*command_queue*/              command_queue,
OK>                                  /*num_sema_objects*/           1,
OK>                                  /*sema_objects*/               &clSema,
OK>                                  /*sema_payload_list*/          NULL,
OK>                                  /*num_events_in_wait_list*/    0,
OK>                                  /*event_wait_list*/            NULL,
OK>                                  /*event*/                      NULL);
OK>
OK>     // (not shown) Launch other work that waits on 'clSema'
OK> }
OK> ----
OK> --
OK> . Example for {clGetSemaphoreInfoKHR}
OK> +
OK> --
OK> [source]
OK> ----
OK> // clSema is created using clCreateSemaphoreWithPropertiesKHR
OK> // using one of the examples for semaphore creation.
OK>
OK> cl_semaphore_khr clSema = clCreateSemaphoreWithPropertiesKHR(context,
OK>                                                              sema_props,
OK>                                                              &errcode_ret);
OK>
OK> // Start the main rendering loop
OK>
OK> while (true) {
OK>     // (not shown) Signal the semaphore from other work
OK>
OK>     // Wait for the semaphore in OpenCL, by calling clEnqueueWaitSemaphoresKHR on 'clSema'
OK>     clEnqueueWaitSemaphoresKHR(/*command_queue*/              command_queue,
OK>                                /*num_sema_objects*/           1,
OK>                                /*sema_objects*/               &clSema,
OK>                                /*sema_payload_list*/          NULL,
OK>                                /*num_events_in_wait_list*/    0,
OK>                                /*event_wait_list*/            NULL,
OK>                                /*event*/                      NULL);
OK>
OK>     // Launch kernel in OpenCL
OK>     clEnqueueNDRangeKernel(command_queue, ...);
OK>
OK>     // Signal the semaphore in OpenCL
OK>     clEnqueueSignalSemaphoresKHR(/*command_queue*/              command_queue,
OK>                                  /*num_sema_objects*/           1,
OK>                                  /*sema_objects*/               &clSema,
OK>                                  /*sema_payload_list*/          NULL,
OK>                                  /*num_events_in_wait_list*/    0,
OK>                                  /*event_wait_list*/            NULL,
OK>                                  /*event*/                      NULL);
OK>
OK>     // Query type of clSema
OK>     clGetSemaphoreInfoKHR(/*sema_object*/           clSema,
OK>                           /*param_name*/            CL_SEMAPHORE_TYPE_KHR,
OK>                           /*param_value_size*/      sizeof(cl_semaphore_type_khr),
OK>                           /*param_value*/           &clSemaType,
OK>                           /*param_value_ret_size*/  &clSemaTypeSize);
OK>
OK>     if (clSemaType == CL_SEMAPHORE_TYPE_BINARY_KHR) {
OK>         // Do something
OK>     }
OK>     else {
OK>         // Do something else
OK>     }
OK>     // (not shown) Launch other work that waits on 'clSema'
OK> }
OK> ----
OK> --
