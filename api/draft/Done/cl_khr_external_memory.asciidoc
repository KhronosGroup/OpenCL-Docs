DONE as of 2023-10-26, except for TODOs below

OK> // Copyright 2021-2023 The Khronos Group. This work is licensed under a
OK> // Creative Commons Attribution 4.0 International License; see
OK> // http://creativecommons.org/licenses/by/4.0/

OK> [[cl_khr_external_memory]]
OK> == External Memory (Provisional)
OK>
OK> This extension defines a generic mechanism to share buffer and image objects
OK> between OpenCL and many other APIs.
OK>
OK> In particular, the `cl_khr_external_memory` extension defines:
OK>
OK> * Optional properties to import external memory exported by other APIs into
OK>   OpenCL for a set of devices.
OK> * Routines to explicitly hand off memory ownership between OpenCL and other
OK>   APIs.
OK>
OK> Other related extensions define specific external memory types that may be
OK> imported into OpenCL.

OK> === General Information
OK>
OK> ==== Name Strings
OK>
OK> `cl_khr_external_memory` +
OK> `cl_khr_external_memory_dma_buf` +
OK> `cl_khr_external_memory_dx` +
OK> `cl_khr_external_memory_opaque_fd` +
OK> `cl_khr_external_memory_win32`

OK> ==== Version History
OK>
OK> [cols="1,1,3",options="header",]
OK> |====
OK> | *Date*     | *Version* | *Description*
OK> | 2023-08-29 | 0.9.3     | Added query for {CL_DEVICE_EXTERNAL_MEMORY_IMPORT_ASSUME_LINEAR_HANDLE_TYPES_KHR} (provisional).
OK> | 2023-08-01 | 0.9.2     | Changed device handle list enum to the memory-specific {CL_MEM_DEVICE_HANDLE_LIST_KHR} (provisional).
OK> | 2023-05-04 | 0.9.1     | Clarified device handle list enum cannot be specified without an external memory handle (provisional).
OK> | 2021-09-10 | 0.9.0     | Initial version (provisional).
OK> |====
OK>
OK> NOTE: This is a preview of an OpenCL provisional extension specification
OK> that has been Ratified under the Khronos Intellectual Property Framework.
OK> It is being made publicly available prior to being uploaded to the Khronos
OK> registry to enable review and feedback from the community.
OK> If you have feedback please create an issue on
OK> https://github.com/KhronosGroup/OpenCL-Docs/

OK> ==== Dependencies
OK>
OK> This extension is written against the OpenCL Specification Version 3.0.8.
OK>
OK> Because this extension adds new properties for {clCreateBufferWithProperties}
OK> and {clCreateImageWithProperties} this extension requires OpenCL 3.0.

OK> ==== Contributors
OK>
OK> // spell-checker: disable
OK> Ajit Hakke-Patil,  NVIDIA +
OK> Amit Rao, NVIDIA +
OK> Balaji Calidas, QUALCOMM +
OK> Ben Ashbaugh, INTEL +
OK> Carsten Rohde, NVIDIA +
OK> Christoph Kubisch, NVIDIA +
OK> Debalina Bhattacharjee, NVIDIA +
OK> Faith Ekstrand, INTEL +
OK> James Jones,  NVIDIA +
OK> Jeremy Kemp, IMAGINATION +
OK> Joshua Kelly, QUALCOMM +
OK> Karthik Raghavan Ravi, NVIDIA +
OK> Kedar Patil, NVIDIA +
OK> Kevin Petit, ARM +
OK> Nikhil Joshi, NVIDIA +
OK> Sharan Ashwathnarayan, NVIDIA +
OK> Vivek Kini,  NVIDIA +
OK> // spell-checker: enable

=== New Types

TODO proto - where in spec?

OK> [source]
OK> ----
OK> typedef cl_uint cl_external_memory_handle_type_khr;
OK> ----

TODO proto - where in spec?

OK> === New API Functions
OK>
OK> [source]
OK> ----
OK> cl_int clEnqueueAcquireExternalMemObjectsKHR(
OK>     cl_command_queue command_queue,
OK>     cl_uint num_mem_objects,
OK>     const cl_mem *mem_objects,
OK>     cl_uint num_events_in_wait_list,
OK>     const cl_event *event_wait_list,
OK>     cl_event *event);
OK>
OK> cl_int clEnqueueReleaseExternalMemObjectsKHR(
OK>     cl_command_queue command_queue,
OK>     cl_uint num_mem_objects,
OK>     const cl_mem *mem_objects,
OK>     cl_uint num_events_in_wait_list,
OK>     const cl_event *event_wait_list,
OK>     cl_event *event);
OK> ----

=== New API Enums

OK> Accepted value for the _param_name_ parameter to {clGetPlatformInfo} to
OK> query external memory handle types that may be imported by all devices in an
OK> OpenCL platform:
OK>
OK> [source]
OK> ----
OK> CL_PLATFORM_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES_KHR                    0x2044
OK> ----
OK>
OK> Accepted value for the _param_name_ parameter to {clGetDeviceInfo} to query
OK> external memory handle types that may be imported by an OpenCL device:
OK>
OK> [source]
OK> ----
OK> CL_DEVICE_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES_KHR                           0x204F
OK> CL_DEVICE_EXTERNAL_MEMORY_IMPORT_ASSUME_LINEAR_IMAGES_HANDLE_TYPES_KHR      0x2052
OK> ----
OK>
OK> New properties accepted as _properties_ to {clCreateBufferWithProperties}
OK> and {clCreateImageWithProperties}:
OK>
OK> [source]
OK> ----
OK> CL_MEM_DEVICE_HANDLE_LIST_KHR                                          0x2051
OK> CL_MEM_DEVICE_HANDLE_LIST_END_KHR                                      0
OK> ----
OK>
OK> New return values from {clGetEventInfo} when _param_name_ is
OK> {CL_EVENT_COMMAND_TYPE}:
OK>
OK> [source]
OK> ----
OK> CL_COMMAND_ACQUIRE_EXTERNAL_MEM_OBJECTS_KHR                            0x2047
OK> CL_COMMAND_RELEASE_EXTERNAL_MEM_OBJECTS_KHR                            0x2048
OK> ----
OK>
OK> External memory handle type added by `cl_khr_external_memory_dma_buf`:
OK>
OK> [source]
OK> ----
OK> CL_EXTERNAL_MEMORY_HANDLE_DMA_BUF_KHR              0x2067
OK> ----
OK>
OK> External memory handle types added by `cl_khr_external_memory_dx`:
OK>
OK> [source]
OK> ----
OK> CL_EXTERNAL_MEMORY_HANDLE_D3D11_TEXTURE_KHR        0x2063
OK> CL_EXTERNAL_MEMORY_HANDLE_D3D11_TEXTURE_KMT_KHR    0x2064
OK> CL_EXTERNAL_MEMORY_HANDLE_D3D12_HEAP_KHR           0x2065
OK> CL_EXTERNAL_MEMORY_HANDLE_D3D12_RESOURCE_KHR       0x2066
OK> ----
OK>
OK> External memory handle type added by `cl_khr_external_memory_opaque_fd`:
OK>
OK> [source]
OK> ----
OK> CL_EXTERNAL_MEMORY_HANDLE_OPAQUE_FD_KHR            0x2060
OK> ----
OK>
OK> External memory handle types added by `cl_khr_external_memory_win32`:
OK>
OK> [source]
OK> ----
OK> CL_EXTERNAL_MEMORY_HANDLE_OPAQUE_WIN32_KHR         0x2061
OK> CL_EXTERNAL_MEMORY_HANDLE_OPAQUE_WIN32_KMT_KHR     0x2062
OK> ----

OK> === Modifications to existing APIs added by this spec
OK>
OK> Following new enums are added to the list of supported _param_names_ by
OK> {clGetPlatformInfo}:
OK>
OK> .List of supported param_names by clGetPlatformInfo
OK> [width="100%",cols="<33%,<17%,<50%",options="header"]
OK> |====
OK> | Platform Info | Return Type | Description
OK> | {CL_PLATFORM_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES_KHR}
OK>   | {cl_external_memory_handle_type_khr_TYPE}[]
OK>       | Returns the list of importable external memory handle types
OK>         supported by all devices in _platform_.
OK> |====
OK>
OK> {clGetPlatformInfo} when called with _param_name_
OK> {CL_PLATFORM_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES_KHR} must return a common
OK> list of external memory handle types supported by all devices in the
OK> platform.
OK>
OK> Following new enums are added to the list of supported _param_names_ by
OK> {clGetDeviceInfo}:
OK>
OK> .List of supported param_names by clGetDeviceInfo
OK> [width="100%",cols="<33%,<17%,<50%",options="header"]
OK> |====
OK> | Device Info | Return Type | Description
OK> | {CL_DEVICE_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES_KHR}
OK>   | {cl_external_memory_handle_type_khr_TYPE}[]
OK>       | Returns the list of importable external memory handle types
OK>         supported by _device_.
OK> | {CL_DEVICE_EXTERNAL_MEMORY_IMPORT_ASSUME_LINEAR_IMAGES_HANDLE_TYPES_KHR}
OK>   | {cl_external_memory_handle_type_khr_TYPE}[]
OK>       | Returns the list of importable external memory handle types
OK>         supported by _device_, that are assumed to apply linear layout to
OK>         imported images when no other tiling information is provided.
OK> |====
OK>
OK> {clGetDeviceInfo} when called with param_name
OK> {CL_DEVICE_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES_KHR} must return a non-empty
OK> list of external memory handle types for at least one of the devices in the
OK> platform.
OK>
OK> {clGetDeviceInfo} when called with param_name
OK> {CL_DEVICE_EXTERNAL_MEMORY_IMPORT_ASSUME_LINEAR_IMAGES_HANDLE_TYPES_KHR}
OK> returns a list of external memory handle types that are assumed to have a
OK> linear memory layout when no other tiling information is provided.
OK> This list contains a subset of
OK> {CL_DEVICE_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES_KHR}.
OK> The returned list may be empty.
OK>
OK> External memory handle types not in
OK> {CL_DEVICE_EXTERNAL_MEMORY_IMPORT_ASSUME_LINEAR_IMAGES_HANDLE_TYPES_KHR} may
OK> have any memory layout.
OK> The layout interpretation of images imported with these handle types is
OK> implementation defined.

TODO This language was largely replicated between the buffer/image APIs - could be avoided?

OK> Following new properties are added to the list of supported properties by
OK> {clCreateBufferWithProperties} and {clCreateImageWithProperties}.
OK>
OK> ifdef::cl_khr_external_memory[]
OK> [[external-memory-properties-table]]
OK> .List of supported buffer and image creation properties
OK> [width="100%",cols="<33%,<17%,<50%",options="header"]
OK> |====
OK> | Property | Property Value | Description
OK> | {CL_MEM_DEVICE_HANDLE_LIST_KHR}
OK>   | {cl_device_id_TYPE}[]
OK>       | Specifies the list of OpenCL devices (terminated with
OK>         {CL_MEM_DEVICE_HANDLE_LIST_END_KHR}) to associate with the external
OK>         memory handle.
OK> |====
OK>
OK> If {CL_MEM_DEVICE_HANDLE_LIST_KHR} is not specified as part of _properties_,
OK> the memory object created by {clCreateBufferWithProperties} or
OK> {clCreateImageWithProperties} is by default accessible to all devices in the
OK> _context_.
OK>
OK> The properties used to create a buffer or image from an external memory
OK> handle are described by related extensions.
OK> When a buffer or image is created from an external memory handle, the
OK> _flags_ used to specify usage information for the buffer or image must not
OK> include {CL_MEM_USE_HOST_PTR}, {CL_MEM_ALLOC_HOST_PTR}, or
OK> {CL_MEM_COPY_HOST_PTR}, and the _host_ptr_ argument must be `NULL`.
OK> When images are created from an external memory handle, implementations may
OK> acquire information about image attributes such as format and layout at the
OK> time of creation.
OK> When such information is acquired at image creation time, it is used for the
OK> lifetime of the image object.
OK> endif::cl_khr_external_memory[]

OK> Add to the list of error conditions for {clCreateBufferWithProperties} and
OK> {clCreateImageWithProperties}:
OK>
OK> ifdef::cl_khr_external_memory[]
OK>   * {CL_INVALID_DEVICE}
OK>   ** if a device identified by the property {CL_MEM_DEVICE_HANDLE_LIST_KHR}
OK>      is not a valid device or is not associated with _context_, or
OK>   ** if a device identified by property {CL_MEM_DEVICE_HANDLE_LIST_KHR}
OK>      cannot import the requested external memory object type, or
OK>   ** if {CL_MEM_DEVICE_HANDLE_LIST_KHR} is not specified as part of
OK>      _properties_ and one or more devices in _context_ cannot import the
OK>      requested external memory object type.
OK>   * {CL_INVALID_VALUE}
OK>   ** if _properties_ includes a supported external memory handle and _flags_
OK>      includes {CL_MEM_USE_HOST_PTR}, {CL_MEM_ALLOC_HOST_PTR}, or
OK>      {CL_MEM_COPY_HOST_PTR}.
OK>   * {CL_INVALID_HOST_PTR}
OK>   ** if _properties_ includes a supported external memory handle and
OK>      _host_ptr_ is not `NULL`.
OK>   * {CL_INVALID_PROPERTY}
OK>   ** if _properties_ does not include a supported external memory handle and
OK>      {CL_MEM_DEVICE_HANDLE_LIST_KHR} is specified as part of _properties_.
OK> endif::cl_khr_external_memory[]

OK> Add images created from an external memory handle to the description of
OK> _image_row_pitch_ and _image_slice_pitch_ for {cl_image_desc_TYPE}:
OK>
OK>   * _image_row_pitch_ is the scan-line pitch in bytes.
OK>     The _image_row_pitch_ must be zero if _host_ptr_ is `NULL`,
OK> ifdef::cl_khr_external_memory[]
OK>     the image is not an image created from an external memory handle,
OK> endif::cl_khr_external_memory[]
OK>     and the image is not a 2D image created from a buffer,
OK>     If _image_row_pitch_ is zero and _host_ptr_ is not `NULL`, then the
OK>     image row pitch is calculated as _image_width_ {times} the size of an
OK>     image element in bytes.
OK> ifdef::cl_khr_external_memory[]
OK>     If _image_row_pitch_ is zero and the image is created from an external
OK>     memory handle, then the image row pitch is implementation-defined.
OK> endif::cl_khr_external_memory[]
OK>     The image row pitch must be {geq} _image_width_ {times} the size of an
OK>     image element in bytes, and must be a multiple of the size of an image
OK>     element in bytes.
OK>     For a 2D image created from a buffer the image row pitch must also be a
OK>     multiple of the maximum of the {CL_DEVICE_IMAGE_PITCH_ALIGNMENT} value
OK>     for all devices in the context that support images.
OK>   * _image_slice_pitch_ is the size in bytes of each 2D slice in a 3D image,
OK>     or the size in bytes of each image in a 1D or 2D image array.
OK>     The _image_slice_pitch_ must be zero if _host_ptr_ is `NULL`
OK> ifdef::cl_khr_external_memory[]
OK>     and the image is not an image created from an external memory handle,
OK> endif::cl_khr_external_memory[]
OK>     If _image_slice_pitch_ is zero and _host_ptr_ is not `NULL` then the
OK>     image slice pitch is calculated as the image row pitch {times}
OK>     _image_height_ for a 2D image array or a 3D image, and as the image row
OK>     pitch for a 1D image array.
OK> ifdef::cl_khr_external_memory[]
OK>     If _image_slice_pitch_ is zero and the image is created from an external
OK>     memory handle, then the image slice pitch is implementation-defined.
OK> endif::cl_khr_external_memory[]
OK>     The image slice pitch must be {geq} the image image row pitch {times}
OK>     _image_height_ for a 2D image array or a 3D image, must be {geq} the
OK>     image row pitch for a 1D image array, and must be a multiple of the
OK>     image row pitch.

OK> === Description of new types added by this spec
OK>
OK> The following new APIs are added as part of this spec.
OK> The details of each are described below:


OK> ==== Acquiring and Releasing External Memory Objects
OK>
OK> [open,refpage='clEnqueueAcquireExternalMemObjectsKHR',desc='Enqueue a command to acquire OpenCL memory objects created from external memory handles',type='protos']
OK> --
OK> To enqueue a command to acquire OpenCL memory objects created from external
OK> memory handles, call the function
OK>
OK> include::{generated}/api/protos/clEnqueueAcquireExternalMemObjectsKHR.txt[]
OK> include::{generated}/api/version-notes/clEnqueueAcquireExternalMemObjectsKHR.asciidoc[]
OK>
OK>   * _command_queue_ specifies a valid command-queue.
OK>   * _num_mem_objects_ specifies the number of memory objects to acquire.
OK>   * _mem_objects_ points to a list of valid memory objects.
OK>   * _num_events_in_wait_list_ specifies the number of events in
OK>     _event_wait_list_.
OK>   * _event_wait_list_ points to the list of events that need to complete
OK>     before {clEnqueueAcquireExternalMemObjectsKHR} can be executed.
OK>     If _event_wait_list_ is `NULL`, then
OK>     {clEnqueueAcquireExternalMemObjectsKHR} does not explicitly wait on any
OK>     event to complete.
OK>     If _event_wait_list_ is `NULL`, _num_events_in_wait_list_ must be 0.
OK>     If _event_wait_list_ is not `NULL`, the list of events pointed to by
OK>     _event_wait_list_ must be valid and _num_events_in_wait_list_ must be
OK>     greater than 0.
OK>     The events specified in _event_wait_list_ act as synchronization points.
OK>     The context associated with events in _event_wait_list_ and that of
OK>     _command_queue_ must be the same.
OK>   * _event_ returns an event object that identifies this particular command
OK>     and can be used to query or queue a wait for this particular command to
OK>     complete.
OK>     _event_ can be `NULL` in which case it will not be possible for the
OK>     application to query the status of this command or queue a wait for this
OK>     command to complete.
OK>
OK> Applications must acquire the memory objects that are created using external
OK> handles before they can be used by any OpenCL commands queued to a
OK> command-queue.
OK> Behavior is undefined if a memory object created from an external memory
OK> handle is used by an OpenCL command queued to a command-queue without being
OK> acquired.
OK> This is to guarantee that the state of the memory objects is up-to-date and
OK> they are accessible to OpenCL.
OK> See <<cl_khr_external_memory-Sample-Code, "`Example with Acquire /
OK> Release`">> for more details on how to use this API.
OK>
OK> If _num_mem_objects_ is 0 and _mem_objects_ is `NULL`, the command will
OK> trivially succeed after its event dependencies are satisfied and will update
OK> its completion event.
OK>
OK> // refError
OK>
OK> {clEnqueueAcquireExternalMemObjectsKHR} returns {CL_SUCCESS} if the function
OK> is executed successfully.
OK> Otherwise, it returns one of the following errors:
OK>
OK>   * {CL_INVALID_VALUE} if _num_mem_objects_ is zero and _mem_objects_ is not
OK>     a `NULL` value, or if _num_mem_objects_ is greater than 0 and
OK>     _mem_objects_ is `NULL`.
OK>   * {CL_INVALID_MEM_OBJECT} if any of the memory objects in _mem_objects_ is
OK>     not a valid OpenCL memory object created using an external memory
OK>     handle.
OK>   * {CL_INVALID_COMMAND_QUEUE}
OK>   ** if _command_queue_ is not a valid command-queue, or
OK>   ** if device associated with _command_queue_ is not one of the devices
OK>      specified by {CL_MEM_DEVICE_HANDLE_LIST_KHR} at the time of creating
OK>      one or more of _mem_objects_, or ** if one or more of _mem_objects_
OK>      belong to a context that does not contain a device associated with
OK>      _command_queue_.
OK>   * {CL_INVALID_EVENT_WAIT_LIST}
OK>   ** if _event_wait_list_ is `NULL` and _num_events_in_wait_list_ is not 0,
OK>      or
OK>   ** if _event_wait_list_ is not `NULL` and _num_events_in_wait_list_ is 0,
OK>      or
OK>   ** if event objects in _event_wait_list_ are not valid events.
OK>   * {CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST} if the execution status
OK>     of any of the events in _event_wait_list_ is a negative integer value.
OK>   * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources
OK>     required by the OpenCL implementation on the device.
OK>   * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources
OK>     required by the OpenCL implementation on the host.
OK> --
OK>
OK> [open,refpage='clEnqueueReleaseExternalMemObjectsKHR',desc='Enqueue a command to release OpenCL memory objects created from external memory handles',type='protos']
OK> --
OK> To enqueue a command to release OpenCL memory objects created from external
OK> memory handles, call the function
OK>
OK> include::{generated}/api/protos/clEnqueueReleaseExternalMemObjectsKHR.txt[]
OK>
OK>   * _command_queue_ specifies a valid command-queue.
OK>   * _num_mem_objects_ specifies the number of memory objects to release.
OK>   * _mem_objects_ points to a list of valid memory objects.
OK>   * _num_events_in_wait_list_ specifies the number of events in
OK>     _event_wait_list_.
OK>   * _event_wait_list_ points to the list of events that need to complete
OK>     before {clEnqueueReleaseExternalMemObjectsKHR} can be executed.
OK>     If _event_wait_list_ is `NULL`, then
OK>     {clEnqueueReleaseExternalMemObjectsKHR} does not wait on any event to
OK>     complete.
OK>     If _event_wait_list_ is `NULL`, _num_events_in_wait_list_ must be 0.
OK>     If _event_wait_list_ is not `NULL`, the list of events pointed to by
OK>     _event_wait_list_ must be valid and _num_events_in_wait_list_ must be
OK>     greater than 0.
OK>     The events specified in _event_wait_list_ act as synchronization points.
OK>     The context associated with events in _event_wait_list_ and that of
OK>     _command_queue_ must be the same.
OK>   * _event_ returns an event object that identifies this particular command
OK>     and can be used to query or queue a wait for this particular command to
OK>     complete.
OK>     _event_ can be `NULL` in which case it will not be possible for the
OK>     application to query the status of this command or queue a wait for this
OK>     command to complete.
OK>
OK> Applications must release the memory objects that are acquired using
OK> {clEnqueueReleaseExternalMemObjectsKHR} before using them through any
OK> commands in the other API.
OK> This is to guarantee that the state of memory objects is up-to-date and they
OK> are accessible to the other API.
OK> See "`Example with Acquire / Release`" provided in
OK> <<cl_khr_external_memory-Sample-Code>> for more details on how to use this
OK> API.
OK>
OK> If _num_mem_objects_ is 0 and _mem_objects_ is `NULL`, the command will
OK> trivially succeed after its event dependencies are satisfied and will update
OK> its completion event.
OK>
OK> // refError
OK>
OK> {clEnqueueReleaseExternalMemObjectsKHR} returns {CL_SUCCESS} if the function
OK> is executed successfully.
OK> Otherwise, it returns one of the following errors:
OK>
OK>   * {CL_INVALID_VALUE} if _num_mem_objects_ is zero and _mem_objects_ is not
OK>     a `NULL` value, or if _num_mem_objects_ is greater than 0 and
OK>     _mem_objects_ is `NULL`.
OK>   * {CL_INVALID_MEM_OBJECT} if any of the memory objects in _mem_objects_ is
OK>     not a valid OpenCL memory object created using an external memory
OK>     handle.
OK>   * {CL_INVALID_COMMAND_QUEUE}
OK>   ** if _command_queue_ is not a valid command-queue, or
OK>   ** if device associated with _command_queue_ is not one of the devices
OK>      specified by {CL_MEM_DEVICE_HANDLE_LIST_KHR} at the time of creating
OK>      one or more of _mem_objects_, or
OK>   ** if one or more of _mem_objects_ belong to a context that does not
OK>      contain a device associated with _command_queue_.
OK>   * {CL_INVALID_EVENT_WAIT_LIST}
OK>   ** if _event_wait_list_ is `NULL` and _num_events_in_wait_list_ is not 0,
OK>      or
OK>   ** if _event_wait_list_ is not `NULL` and _num_events_in_wait_list_ is 0,
OK>      or
OK>   ** if event objects in _event_wait_list_ are not valid events.
OK>   * {CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST} if the execution status
OK>     of any of the events in _event_wait_list_ is a negative integer value.
OK>   * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources
OK>     required by the OpenCL implementation on the device.
OK>   * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources
OK>     required by the OpenCL implementation on the host.
OK> --
OK>
OK> === Descriptions of External Memory Handle Types
OK>
OK> This section describes the external memory handle types that are added by
OK> related extensions.
OK>
OK> Applications can import the same payload into multiple OpenCL contexts and
OK> multiple times into a given OpenCL context. In all cases, each import
OK> operation must create a distinct memory object.
OK>
OK> ==== File Descriptor Handle Types
OK>
OK> The `<<cl_khr_external_memory_opaque_fd>>` extension extends
OK> {cl_external_memory_handle_type_khr_TYPE} to support the following new types
OK> of handles, and adds as a property that may be specified when creating a
OK> buffer or an image memory object from an external handle:
OK>
OK> --
OK>   * {CL_EXTERNAL_MEMORY_HANDLE_OPAQUE_FD_KHR} specifies a POSIX file
OK>     descriptor handle that has only limited valid usage outside of OpenCL
OK>     and other compatible APIs.
OK>     It must be compatible with the POSIX system calls dup, dup2, close, and
OK>     the non-standard system call dup3.
OK>     Additionally, it must be transportable over a socket using an SCM_RIGHTS
OK>     control message.
OK>     It owns a reference to the underlying memory resource represented by its
OK>     memory object.
OK> --
OK>
OK> The `<<cl_khr_external_memory_dma_buf>>` extension extends
OK> {cl_external_memory_handle_type_khr_TYPE} to support the following types of
OK> handles, and adds as a property that may be specified when creating a buffer
OK> or an image memory object from an external handle:
OK>
OK> --
OK>   * {CL_EXTERNAL_MEMORY_HANDLE_DMA_BUF_KHR} is a file descriptor for a Linux
OK>     dma_buf.
OK>     It owns a reference to the underlying memory resource represented by its
OK>     memory object.
OK> --
OK>
OK> For these extensions, importing memory from a file descriptor transfers
OK> ownership of the file descriptor from the application to the OpenCL
OK> implementation.
OK> The application must not perform any operations on the file descriptor after
OK> a successful import.
OK> The imported memory object holds a reference to its payload.
OK>
OK> ==== NT Handle Types
OK>
OK> The `<<cl_khr_external_memory_dx>>` extension extends
OK> {cl_external_memory_handle_type_khr_TYPE} to support the following new types
OK> of handles, and adds as a property that may be specified when creating a
OK> buffer or an image memory object from an external handle:
OK>
OK> --
OK>   * {CL_EXTERNAL_MEMORY_HANDLE_D3D11_TEXTURE_KHR} specifies an NT handle
OK>     returned by `IDXGIResource1::CreateSharedHandle` referring to a Direct3D
OK>     10 or 11 texture resource.
OK>     It owns a reference to the memory used by the Direct3D resource.
OK>   * {CL_EXTERNAL_MEMORY_HANDLE_D3D11_TEXTURE_KMT_KHR} specifies a global
OK>     share handle returned by `IDXGIResource::GetSharedHandle` referring to a
OK>     Direct3D 10 or 11 texture resource.
OK>     It does not own a reference to the underlying Direct3D resource, and
OK>     will therefore become invalid when all memory objects and Direct3D
OK>     resources associated with it are destroyed.
OK>   * {CL_EXTERNAL_MEMORY_HANDLE_D3D12_HEAP_KHR} specifies an NT handle
OK>     returned by `ID3D12Device::CreateSharedHandle` referring to a Direct3D
OK>     12 heap resource.
OK>     It owns a reference to the resources used by the Direct3D heap.
OK>   * {CL_EXTERNAL_MEMORY_HANDLE_D3D12_RESOURCE_KHR} specifies an NT handle
OK>     returned by `ID3D12Device::CreateSharedHandle` referring to a Direct3D
OK>     12 committed resource.
OK>     It owns a reference to the memory used by the Direct3D resource.
OK> --
OK>
OK> The `<<cl_khr_external_memory_win32>>` extension extends
OK> {cl_external_memory_handle_type_khr_TYPE} to support the following new types
OK> of handles, and adds as a property that may be specified when creating a
OK> buffer or an image memory object from an external handle:
OK>
OK> --
OK>   * {CL_EXTERNAL_MEMORY_HANDLE_OPAQUE_WIN32_KHR} specifies an NT handle that
OK>     has only limited valid usage outside of OpenCL and other compatible
OK>     APIs.
OK>     It must be compatible with the functions `DuplicateHandle`,
OK>     `CloseHandle`, `CompareObjectHandles`, `GetHandleInformation`, and
OK>     `SetHandleInformation`.
OK>     It owns a reference to the underlying memory resource represented by its
OK>     memory object.
OK>   * {CL_EXTERNAL_MEMORY_HANDLE_OPAQUE_WIN32_KMT_KHR} specifies a global
OK>     share handle that has only limited valid usage outside of OpenCL and
OK>     other compatible APIs.
OK>     It is not compatible with any native APIs.
OK>     It does not own a reference to the underlying memory resource
OK>     represented by its memory object, and will therefore become invalid when
OK>     all memory objects associated with it are destroyed.
OK> --
OK>
OK> For these extensions, importing memory object payloads from Windows handles
OK> does not transfer ownership of the handle to the OpenCL implementation.
OK> For handle types defined as NT handles, the application must release handle
OK> ownership using the CloseHandle system call when the handle is no longer
OK> needed.
OK> For handle types defined as NT handles, the imported memory object holds a
OK> reference to its payload.
OK>
OK> Note: Non-NT handle import operations do not add a reference to their
OK> associated payload.
OK> If the original object owning the payload is destroyed, all resources and
OK> handles sharing that payload will become invalid.


OK> [[cl_khr_external_memory-Sample-Code]]
OK> === Sample Code
OK>
OK> . Example for creating a CL buffer from an exported external buffer in a single device context.
OK> +
OK> --
OK> [source]
OK> ----
OK> // Get cl_devices of the platform.
OK> clGetDeviceIDs(..., &devices, &deviceCount);
OK>
OK> // Create cl_context with just first device
OK> clCreateContext(..., 1, devices, ...);
OK>
OK> // Obtain fd/win32 or similar handle for external memory to be imported
OK> // from other API.
OK> int fd = getFdForExternalMemory();
OK>
OK> // Create extMemBuffer of type cl_mem from fd.
OK> cl_mem_properties_khr extMemProperties[] =
OK> {
OK>     (cl_mem_properties_khr)CL_EXTERNAL_MEMORY_HANDLE_OPAQUE_FD_KHR,
OK>     (cl_mem_properties_khr)fd,
OK>     0
OK> };
OK>
OK> cl_mem extMemBuffer = clCreateBufferWithProperties(/*context*/          clContext,
OK>                                                    /*properties*/       extMemProperties,
OK>                                                    /*flags*/            0,
OK>                                                    /*size*/             size,
OK>                                                    /*host_ptr*/         NULL,
OK>                                                    /*errcode_ret*/      &errcode_ret);
OK> ----
OK> --
OK> . Example for creating a CL Image from an exported external Image for single device usage in a multi-device context
OK> +
OK> --
OK> [source]
OK> ----
OK> // Get cl_devices of the platform.
OK> clGetDeviceIDs(..., &devices, &deviceCount);
OK>
OK> // Create cl_context with first two devices
OK> clCreateContext(..., 2, devices, ...);
OK>
OK> // Create img of type cl_mem usable only on devices[0]
OK>
OK> // Create img of type cl_mem.
OK> // Obtain fd/win32 or similar handle for external memory to be imported
OK> // from other API.
OK> int fd = getFdForExternalMemory();
OK>
OK> // Set cl_image_format based on external image info
OK> cl_image_format clImgFormat = { };
OK> clImageFormat.image_channel_order = CL_RGBA;
OK> clImageFormat.image_channel_data_type = CL_UNORM_INT8;
OK>
OK> // Set cl_image_desc based on external image info
OK> size_t clImageFormatSize;
OK> cl_image_desc image_desc = { };
OK> image_desc.image_type = CL_MEM_OBJECT_IMAGE2D_ARRAY;
OK> image_desc.image_width = width;
OK> image_desc.image_height = height;
OK> image_desc.image_depth = depth;
OK> image_desc.image_array_size = num_slices;
OK> image_desc.image_row_pitch = width * 8 * 4; // May need alignment
OK> image_desc.image_slice_pitch = image_desc.image_row_pitch * height;
OK> image_desc.num_mip_levels = 1;
OK> image_desc.num_samples = 0;
OK> image_desc.buffer = NULL;
OK>
OK> cl_mem_properties_khr extMemProperties[] = {
OK>     (cl_mem_properties_khr)CL_EXTERNAL_MEMORY_HANDLE_OPAQUE_FD_KHR,
OK>     (cl_mem_properties_khr)fd,
OK>     (cl_mem_properties_khr)CL_MEM_DEVICE_HANDLE_LIST_KHR,
OK>     (cl_mem_properties_khr)devices[0],
OK>     CL_MEM_DEVICE_HANDLE_LIST_END_KHR,
OK>     0
OK> };
OK>
OK> cl_mem img = clCreateImageWithProperties(/*context*/        clContext,
OK>                                          /*properties*/     extMemProperties,
OK>                                          /*flags*/          0,
OK>                                          /*image_format*/   &clImgFormat,
OK>                                          /*image_desc*/     &image_desc,
OK>                                          /*errcode_ret*/    &errcode_ret);
OK>
OK> // Use clGetImageInfo to get cl_image_format details.
OK> size_t clImageFormatSize;
OK> clGetImageInfo(img,
OK>                CL_IMAGE_FORMAT,
OK>                sizeof(cl_image_format),
OK>                &clImageFormat,
OK>                &clImageFormatSize);
OK> ----
OK> --
OK> . Example for synchronization using Wait and Signal
OK> +
OK> --
OK> [source]
OK> ----
OK> // Start the main rendering loop
OK>
OK> // Create extSem of type cl_semaphore_khr using clCreateSemaphoreWithPropertiesKHR
OK>
OK> // Create extMem of type cl_mem using clCreateBufferWithProperties or clCreateImageWithProperties
OK>
OK> while (true) {
OK>     // (not shown) Signal the semaphore from the other API
OK>
OK>     // Wait for the semaphore in OpenCL, by calling clEnqueueWaitSemaphoresKHR on 'extSem'
OK>     clEnqueueWaitSemaphoresKHR(/*command_queue*/            command_queue,
OK>                                /*num_sema_objects*/         1,
OK>                                /*sema_objects*/             &extSem,
OK>                                /*sema_payload_list*/        NULL,
OK>                                /*num_events_in_wait_list*/  0,
OK>                                /*event_wait_list*/          NULL,
OK>                                /*event*/                    NULL);
OK>
OK>     // Launch kernel that accesses extMem
OK>     clEnqueueNDRangeKernel(command_queue, ...);
OK>
OK>     // Signal the semaphore in OpenCL
OK>     clEnqueueSignalSemaphoresKHR(/*command_queue*/           command_queue,
OK>                                  /*num_sema_objects*/        1,
OK>                                  /*sema_objects*/            &extSem,
OK>                                  /*sema_payload_list*/       NULL,
OK>                                  /*num_events_in_wait_list*/ 0,
OK>                                  /*event_wait_list*/         NULL,
OK>                                  /*event*/                   NULL);
OK>
OK>     // (not shown) Launch work in other API that waits on 'extSem'
OK> }
OK> ----
OK> --
OK> . Example with memory sharing using acquire/release
OK> +
OK> --
OK> [source]
OK> ----
OK> // Create extSem of type cl_semaphore_khr using
OK> // clCreateSemaphoreWithPropertiesKHR with CL_SEMAPHORE_HANDLE_*_KHR.
OK>
OK> // Create extMem1 and extMem2 of type cl_mem using clCreateBufferWithProperties
OK> // or clCreateImageWithProperties
OK>
OK> while (true) {
OK>     // (not shown) Signal the semaphore from the other API. Wait for the
OK>     // semaphore in OpenCL, by calling clEnqueueWaitForSemaphore on extSem
OK>     clEnqueueWaitSemaphoresKHR(/*command_queue*/            cq1,
OK>                                /*num_sema_objects*/         1,
OK>                                /*sema_objects*/             &extSem,
OK>                                /*sema_payload_list*/        NULL,
OK>                                /*num_events_in_wait_list*/  0,
OK>                                /*event_wait_list*/          NULL,
OK>                                /*event*/                    NULL);
OK>
OK>     // Get explicit ownership of extMem1
OK>     clEnqueueAcquireExternalMemObjectsKHR(/*command_queue*/             cq1,
OK>                                           /*num_mem_objects*/           1,
OK>                                           /*mem_objects*/               extMem1,
OK>                                           /*num_events_in_wait_list*/   0,
OK>                                           /*event_wait_list*/           NULL,
OK>                                           /*event*/                     NULL);
OK>
OK>     // Launch kernel that accesses extMem1 on cq1 on cl_device1
OK>     clEnqueueNDRangeKernel(cq1,  ..., &event1);
OK>
OK>     // Launch kernel that accesses both extMem1 and extMem2 on cq2 on cl_device2
OK>     // Migration of extMem1 and extMem2 handles through regular CL memory
OK>     // migration.
OK>     clEnqueueNDRangeKernel(cq2, ..., &event1, &event2);
OK>
OK>     // Give up ownership of extMem1 before you signal the semaphore. Handle
OK>     // memory migration here.
OK>     clEnqueueReleaseExternalMemObjectsKHR(/*command_queue*/           cq2
OK>                                           /*num_mem_objects*/         1,
OK>                                           /*mem_objects*/             &extMem1,
OK>                                           /*num_events_in_wait_list*/ 0,
OK>                                           /*event_wait_list*/         NULL,
OK>                                           /*event*/                   NULL);
OK>
OK>     // Signal the semaphore from OpenCL
OK>     clEnqueueSignalSemaphoresKHR(/*command_queue*/           cq2,
OK>                                  /*num_sema_objects*/        1,
OK>                                  /*sema_objects*/            &extSem,
OK>                                  /*sema_payload_list*/       NULL,
OK>                                  /*num_events_in_wait_list*/ 0,
OK>                                  /*event_wait_list*/         NULL,
OK>                                  /*event*/                   NULL);
OK>
OK>     // (not shown) Launch work in other API that waits on 'extSem'
OK>     // Other API accesses ext1, but not ext2 on device-1
OK> }
OK> ----
OK> --
OK>
OK>
OK> === Issues
OK>
OK> . How should the import of images that are created in external APIs with non-linear tiling be robustly handled?
OK> +
OK> --
OK> *UNRESOLVED*
OK> --
