DONE, updated for 0.9.4 as of 2023-10-26

OK> // Copyright 2018-2023 The Khronos Group. This work is licensed under a
OK> // Creative Commons Attribution 4.0 International License; see
OK> // http://creativecommons.org/licenses/by/4.0/
OK>
OK> [[cl_khr_command_buffer]]
OK> == Command Buffers (Provisional)
OK>
OK> This extension adds the ability to record and replay buffers of OpenCL commands.
OK>
OK> === General Information
OK>
OK> ==== Name Strings
OK>
OK> `cl_khr_command_buffer`
OK>
OK> ==== Version History
OK>
OK> [cols="1,1,3",options="header",]
OK> |====
OK> | *Date*     | *Version* | *Description*
OK> | 2021-11-10 | 0.9.0     | First assigned version (provisional).
OK> | 2022-08-24 | 0.9.1     | Specify an error if a command-buffer is finalized multiple times (provisional).
OK> | 2023-03-31 | 0.9.2     | Introduce context query {CL_COMMAND_BUFFER_CONTEXT_KHR} (provisional).
OK> | 2023-04-04 | 0.9.3     | Remove Invalid command-buffer state (provisional).
OK> | 2023-05-11 | 0.9.4     | Add clCommandSVMMemcpyKHR and clCommandSVMMemFillKHR command entries (provisional).
OK> |====
OK>
OK> ==== Dependencies
OK>
OK> This extension is written against the OpenCL Specification version 3.0.6.
OK>
OK> This extension requires OpenCL 1.2 or later. Buffering of SVM commands
OK> requires OpenCL 2.0 or later.
OK>
OK> ==== Contributors
OK>
OK> Ewan Crawford, Codeplay Software Ltd. +
OK> Gordon Brown, Codeplay Software Ltd. +
OK> Kenneth Benzie, Codeplay Software Ltd. +
OK> Alastair Murray, Codeplay Software Ltd. +
OK> Jack Frankland, Codeplay Software Ltd. +
OK> Balaji Calidas, Qualcomm Technologies Inc. +
OK> Joshua Kelly, Qualcomm Technologies, Inc. +
OK> Kevin Petit, Arm Ltd. +
OK> Aharon Abramson, Intel. +
OK> Ben Ashbaugh, Intel. +
OK> Boaz Ouriel, Intel. +
OK> Chris Gearing, Intel. +
OK> Pekka Jääskeläinen, Tampere University and Intel. +
OK> Jan Solanti, Tampere University +
OK> Nikhil Joshi, NVIDIA +
OK> James Price, Google +
OK> Brice Videau, Argonne National Laboratory +
OK>
OK> === Overview
OK>
OK> Command-buffers enable a reduction in overhead when enqueuing the same
OK> workload multiple times. By separating the command-queue setup from dispatch,
OK> the ability to replay a set of previously created commands is introduced.
OK>
OK> Device-side _cl_sync_point_khr_ synchronization-points can be used within
OK> command-buffers to define command dependencies. This allows the commands of a
OK> command-buffer to execute out-of-order on a single <<compatible, compatible>>
OK> command-queue. The command-buffer itself has no inherent in-order/out-of-order
OK> property, this ordering is inferred from the command-queue used on command
OK> recording. Out-of-order enqueues without event dependencies of both regular
OK> commands, such as {clEnqueueFillBuffer}, and command-buffers are allowed to
OK> execute concurrently, and it is up to the user to express any dependencies using
OK> events.
OK>
OK> The command-queues a command-buffer will be executed on can be set on replay via
OK> parameters to {clEnqueueCommandBufferKHR}, provided they are
OK> <<compatible, compatible>> with the command-queues used on command-buffer
OK> recording.
OK>
OK> ==== Background
OK>
OK> On embedded devices where building a command stream accounts for a significant
OK> expenditure of resources and where workloads are often required to be pipelined,
OK> a solution that minimizes driver overhead can significantly improve the
OK> utilization of accelerators by removing a bottleneck in repeated command stream
OK> generation.
OK>
OK> An additional motivator is lowering task execution latency, as devices can be
OK> kept occupied with work by repeated submissions, without having to wait on
OK> the host to construct commands again for a similar workload.
OK>
OK> ==== Rationale
OK>
OK> The command-buffer abstraction over the generation of command streams is a
OK> proven approach which facilitates a significant reduction in driver overhead in
OK> existing real-world applications with repetitive pipelined workloads which are
OK> built on top of Vulkan, DirectX 12, and Metal.
OK>
OK> A primary goal is for a command-buffer to avoid any interaction with
OK> application code after being enqueued until all recorded commands have
OK> completed. As such, any command which maps or migrates memory objects; reads
OK> or writes memory objects; or enqueues a native kernel, is not available for
OK> command-buffer recording. Finally commands recorded into a command buffer do
OK> not wait for or return event objects, these are instead replaced with
OK> device-side synchronization-point identifiers which enable out-of-order
OK> execution when enqueued on <<compatible, compatible>> command-queues.
OK>
OK> Adding new entry-points for individual commands, rather than recording existing
OK> command-queue APIs with begin/end markers was a design decision made for the
OK> following reasons:
OK>
OK> * Individually specified entry points makes it clearer to the user what's
OK>   supported, as opposed to adding a large number of error conditions
OK>   throughout the specification with all the restrictions.
OK>
OK> * Prevents code forking in existing entry points for the implementer, as
OK>   otherwise separate paths in each entry point need to be maintained for both
OK>   the recording and normal cases.
OK>
OK> * Allows the definition of a new device-side synchronization primitive rather
OK>   than overloading {cl_event_TYPE}. As use of {cl_event_TYPE} in individual commands
OK>   allows host interaction from callback and user-events, as well as introducing
OK>   complexities when a command-buffer is enqueued multiple times regarding
OK>   profiling and execution status.
OK>
OK> * New entry points facilitate returning handles to individual commands, allowing
OK>   those commands to be modified between enqueues of the command buffer. Not all
OK>   command handles are used in this extension, but providing them facilitates
OK>   other extensions layered on top to take advantage of them to provide additional
OK>   mutable functionality.
OK>
OK> ==== Simultaneous Use
OK>
OK> The optional simultaneous use capability was added to the extension so that
OK> vendors can support pipelined workflows, where command-buffers are repeatedly
OK> enqueued without blocking in user code. However, simultaneous use may result in
OK> command-buffers being more expensive to enqueue than in a sequential model, so
OK> the capability is optional to enable optimizations on command-buffer recording.
OK>
OK> === Interactions with Other Extensions
OK>
OK> The introduction of the command-buffer abstraction enables functionality
OK> beyond what the `cl_khr_command_buffer` extension currently provides, i.e.
OK> the recording of immutable commands to a single queue which can then be
OK> executed without commands synchronizing outside the command-buffer. It is
OK> intended that extra functionality expanding on this will be provided as layered
OK> extensions on top of `cl_khr_command_buffer`.
OK>
OK> Having `cl_khr_command_buffer` as a minimal base specification means that the
OK> API defines mechanisms for functionality that is not enabled by this extension,
OK> these are described in the following sub-sections. `cl_khr_command_buffer` will
OK> retain its provisional extension status until other layered extensions are
OK> released, as these may reveal modifications needed to the base specification to
OK> support their intended use cases.
OK>
OK> ==== ND-range Kernel Command Properties
OK>
OK> The {clCommandNDRangeKernelKHR} entry-point defines a `properties` parameter of
OK> new type {cl_ndrange_kernel_command_properties_khr_TYPE}. No properties are defined
OK> in `cl_khr_command_buffer`, but the parameter is intended to enable future
OK> functionality that would change the characteristics of the kernel command.
OK>
OK> ==== Command Handles
OK>
OK> All command recording entry-points define a {cl_mutable_command_khr_TYPE} output
OK> parameter which provides a handle to the specific command being recorded. Use of
OK> these output handles is not enabled by the `cl_khr_command_buffer` extension,
OK> but the handles will allow individual commands in a command-buffer to be
OK> referenced by the user. In particular, the capability for an application to use
OK> these handles to modify commands between enqueues of a command-buffer is
OK> envisaged.
OK>
OK> ==== List of Queues
OK>
OK> Only a single command-queue can be associated with a command-buffer in the
OK> `cl_khr_command_buffer` extension, but the API is designed with the intention
OK> that a future extension will allow commands to be recorded across multiple
OK> queues in the same command-buffer, providing replay of heterogeneous task
OK> graphs.
OK>
OK> Using multiple queue functionality will result in an error without any layered
OK> extensions to relax usage of the following API features:
OK>
OK> * When a command-buffer is created the API enables passing a list of queues
OK>   that the command-buffer will record commands to. Only a single queue is
OK>   permitted in `cl_khr_command_buffer`.
OK>
OK> * Individual command recording entry-points define a {cl_command_queue_TYPE}
OK>   parameter for which of the queues set on command-buffer creation that command
OK>   should be record to. This must be passed as NULL in `cl_khr_command_buffer`.
OK>
OK> * {clEnqueueCommandBufferKHR} takes a list of queues for command-buffer execution,
OK>   correspond to those set on creation. Only a single queue is permitted in
OK>   `cl_khr_command_buffer`.
OK>
OK> === New Types
OK>
OK> ====  Command Buffer Types
OK>
OK> Bitfield for querying command-buffer capabilities of an OpenCL device with
OK> {clGetDeviceInfo}, see <<command-buffer-queries, device queries table>>:
OK> [source]
OK> ----
OK> typedef cl_bitfield cl_device_command_buffer_capabilities_khr
OK> ----
OK>
OK> Types describing <<command-buffers, command-buffers>>:
OK>
OK> [source]
OK> ----
OK> // Returned by clCreateCommandBufferKHR()
OK> typedef struct _cl_command_buffer_khr* cl_command_buffer_khr;
OK>
OK> // Unique ID to a device-side synchronization-point used to describe the
OK> // ordering of commands when recording a command-buffer. Valid for use
OK> // only within the same command-buffer during recording.
OK> typedef cl_uint cl_sync_point_khr;
OK>
OK> // Handle returned on command recording
OK> typedef struct _cl_mutable_command_khr* cl_mutable_command_khr;
OK>
OK> // Properties of a clCommandNDRangeKernelKHR command
OK> typedef cl_properties cl_ndrange_kernel_command_properties_khr;
OK>
OK> // Properties for command-buffer creation
OK> typedef cl_properties cl_command_buffer_properties_khr;
OK>
OK> // Bitfield representing flags for command-buffers
OK> typedef cl_bitfield cl_command_buffer_flags_khr;
OK>
OK> // Enumerated type for use in clGetCommandBufferInfoKHR()
OK> typedef cl_uint cl_command_buffer_info_khr;
OK>
OK> // Return type for CL_COMMAND_BUFFER_STATE_KHR in clGetCommandBufferInfoKHR()
OK> typedef cl_uint cl_command_buffer_state_khr;
OK> ----
OK>
OK> === New API Functions
OK>
OK> Command-buffer entry points from <<command-buffers, Section 5.X>>:
OK> [source]
OK> ----
OK> cl_command_buffer_khr clCreateCommandBufferKHR(
OK>     cl_uint num_queues,
OK>     const cl_command_queue* queues,
OK>     const cl_command_buffer_properties_khr* properties,
OK>     cl_int* errcode_ret);
OK>
OK> cl_int clRetainCommandBufferKHR(cl_command_buffer_khr command_buffer);
OK>
OK> cl_int clReleaseCommandBufferKHR(cl_command_buffer_khr command_buffer);
OK>
OK> cl_int clFinalizeCommandBufferKHR(cl_command_buffer_khr command_buffer);
OK>
OK> cl_int clEnqueueCommandBufferKHR(
OK>     cl_uint num_queues,
OK>     cl_command_queue* queues,
OK>     cl_command_buffer_khr command_buffer,
OK>     cl_uint num_events_in_wait_list,
OK>     const cl_event* event_wait_list,
OK>     cl_event* event);
OK>
OK> cl_int clCommandBarrierWithWaitListKHR(
OK>     cl_command_buffer_khr command_buffer,
OK>     cl_command_queue command_queue,
OK>     cl_uint num_sync_points_in_wait_list,
OK>     const cl_sync_point_khr* sync_point_wait_list,
OK>     cl_sync_point_khr* sync_point,
OK>     cl_mutable_command_khr* mutable_handle);
OK>
OK> cl_int clCommandCopyBufferKHR(
OK>     cl_command_buffer_khr command_buffer,
OK>     cl_command_queue command_queue,
OK>     cl_mem src_buffer,
OK>     cl_mem dst_buffer,
OK>     size_t src_offset,
OK>     size_t dst_offset,
OK>     size_t size,
OK>     cl_uint num_sync_points_in_wait_list,
OK>     const cl_sync_point_khr* sync_point_wait_list,
OK>     cl_sync_point_khr* sync_point,
OK>     cl_mutable_command_khr* mutable_handle);
OK>
OK> cl_int clCommandCopyBufferRectKHR(
OK>     cl_command_buffer_khr command_buffer,
OK>     cl_command_queue command_queue,
OK>     cl_mem src_buffer,
OK>     cl_mem dst_buffer,
OK>     const size_t* src_origin,
OK>     const size_t* dst_origin,
OK>     const size_t* region,
OK>     size_t src_row_pitch,
OK>     size_t src_slice_pitch,
OK>     size_t dst_row_pitch,
OK>     size_t dst_slice_pitch,
OK>     cl_uint num_sync_points_in_wait_list,
OK>     const cl_sync_point_khr* sync_point_wait_list,
OK>     cl_sync_point_khr* sync_point,
OK>     cl_mutable_command_khr* mutable_handle);
OK>
OK> cl_int clCommandCopyBufferToImageKHR(
OK>     cl_command_buffer_khr command_buffer,
OK>     cl_command_queue command_queue,
OK>     cl_mem src_buffer,
OK>     cl_mem dst_image,
OK>     size_t src_offset,
OK>     const size_t* dst_origin,
OK>     const size_t* region,
OK>     cl_uint num_sync_points_in_wait_list,
OK>     const cl_sync_point_khr* sync_point_wait_list,
OK>     cl_sync_point_khr* sync_point,
OK>     cl_mutable_command_khr* mutable_handle);
OK>
OK> cl_int clCommandCopyImageKHR(
OK>     cl_command_buffer_khr command_buffer,
OK>     cl_command_queue command_queue,
OK>     cl_mem src_image,
OK>     cl_mem dst_image,
OK>     const size_t* src_origin,
OK>     const size_t* dst_origin,
OK>     const size_t* region,
OK>     cl_uint num_sync_points_in_wait_list,
OK>     const cl_sync_point_khr* sync_point_wait_list,
OK>     cl_sync_point_khr* sync_point,
OK>     cl_mutable_command_khr* mutable_handle);
OK>
OK> cl_int clCommandCopyImageToBufferKHR(
OK>     cl_command_buffer_khr command_buffer,
OK>     cl_command_queue command_queue,
OK>     cl_mem src_image,
OK>     cl_mem dst_buffer,
OK>     const size_t* src_origin,
OK>     const size_t* region,
OK>     size_t dst_offset,
OK>     cl_uint num_sync_points_in_wait_list,
OK>     const cl_sync_point_khr* sync_point_wait_list,
OK>     cl_sync_point_khr* sync_point,
OK>     cl_mutable_command_khr* mutable_handle);
OK>
OK> cl_int clCommandFillBufferKHR(
OK>     cl_command_buffer_khr command_buffer,
OK>     cl_command_queue command_queue,
OK>     cl_mem buffer,
OK>     const void* pattern,
OK>     size_t pattern_size,
OK>     size_t offset,
OK>     size_t size,
OK>     cl_uint num_sync_points_in_wait_list,
OK>     const cl_sync_point_khr* sync_point_wait_list,
OK>     cl_sync_point_khr* sync_point,
OK>     cl_mutable_command_khr* mutable_handle);
OK>
OK> cl_int clCommandFillImageKHR(
OK>     cl_command_buffer_khr command_buffer,
OK>     cl_command_queue command_queue,
OK>     cl_mem image,
OK>     const void* fill_color,
OK>     const size_t* origin,
OK>     const size_t* region,
OK>     cl_uint num_sync_points_in_wait_list,
OK>     const cl_sync_point_khr* sync_point_wait_list,
OK>     cl_sync_point_khr* sync_point,
OK>     cl_mutable_command_khr* mutable_handle);
OK>
OK> cl_int clCommandNDRangeKernelKHR(
OK>     cl_command_buffer_khr command_buffer,
OK>     cl_command_queue command_queue,
OK>     const cl_ndrange_kernel_command_properties_khr* properties,
OK>     cl_kernel kernel,
OK>     cl_uint work_dim,
OK>     const size_t* global_work_offset,
OK>     const size_t* global_work_size,
OK>     const size_t* local_work_size,
OK>     cl_uint num_sync_points_in_wait_list,
OK>     const cl_sync_point_khr* sync_point_wait_list,
OK>     cl_sync_point_khr* sync_point,
OK>     cl_mutable_command_khr* mutable_handle);
OK>
OK> cl_int clGetCommandBufferInfoKHR(
OK>     cl_command_buffer_khr command_buffer,
OK>     cl_command_buffer_info_khr param_name,
OK>     size_t param_value_size,
OK>     void* param_value,
OK>     size_t* param_value_size_ret);
OK> ----
OK>
OK> The following SVM entry points are supported only with at least OpenCL 2.0 and
OK> starting from 0.9.4 of this extension:
OK>
OK> [source]
OK> ----
OK>
OK> cl_int clCommandSVMMemcpyKHR(
OK>     cl_command_buffer_khr command_buffer,
OK>     cl_command_queue command_queue,
OK>     void* dst_ptr,
OK>     const void* src_ptr,
OK>     size_t size,
OK>     cl_uint num_sync_points_in_wait_list,
OK>     const cl_sync_point_khr* sync_point_wait_list,
OK>     cl_sync_point_khr* sync_point,
OK>     cl_mutable_command_khr* mutable_handle);
OK>
OK> cl_int clCommandSVMMemFillKHR(
OK>     cl_command_buffer_khr command_buffer,
OK>     cl_command_queue command_queue,
OK>     void* svm_ptr,
OK>     const void* pattern,
OK>     size_t pattern_size,
OK>     size_t size,
OK>     cl_uint num_sync_points_in_wait_list,
OK>     const cl_sync_point_khr* sync_point_wait_list,
OK>     cl_sync_point_khr* sync_point,
OK>     cl_mutable_command_khr* mutable_handle);
OK> ----
OK>
OK>
OK> === New API Enums
OK>
OK> Enums for querying device command-buffer capabilities with
OK> {clGetDeviceInfo}, see <<command-buffer-queries, device queries table>>:
OK>
OK> [source]
OK> ----
OK> // Accepted values for the param_name parameter to clGetDeviceInfo
OK> CL_DEVICE_COMMAND_BUFFER_CAPABILITIES_KHR              0x12A9
OK> CL_DEVICE_COMMAND_BUFFER_REQUIRED_QUEUE_PROPERTIES_KHR 0x12AA
OK>
OK> // Bits for cl_device_command_buffer_capabilities_khr bitfield
OK> CL_COMMAND_BUFFER_CAPABILITY_KERNEL_PRINTF_KHR        (0x1 << 0)
OK> CL_COMMAND_BUFFER_CAPABILITY_DEVICE_SIDE_ENQUEUE_KHR  (0x1 << 1)
OK> CL_COMMAND_BUFFER_CAPABILITY_SIMULTANEOUS_USE_KHR     (0x1 << 2)
OK> CL_COMMAND_BUFFER_CAPABILITY_OUT_OF_ORDER_KHR         (0x1 << 3)
OK>
OK> // Values for cl_command_buffer_state_khr
OK> CL_COMMAND_BUFFER_STATE_RECORDING_KHR              0x0
OK> CL_COMMAND_BUFFER_STATE_EXECUTABLE_KHR             0x1
OK> CL_COMMAND_BUFFER_STATE_PENDING_KHR                0x2
OK> ----
OK>
OK> Enums for base <<command-buffer, command-buffers>> functionality:
OK>
OK> [source]
OK> ----
OK> // Error codes
OK> CL_INVALID_COMMAND_BUFFER_KHR                      -1138
OK> CL_INVALID_SYNC_POINT_WAIT_LIST_KHR                -1139
OK> CL_INCOMPATIBLE_COMMAND_QUEUE_KHR                  -1140
OK>
OK> // Bitfield to clCreateCommandBufferKHR
OK> CL_COMMAND_BUFFER_FLAGS_KHR                        0x1293
OK>
OK> // Bits for cl_command_buffer_flags_khr bitfield
OK> CL_COMMAND_BUFFER_SIMULTANEOUS_USE_KHR             (0x1 << 0)
OK>
OK> // cl_command_buffer_info_khr queries to clGetCommandBufferInfoKHR
OK> CL_COMMAND_BUFFER_QUEUES_KHR                       0x1294
OK> CL_COMMAND_BUFFER_NUM_QUEUES_KHR                   0x1295
OK> CL_COMMAND_BUFFER_REFERENCE_COUNT_KHR              0x1296
OK> CL_COMMAND_BUFFER_STATE_KHR                        0x1297
OK> CL_COMMAND_BUFFER_PROPERTIES_ARRAY_KHR             0x1298
OK> CL_COMMAND_BUFFER_CONTEXT_KHR                      0x1299
OK>
OK> // cl_event command-buffer enqueue command type
OK> CL_COMMAND_COMMAND_BUFFER_KHR                      0x12A8
OK> ----

OK> === Modifications to section 4.2 of the OpenCL API Specification
OK>
OK> Add to *Table 5*, _Device Queries_, of section 4.2:
OK>
OK> [[command-buffer-queries]]
OK> [caption="Table 5. "]
OK> .List of supported param_names by {clGetDeviceInfo}
OK> [cols="1,1,4",options="header"]
OK> |====
OK> | Device Info
OK> | Return Type
OK> | Description
OK>
OK> | {CL_DEVICE_COMMAND_BUFFER_CAPABILITIES_KHR}
OK> | {cl_device_command_buffer_capabilities_khr_TYPE}
OK> | Describes device command-buffer capabilities, encoded as bits in a bitfield.
OK>   Supported capabilities are:
OK>
OK>   {CL_COMMAND_BUFFER_CAPABILITY_KERNEL_PRINTF_KHR} Device supports the ability
OK>   to record commands that execute kernels which contain printf calls.
OK>
OK>   {CL_COMMAND_BUFFER_CAPABILITY_DEVICE_SIDE_ENQUEUE_KHR} Device supports the
OK>   ability to record commands that execute kernels which contain device-side
OK>   kernel-enqueue calls.
OK>
OK>   {CL_COMMAND_BUFFER_CAPABILITY_SIMULTANEOUS_USE_KHR} Device supports the
OK>   command-buffers having a <<pending_count, Pending Count>> that exceeds 1.
OK>
OK>   {CL_COMMAND_BUFFER_CAPABILITY_OUT_OF_ORDER_KHR} Device supports the ability
OK>   to record command-buffers to out-of-order command-queues.
OK>
OK> | {CL_DEVICE_COMMAND_BUFFER_REQUIRED_QUEUE_PROPERTIES_KHR}
OK> | {cl_command_queue_properties_TYPE}
OK> | Bitmask of the minimum properties with which a command-queue must be created
OK>   to allow a command-buffer to be executed on it. It is valid for a
OK>   command-queue to be created with extra properties in addition to this
OK>   base requirement and still be compatible with command-buffer execution.
OK> |====

OK> [[command-buffers]]
OK> === Add new section "Section 5.X - Command Buffers" to OpenCL API Specification
OK>
OK> A _command-buffer_ object represents a series of operations to be enqueued
OK> on one or more command-queues without any application code interaction.
OK> Grouping the operations together allows efficient enqueuing of repetitive
OK> operations, as well as enabling driver optimizations.
OK>
OK> Command-buffers are _sequential use_ by default, but may also be set to
OK> _simultaneous use_ on creation if the device optionally supports this
OK> capability. A sequential use command-buffer must have a <<pending_count,
OK> Pending Count>> of 0 or 1. The simultaneous use capability removes this
OK> restriction and allows command-buffers to have a <<pending_count, Pending
OK> Count>> greater than 1.
OK>
OK> [[compatible]]
OK> Command-buffers are created using an ordered list of command-queues that
OK> commands are recorded to and execute on by default. These command-queues can be
OK> replaced on command-buffer enqueue with different command-queues, provided for
OK> each element in the replacement list the substitute command-queue is compatible
OK> with the command-queue used on command-buffer creation. Where a _compatible_
OK> command-queue is defined as a command-queue with identical properties targeting
OK> the same device and in the same OpenCL context.
OK>
OK> While constructing a command-buffer it is valid for the user to interleave calls
OK> to the same queue which create commands, such as {clCommandNDRangeKernelKHR}, with
OK> queue submission calls, such as {clEnqueueNDRangeKernel} or
OK> {clEnqueueCommandBufferKHR}. That is, there is no effect on queue state from
OK> recording commands. The purpose of the queue parameter is to define the device
OK> and properties of the command, which are constant queries on the queue object.
OK>
OK> A command-buffer object should increment the reference count of attached OpenCL
OK> objects such as queues, buffers, images, and kernels referenced in commands
OK> recorded to the command-buffer. This enables correct behavior of the
OK> command-buffer when its attached objects have been released. On destruction of
OK> the command-buffer it should decrement these reference counts, allowing the
OK> attached objects to be freed if appropriate.
OK>
OK> [[command-buffer-kernel-argument-ref-counting]]
OK> [NOTE]
OK> ====
OK> A command-buffer object does not update the reference count of objects set as
OK> arguments on kernels recorded into the command-buffer. This is consistent with
OK> the reference counting behavior of {clSetKernelArg}.
OK>
OK> Applications should ensure that objects passed as arguments to kernels recorded
OK> to a command-buffer are not deleted until the command-buffer has been released.
OK> Undefined behavior may result from the failure to follow this usage requirement
OK> for all the command-buffers an object is used as a kernel argument in.
OK>
OK> If using layered extension `cl_khr_command_buffer_mutable_dispatch`,
OK> <<mutable-dispatch-kernel-argument-safe-usage,
OK> see related note on safe usage>>.
OK> ====
OK>
OK> ==== Add new section "Section 5.X.1 - Command Buffer Lifecycle"
OK>
OK> A command-buffer is always in one of the following states:
OK>
OK> [[recording]]
OK> Recording:: Initial state of a command-buffer on creation, where commands can be
OK> recorded to the command-buffer.
OK>
OK> [[executable]]
OK> Executable:: State after command recording has finished with
OK> {clFinalizeCommandBufferKHR} and the command-buffer may be enqueued.
OK>
OK> [[pending]]
OK> Pending:: Once a command-buffer has been enqueued to a command-queue it enters
OK> the Pending state until completion, at which point it moves back to the
OK> <<executable, Executable>> state.
OK>
OK> ////
OK> Image generated from the following mermaid diagram description using https://mermaid.live
OK> Ideally we'd use the asciidoctor-diagram extension to generate the rendered diagram, but
OK> there are issues installing the gem with ruby 2.3.3
OK>
OK> [mermaid, "Lifecycle of a command-buffer", png]
OK> ....
OK> stateDiagram-v2
OK>     [*] --> Recording: Create
OK>     Recording -->Executable: Finalize
OK>     Executable --> Pending: Enqueue
OK>     Pending --> Executable: Completion
OK> ....
OK> ////
OK>
OK> image::images/commandbuffer_lifecycle.svg[align="center", title="Lifecycle of a command-buffer."]
OK>
OK> [[pending_count]]
OK> The Pending Count is the number of copies of the command
OK> buffer in the <<pending, Pending>> state. By default a command-buffer's Pending
OK> Count must be 0 or 1. If the command-buffer was created with
OK> {CL_COMMAND_BUFFER_SIMULTANEOUS_USE_KHR} then the command-buffer may have a
OK> Pending Count greater than 1.
OK>
OK> ==== Add new section "Section 5.X.2 - Creating Command Buffer Objects"
OK>
OK> The function
OK>
OK> include::{generated}/api/protos/clCreateCommandBufferKHR.txt[]
OK>
OK> Is used to create a command-buffer that can record commands to the specified
OK> queues.
OK>
OK> [NOTE]
OK> ====
OK> Upon creation the command-buffer is defined as being in the
OK> <<recording, Recording>> state, in order for the command-buffer to be enqueued
OK> it must first be finalized using {clFinalizeCommandBufferKHR} after which no
OK> further commands can be recorded. A command-buffer is submitted for execution
OK> on command-queues with a call to {clEnqueueCommandBufferKHR}.
OK> ====
OK>
OK> _num_queues_ The number of command-queues listed in _queues_. This extension
OK> only supports a single command-queue, so this **must** be one.
OK>
OK> _queues_  Is a pointer to a command-queue that the command-buffer commands will
OK> be recorded to. _queues_ must be a non-`NULL` value.
OK>
OK> _properties_  Specifies a list of properties for the command-buffer and their
OK> corresponding values. Each property name is immediately followed by the
OK> corresponding desired value. The list is terminated with 0.
OK> The list of supported properties is described in the table below. If a
OK> supported property and its value is not specified in properties, its
OK> default value will be used. _properties_ can be `NULL` in which case the
OK> default values for supported command-buffer properties will be used.
OK>
OK> [[commandbuffer-properties]]
OK> .{clCreateCommandBufferKHR} properties
OK> [cols=",,",options="header",]
OK> |====
OK> | *Recording Properties*
OK> | *Property Value*
OK> | *Description*
OK>
OK> | {CL_COMMAND_BUFFER_FLAGS_KHR}
OK> | {cl_command_buffer_flags_khr_TYPE}
OK> | This is a bitfield and can be set to a combination of the following values:
OK>
OK>   {CL_COMMAND_BUFFER_SIMULTANEOUS_USE_KHR} - Allow multiple instances of the
OK>   command-buffer to be submitted to the device for execution. If set, devices
OK>   must support {CL_COMMAND_BUFFER_CAPABILITY_SIMULTANEOUS_USE_KHR}.
OK>
OK>   The default value of this property is `0`.
OK> |====
OK>
OK> _errcode_ret_ Returns an appropriate error code. If _errcode_ret_ is `NULL`, no
OK> error code is returned.
OK>
OK> {clCreateCommandBufferKHR} returns a valid non-zero command-buffer and
OK> _errcode_ret_ is set to {CL_SUCCESS} if the command-buffer is created
OK> successfully. Otherwise, it returns a `NULL` value with one of the following
OK> error values returned in _errcode_ret_:
OK>
OK> * {CL_INVALID_COMMAND_QUEUE} if any command-queue in _queues_ is not a valid
OK>   command-queue.
OK>
OK> * {CL_INCOMPATIBLE_COMMAND_QUEUE_KHR} if any command-queue in _queues_ is an
OK>   out-of-order command-queue and the device associated with the command-queue
OK>   does not support the {CL_COMMAND_BUFFER_CAPABILITY_OUT_OF_ORDER_KHR}
OK>   capability.
OK>
OK> * {CL_INCOMPATIBLE_COMMAND_QUEUE_KHR} if the properties of any command-queue in
OK>   _queues_ does not contain the minimum properties specified by
OK>   {CL_DEVICE_COMMAND_BUFFER_REQUIRED_QUEUE_PROPERTIES_KHR}.
OK>
OK> * {CL_INVALID_CONTEXT} if all the command-queues in _queues_ do not have the
OK>   same OpenCL context.
OK>
OK> * {CL_INVALID_VALUE} if _num_queues_ is not one.
OK>
OK> * {CL_INVALID_VALUE} if _queues_ is `NULL`.
OK>
OK> * {CL_INVALID_VALUE} if values specified in _properties_ are not valid, or if
OK>   the same property name is specified more than once.
OK>
OK> * {CL_INVALID_PROPERTY} if values specified in _properties_ are valid but are
OK>   not supported by all the devices associated with command-queues in _queues_.
OK>
OK> * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources
OK>   required by the OpenCL implementation on the device.
OK>
OK> * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources
OK>   required by the OpenCL implementation on the host.
OK>
OK> The function
OK>
OK> include::{generated}/api/protos/clRetainCommandBufferKHR.txt[]
OK>
OK> Increments the _command_buffer_ reference count.
OK>
OK> _command_buffer_ Specifies the command-buffer to retain.
OK>
OK> {clRetainCommandBufferKHR} returns {CL_SUCCESS} if the function is executed
OK> successfully. Otherwise, it returns one of the following errors:
OK>
OK> * {CL_INVALID_COMMAND_BUFFER_KHR} if _command_buffer_ is not a valid
OK>   command-buffer.
OK>
OK> * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources required by
OK>   the OpenCL implementation on the device.
OK>
OK> * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources required by
OK>   the OpenCL implementation on the host.
OK>
OK> The function
OK>
OK> include::{generated}/api/protos/clReleaseCommandBufferKHR.txt[]
OK>
OK> Decrements the _command_buffer_ reference count.
OK>
OK> [NOTE]
OK> ====
OK> After the _command_buffer_ reference count becomes zero and has finished
OK> execution, the command-buffer is deleted.
OK> ====
OK>
OK> _command_buffer_ Specifies the command-buffer to release.
OK>
OK> {clReleaseCommandBufferKHR} returns {CL_SUCCESS} if the function is executed
OK> successfully. Otherwise, it returns one of the following errors:
OK>
OK> * {CL_INVALID_COMMAND_BUFFER_KHR} if _command_buffer_ is not a valid
OK>   command-buffer.
OK>
OK> * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources
OK>   required by the OpenCL implementation on the device.
OK>
OK> * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources
OK>   required by the OpenCL implementation on the host.
OK>
OK> ==== Add new section "Section 5.X.2 - Enqueuing a Command Buffer"
OK>
OK> The function
OK>
OK> include::{generated}/api/protos/clFinalizeCommandBufferKHR.txt[]
OK>
OK> Finalizes command recording ready for enqueuing the command-buffer on a
OK> command-queue.
OK>
OK> [NOTE]
OK> ====
OK> {clFinalizeCommandBufferKHR} places the command-buffer in the
OK> <<executable, Executable>> state where commands can no longer be recorded, at
OK> this point the command-buffer is ready to be enqueued.
OK> ====
OK>
OK> _command_buffer_ Refers to a valid command-buffer object.
OK>
OK> {clFinalizeCommandBufferKHR} returns {CL_SUCCESS} if the function is executed
OK> successfully. Otherwise, it returns one of the following errors:
OK>
OK> * {CL_INVALID_COMMAND_BUFFER_KHR} if _command_buffer_ is not a valid
OK>   command-buffer.
OK>
OK> * {CL_INVALID_OPERATION} if _command_buffer_ is not in the
OK>   <<recording, Recording>> state.
OK>
OK> * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources required by
OK>   the OpenCL implementation on the device.
OK>
OK> * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources required
OK>   by the OpenCL implementation on the host.
OK>
OK> The function
OK>
OK> include::{generated}/api/protos/clEnqueueCommandBufferKHR.txt[]
OK>
OK> Enqueues a command-buffer to execute on command-queues specified by _queues_,
OK> or on default command-queues used during recording if _queues_ is empty.
OK>
OK> [NOTE]
OK> ====
OK> To enqueue a command-buffer it must be in a <<executable, Executable>> state,
OK> see {clFinalizeCommandBufferKHR}.
OK> ====
OK>
OK> _num_queues_ The number of command-queues listed in _queues_.
OK>
OK> _queues_  A pointer to an ordered list of command-queues
OK> <<compatible, compatible>> with the command-queues used on recording. _queues_
OK> can be `NULL` in which case the default command-queues used on command-buffer
OK> creation are used and _num_queues_ must be 0.
OK>
OK> _command_buffer_ Refers to a valid command-buffer object.
OK>
OK> _event_wait_list_, _num_events_in_wait_list_ Specify events that need to
OK> complete before this particular command can be executed. If
OK> _event_wait_list_ is `NULL`, then this particular command does not wait
OK> on any event to complete. If _event_wait_list_ is `NULL`,
OK> _num_events_in_wait_list_ must be 0. If event_wait_list is not `NULL`,
OK> the list of events pointed to by _event_wait_list_ must be valid and
OK> _num_events_in_wait_list_ must be greater than 0. The events specified
OK> in _event_wait_list_ act as synchronization points. The context associated
OK> with events in _event_wait_list_ and command_queue must be the same. The memory
OK> associated with _event_wait_list_ can be reused or freed after the function
OK> returns.
OK>
OK> _event_ Returns an event object that identifies this command and
OK> can be used to query for profiling information or queue a wait for this
OK> particular command to complete. _event_ can be `NULL` in which case it will not
OK> be possible for the application to wait on this command or query it for
OK> profiling information.
OK>
OK> {clEnqueueCommandBufferKHR} returns {CL_SUCCESS} if the command-buffer
OK> execution was successfully queued, or one of the errors below:
OK>
OK> * {CL_INVALID_COMMAND_BUFFER_KHR} if _command_buffer_ is not a valid
OK>   command-buffer.
OK>
OK> * {CL_INVALID_OPERATION} if _command_buffer_ has not been finalized.
OK>
OK> * {CL_INVALID_OPERATION} if _command_buffer_ was not created with the
OK>   {CL_COMMAND_BUFFER_SIMULTANEOUS_USE_KHR} flag and is in the <<pending,
OK>   Pending>> state.
OK>
OK> * {CL_INVALID_VALUE} if _queues_ is `NULL` and _num_queues_ is > 0, or _queues_
OK>   is not `NULL` and _num_queues_ is 0.
OK>
OK> * {CL_INVALID_VALUE} if _num_queues_ is > 0 and not the same value as
OK>   _num_queues_ set on _command_buffer_ creation.
OK>
OK> * {CL_INVALID_COMMAND_QUEUE} if any element of _queues_ is not a valid
OK>   command-queue.
OK>
OK> * {CL_INCOMPATIBLE_COMMAND_QUEUE_KHR} if any element of _queues_ is not
OK>   <<compatible, compatible>>  with the command-queue set on _command_buffer_
OK>   creation at the same list index.
OK>
OK> * {CL_INVALID_CONTEXT} if any element of _queues_ does not have the same
OK>   context as the command-queue set on _command_buffer_ creation at the same list
OK>   index.
OK>
OK> * {CL_INVALID_CONTEXT} if context associated with _command_buffer_ and
OK>   events in _event_wait_list_ are not the same.
OK>
OK> * {CL_OUT_OF_RESOURCES} if there is a failure to queue the execution instance of
OK>   _command_buffer_ on the command-queues because of insufficient resources
OK>   needed to execute _command_buffer_.
OK>
OK> * {CL_INVALID_EVENT_WAIT_LIST} if _event_wait_list_ is `NULL` and
OK>   _num_events_in_wait_list_ > 0, or _event_wait_list_ is not `NULL`
OK>   and _num_events_in_wait_list_ is 0, or if event objects in
OK>   _event_wait_list_ are not valid events.
OK>
OK> * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources required by
OK>   the OpenCL implementation on the device.
OK>
OK> * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources required
OK>   by the OpenCL implementation on the host.
OK>
OK> ==== Add new section "Section 5.X.3 - Recording Commands to a Command Buffer"
OK>
OK> The function
OK>
OK> include::{generated}/api/protos/clCommandBarrierWithWaitListKHR.txt[]
OK>
OK> Records a barrier operation used as a synchronization point.
OK>
OK> [NOTE]
OK> ====
OK> {clCommandBarrierWithWaitListKHR} Waits for either a list of
OK> synchronization-points to complete, or if the list is empty it waits for all
OK> commands previously recorded in _command_buffer_ to complete before it
OK> completes. This command blocks command execution, that is, any following
OK> commands recorded after it do not execute until it completes.
OK> ====
OK>
OK> _command_buffer_ Refers to a valid command-buffer object.
OK>
OK> _command_queue_ Specifies the command-queue the command will be recorded to.
OK> Parameter is unused by this extension as only a single command-queue is
OK> supported and **must** be `NULL`.
OK>
OK> _sync_point_wait_list_, _num_sync_points_in_wait_list_ Specify
OK> synchronization-points that need to complete before this
OK> particular command can be executed.
OK>
OK> If _sync_point_wait_list_ is `NULL`, _num_sync_points_in_wait_list_
OK> must be 0. If _sync_point_wait_list_ is not `NULL`, the list of
OK> synchronization-points pointed to by _sync_point_wait_list_ must be
OK> valid and _num_sync_points_in_wait_list_ must be greater than 0.
OK> The synchronization-points specified in _sync_point_wait_list_ are
OK> *device-side* synchronization-points. The command-buffer associated
OK> with synchronization-points in _sync_point_wait_list_ must be the same
OK> as _command_buffer_. The memory associated with _sync_point_wait_list_
OK> can be reused or freed after the function returns.
OK>
OK> If _sync_point_wait_list_ is `NULL`, then this particular command
OK> waits until all previous recorded commands to _command_queue_ have
OK> completed.
OK>
OK> _sync_point_ Returns a synchronization-point ID that identifies this particular
OK> command. Synchronization-point objects are unique and can be used to
OK> identify this barrier command later on. _sync_point_ can be `NULL` in
OK> which case it will not be possible for the application to record a wait
OK> for this command to complete. If the _sync_point_wait_list_ and the
OK> _sync_point_ arguments are not `NULL`, the _sync_point_ argument
OK> should not refer to an element of the _sync_point_wait_list_ array.
OK>
OK> _mutable_handle_ Returns a handle to the command. Handle is unused by
OK> this extension and must be passed as `NULL`.
OK>
OK> {clCommandBarrierWithWaitListKHR} returns {CL_SUCCESS} if the function is
OK> executed successfully. Otherwise, it returns one of the following errors:
OK>
OK> * {CL_INVALID_COMMAND_QUEUE} if _command_queue_ is not `NULL`.
OK>
OK> * {CL_INVALID_COMMAND_BUFFER_KHR} if _command_buffer_ is not a valid
OK>   command-buffer.
OK>
OK> * {CL_INVALID_CONTEXT} if the context associated with _command_queue_ and
OK>   _command_buffer_ is not the same.
OK>
OK> * {CL_INVALID_OPERATION} if _command_buffer_ has been finalized.
OK>
OK> * {CL_INVALID_VALUE} if _mutable_handle_ is not `NULL`.
OK>
OK> * {CL_INVALID_SYNC_POINT_WAIT_LIST_KHR} if _sync_point_wait_list_ is `NULL` and
OK>   _num_sync_points_in_wait_list_ is > 0, or _sync_point_wait_list_ is not
OK>   `NULL` and _num_sync_points_in_wait_list_ is 0, or if
OK>   synchronization-point objects in _sync_point_wait_list_ are not valid
OK>   synchronization-points.
OK>
OK> * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources required by
OK>   the OpenCL implementation on the device.
OK>
OK> * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources required by
OK>   the OpenCL implementation on the host.
OK>
OK> The function
OK>
OK> include::{generated}/api/protos/clCommandCopyBufferKHR.txt[]
OK>
OK> Records a command to copy from one buffer object to another.
OK>
OK> _command_buffer_ Refers to a valid command-buffer object.
OK>
OK> _command_queue_ Specifies the command-queue the command will be recorded to.
OK> Parameter is unused by this extension as only a single command-queue is
OK> supported and **must** be `NULL`.
OK>
OK> _src_buffer_, _dst_buffer_, _src_offset_, _dst_offset_, _size_ Refer to
OK> {clEnqueueCopyBuffer}.
OK>
OK> _sync_point_wait_list_, _num_sync_points_in_wait_list_ Specify
OK> synchronization-points that need to complete before this
OK> particular command can be executed.
OK>
OK> If _sync_point_wait_list_ is `NULL`, _num_sync_points_in_wait_list_
OK> must be 0. If _sync_point_wait_list_ is not `NULL`, the list of
OK> synchronization-points pointed to by _sync_point_wait_list_ must be
OK> valid and _num_sync_points_in_wait_list_ must be greater than 0.
OK> The synchronization-points specified in _sync_point_wait_list_ are
OK> *device-side* synchronization-points. The command-buffer associated
OK> with synchronization-points in _sync_point_wait_list_ must be the same
OK> as _command_buffer_. The memory associated with _sync_point_wait_list_
OK> can be reused or freed after the function returns.
OK>
OK> _sync_point_ Returns a synchronization-point ID that identifies this particular
OK> command. Synchronization-point objects are unique and can be used to
OK> identify this command later on. _sync_point_ can be `NULL` in which case it
OK> will not be possible for the application to record a wait for this command to
OK> complete. If the _sync_point_wait_list_ and the _sync_point_ arguments are not
OK> `NULL`, the _sync_point_ argument should not refer to an element of the
OK> _sync_point_wait_list_ array.
OK>
OK> _mutable_handle_ Returns a handle to the command. Handle is unused by
OK> this extension and must be passed as `NULL`.
OK>
OK> {clCommandCopyBufferKHR} returns {CL_SUCCESS} if the function is executed
OK> successfully. Otherwise, it returns the errors defined by
OK> {clEnqueueCopyBuffer} except:
OK>
OK> {CL_INVALID_COMMAND_QUEUE} is replaced with:
OK>
OK> * {CL_INVALID_COMMAND_QUEUE} if _command_queue_ is not `NULL`.
OK>
OK> {CL_INVALID_CONTEXT} is replaced with:
OK>
OK> * {CL_INVALID_CONTEXT} if the context associated with _command_queue_,
OK>   _command_buffer_, _src_buffer_, and _dst_buffer_ are not the same.
OK>
OK> {CL_INVALID_EVENT_WAIT_LIST} is replaced with:
OK>
OK> * {CL_INVALID_SYNC_POINT_WAIT_LIST_KHR} if _sync_point_wait_list_ is `NULL` and
OK>   _num_sync_points_in_wait_list_ is > 0, or _sync_point_wait_list_ is not
OK>   `NULL` and _num_sync_points_in_wait_list_ is 0, or if
OK>   synchronization-point objects in _sync_point_wait_list_ are not valid
OK>   synchronization-points.
OK>
OK> New errors:
OK>
OK> * {CL_INVALID_COMMAND_BUFFER_KHR} if _command_buffer_ is not a valid
OK>   command-buffer.
OK>
OK> * {CL_INVALID_OPERATION} if _command_buffer_ has been finalized.
OK>
OK> * {CL_INVALID_VALUE} if _mutable_handle_ is not `NULL`.
OK>
OK> The function
OK>
OK> include::{generated}/api/protos/clCommandCopyBufferRectKHR.txt[]
OK>
OK> Records a command to copy a rectangular region from a buffer object to another
OK> buffer object.
OK>
OK> [NOTE]
OK> ====
OK> {clCommandCopyBufferRectKHR} records a command to copy a 2D or 3D rectangular
OK> region from the buffer object identified by _src_buffer_ to a 2D or 3D region
OK> in the buffer object identified by _dst_buffer_. Copying begins at the source
OK> offset and destination offset which are computed as described in the
OK> description for _src_origin_ and _dst_origin_.
OK>
OK> Each byte of the region's width is copied from the source offset to the
OK> destination offset. After copying each width, the source and destination
OK> offsets are incremented by their respective source and destination row
OK> pitches. After copying each 2D rectangle, the source and destination offsets
OK> are incremented by their respective source and destination slice pitches.
OK> ====
OK>
OK> _command_buffer_ Refers to a valid command-buffer object.
OK>
OK> _command_queue_ Specifies the command-queue the command will be recorded to.
OK> Parameter is unused by this extension as only a single command-queue is
OK> supported and **must** be `NULL`.
OK>
OK> _src_origin_, _dst_origin_, _region_, _src_row_pitch_, _src_slice_pitch_,
OK> _dst_row_pitch_, _dst_slice_pitch_ Refer to {clEnqueueCopyBufferRect}.
OK>
OK> _sync_point_wait_list_, _num_sync_points_in_wait_list_ Specify
OK> synchronization-points that need to complete before this
OK> particular command can be executed.
OK>
OK> If _sync_point_wait_list_ is `NULL`, _num_sync_points_in_wait_list_
OK> must be 0. If _sync_point_wait_list_ is not `NULL`, the list of
OK> synchronization-points pointed to by _sync_point_wait_list_ must be
OK> valid and _num_sync_points_in_wait_list_ must be greater than 0.
OK> The synchronization-points specified in _sync_point_wait_list_ are
OK> *device-side* synchronization-points. The command-buffer associated
OK> with synchronization-points in _sync_point_wait_list_ must be the same
OK> as _command_buffer_. The memory associated with _sync_point_wait_list_
OK> can be reused or freed after the function returns.
OK>
OK> _sync_point_ Returns a synchronization-point ID that identifies this particular
OK> command. Synchronization-point objects are unique and can be used to
OK> identify this command later on. _sync_point_ can be `NULL` in which case it
OK> will not be possible for the application to record a wait for this command to
OK> complete. If the _sync_point_wait_list_ and the _sync_point_ arguments are not
OK> `NULL`, the _sync_point_ argument should not refer to an element of the
OK> _sync_point_wait_list_ array.
OK>
OK> _mutable_handle_ Returns a handle to the command. Handle is unused by
OK> this extension and must be passed as `NULL`.
OK>
OK> {clCommandCopyBufferRectKHR} returns {CL_SUCCESS} if the function is executed
OK> successfully. Otherwise, it returns the errors defined by
OK> {clEnqueueCopyBufferRect} except:
OK>
OK> {CL_INVALID_COMMAND_QUEUE} is replaced with:
OK>
OK> * {CL_INVALID_COMMAND_QUEUE} if _command_queue_ is not `NULL`.
OK>
OK> {CL_INVALID_CONTEXT} is replaced with:
OK>
OK> * {CL_INVALID_CONTEXT} if the context associated with _command_queue_,
OK>   _command_buffer_, _src_buffer_, and _dst_buffer_ are not the same.
OK>
OK> {CL_INVALID_EVENT_WAIT_LIST} is replaced with:
OK>
OK> * {CL_INVALID_SYNC_POINT_WAIT_LIST_KHR} if _sync_point_wait_list_ is `NULL` and
OK>   _num_sync_points_in_wait_list_ is > 0, or _sync_point_wait_list_ is not
OK>   `NULL` and _num_sync_points_in_wait_list_ is 0, or if
OK>   synchronization-point objects in _sync_point_wait_list_ are not valid
OK>   synchronization-points.
OK>
OK> New errors:
OK>
OK> * {CL_INVALID_COMMAND_BUFFER_KHR} if _command_buffer_ is not a valid
OK>   command-buffer.
OK>
OK> * {CL_INVALID_OPERATION} if _command_buffer_ has been finalized.
OK>
OK> * {CL_INVALID_VALUE} if _mutable_handle_ is not `NULL`.
OK>
OK> The function
OK>
OK> include::{generated}/api/protos/clCommandCopyBufferToImageKHR.txt[]
OK>
OK> Records a command to copy a buffer object to an image object.
OK>
OK> _command_buffer_ Refers to a valid command-buffer object.
OK>
OK> _command_queue_ Specifies the command-queue the command will be recorded to.
OK> Parameter is unused by this extension as only a single command-queue is
OK> supported and **must** be `NULL`.
OK>
OK> _src_buffer_, _dst_image_, _src_offset_, _dst_origin_, _region_ Refer to
OK> {clEnqueueCopyBufferToImage}
OK>
OK> _sync_point_wait_list_, _num_sync_points_in_wait_list_ Specify
OK> synchronization-points that need to complete before this
OK> particular command can be executed.
OK>
OK> If _sync_point_wait_list_ is `NULL`, _num_sync_points_in_wait_list_
OK> must be 0. If _sync_point_wait_list_ is not `NULL`, the list of
OK> synchronization-points pointed to by _sync_point_wait_list_ must be
OK> valid and _num_sync_points_in_wait_list_ must be greater than 0.
OK> The synchronization-points specified in _sync_point_wait_list_ are
OK> *device-side* synchronization-points. The command-buffer associated
OK> with synchronization-points in _sync_point_wait_list_ must be the same
OK> as _command_buffer_. The memory associated with _sync_point_wait_list_
OK> can be reused or freed after the function returns.
OK>
OK> _sync_point_ Returns a synchronization-point ID that identifies this particular
OK> command. Synchronization-point objects are unique and can be used to
OK> identify this command later on. _sync_point_ can be `NULL` in which case it
OK> will not be possible for the application to record a wait for this command to
OK> complete. If the _sync_point_wait_list_ and the _sync_point_ arguments are not
OK> `NULL`, the _sync_point_ argument should not refer to an element of the
OK> _sync_point_wait_list_ array.
OK>
OK> _mutable_handle_ Returns a handle to the command. Handle is unused by
OK> this extension and must be passed as `NULL`.
OK>
OK> {clCommandCopyBufferToImageKHR} returns {CL_SUCCESS} if the function is executed
OK> successfully. Otherwise, it returns the errors defined by
OK> {clEnqueueCopyBufferToImage} except:
OK>
OK> {CL_INVALID_COMMAND_QUEUE} is replaced with:
OK>
OK> * {CL_INVALID_COMMAND_QUEUE} if _command_queue_ is not `NULL`.
OK>
OK> {CL_INVALID_CONTEXT} is replaced with:
OK>
OK> * {CL_INVALID_CONTEXT} if the context associated with _command_queue_,
OK>   _command_buffer_, _src_buffer_, and _dst_image_ are not the same.
OK>
OK> {CL_INVALID_EVENT_WAIT_LIST} is replaced with:
OK>
OK> * {CL_INVALID_SYNC_POINT_WAIT_LIST_KHR} if _sync_point_wait_list_ is `NULL` and
OK>   _num_sync_points_in_wait_list_ is > 0, or _sync_point_wait_list_ is not
OK>   `NULL` and _num_sync_points_in_wait_list_ is 0, or if
OK>   synchronization-point objects in _sync_point_wait_list_ are not valid
OK>   synchronization-points.
OK>
OK> New errors:
OK>
OK> * {CL_INVALID_COMMAND_BUFFER_KHR} if _command_buffer_ is not a valid
OK>   command-buffer.
OK>
OK> * {CL_INVALID_OPERATION} if _command_buffer_ has been finalized.
OK>
OK> * {CL_INVALID_VALUE} if _mutable_handle_ is not `NULL`.
OK>
OK> The function
OK>
OK> include::{generated}/api/protos/clCommandCopyImageKHR.txt[]
OK>
OK> Records a command to copy image objects.
OK>
OK> [NOTE]
OK> ====
OK> It is currently a requirement that the _src_image_ and _dst_image_ image
OK> memory objects for {clCommandCopyImageKHR} must have the exact same image
OK> format, i.e. the {cl_image_format_TYPE} descriptor specified when _src_image_ and
OK> _dst_image_ are created must match.
OK> ====
OK>
OK> _command_buffer_ Refers to a valid command-buffer object.
OK>
OK> _command_queue_ Specifies the command-queue the command will be recorded to.
OK> Parameter is unused by this extension as only a single command-queue is
OK> supported and **must** be `NULL`.
OK>
OK> _src_image_, _dst_image_, _src_origin_, _dst_origin_, _region_ Refer to
OK> {clEnqueueCopyImage}.
OK>
OK> _sync_point_wait_list_, _num_sync_points_in_wait_list_ Specify
OK> synchronization-points that need to complete before this
OK> particular command can be executed.
OK>
OK> If _sync_point_wait_list_ is `NULL`, _num_sync_points_in_wait_list_
OK> must be 0. If _sync_point_wait_list_ is not `NULL`, the list of
OK> synchronization-points pointed to by _sync_point_wait_list_ must be
OK> valid and _num_sync_points_in_wait_list_ must be greater than 0.
OK> The synchronization-points specified in _sync_point_wait_list_ are
OK> *device-side* synchronization-points. The command-buffer associated
OK> with synchronization-points in _sync_point_wait_list_ must be the same
OK> as _command_buffer_. The memory associated with _sync_point_wait_list_
OK> can be reused or freed after the function returns.
OK>
OK> _sync_point_ Returns a synchronization-point ID that identifies this particular
OK> command. Synchronization-point objects are unique and can be used to
OK> identify this command later on. _sync_point_ can be `NULL` in which case it
OK> will not be possible for the application to record a wait for this command to
OK> complete. If the _sync_point_wait_list_ and the _sync_point_ arguments are not
OK> `NULL`, the _sync_point_ argument should not refer to an element of the
OK> _sync_point_wait_list_ array.
OK>
OK> _mutable_handle_ Returns a handle to the command. Handle is unused by
OK> this extension and must be passed as `NULL`.
OK>
OK> {clCommandCopyImageKHR} returns {CL_SUCCESS} if the function is executed
OK> successfully. Otherwise, it returns the errors defined by
OK> {clEnqueueCopyImage} except:
OK>
OK> {CL_INVALID_COMMAND_QUEUE} is replaced with:
OK>
OK> * {CL_INVALID_COMMAND_QUEUE} if _command_queue_ is not `NULL`.
OK>
OK> {CL_INVALID_CONTEXT} is replaced with:
OK>
OK> * {CL_INVALID_CONTEXT} if the context associated with _command_queue_,
OK>   _command_buffer_, _src_image_, and _dst_image_ are not the same.
OK>
OK> {CL_INVALID_EVENT_WAIT_LIST} is replaced with:
OK>
OK> * {CL_INVALID_SYNC_POINT_WAIT_LIST_KHR} if _sync_point_wait_list_ is `NULL` and
OK>   _num_sync_points_in_wait_list_ is > 0, or _sync_point_wait_list_ is not
OK>   `NULL` and _num_sync_points_in_wait_list_ is 0, or if
OK>   synchronization-point objects in _sync_point_wait_list_ are not valid
OK>   synchronization-points.
OK>
OK> New errors:
OK>
OK> * {CL_INVALID_COMMAND_BUFFER_KHR} if _command_buffer_ is not a valid
OK>   command-buffer.
OK>
OK> * {CL_INVALID_OPERATION} if _command_buffer_ has been finalized.
OK>
OK> * {CL_INVALID_VALUE} if _mutable_handle_ is not `NULL`.
OK>
OK> The function
OK>
OK> include::{generated}/api/protos/clCommandCopyImageToBufferKHR.txt[]
OK>
OK> Records a command to copy an image object to a buffer object.
OK>
OK> _command_buffer_ Refers to a valid command-buffer object.
OK>
OK> _command_queue_ Specifies the command-queue the command will be recorded to.
OK> Parameter is unused by this extension as only a single command-queue is
OK> supported and **must** be `NULL`.
OK>
OK> _src_image_, _dst_buffer_, _src_origin_, _region_, _dst_offset_
OK> Refer to {clEnqueueCopyImageToBuffer}.
OK>
OK> _sync_point_wait_list_, _num_sync_points_in_wait_list_ Specify
OK> synchronization-points that need to complete before this
OK> particular command can be executed.
OK>
OK> If _sync_point_wait_list_ is `NULL`, _num_sync_points_in_wait_list_
OK> must be 0. If _sync_point_wait_list_ is not `NULL`, the list of
OK> synchronization-points pointed to by _sync_point_wait_list_ must be
OK> valid and _num_sync_points_in_wait_list_ must be greater than 0.
OK> The synchronization-points specified in _sync_point_wait_list_ are
OK> *device-side* synchronization-points. The command-buffer associated
OK> with synchronization-points in _sync_point_wait_list_ must be the same
OK> as _command_buffer_. The memory associated with _sync_point_wait_list_
OK> can be reused or freed after the function returns.
OK>
OK> _sync_point_ Returns a synchronization-point ID that identifies this particular
OK> command. Synchronization-point objects are unique and can be used to
OK> identify this command later on. _sync_point_ can be `NULL` in which case it
OK> will not be possible for the application to record a wait for this command to
OK> complete. If the _sync_point_wait_list_ and the _sync_point_ arguments are not
OK> `NULL`, the _sync_point_ argument should not refer to an element of the
OK> _sync_point_wait_list_ array.
OK>
OK> _mutable_handle_ Returns a handle to the command. Handle is unused by
OK> this extension and must be passed as `NULL`.
OK>
OK> {clCommandCopyImageToBufferKHR} returns {CL_SUCCESS} if the function is
OK> executed successfully. Otherwise, it returns the errors defined by
OK> {clEnqueueCopyImageToBuffer} except:
OK>
OK> {CL_INVALID_COMMAND_QUEUE} is replaced with:
OK>
OK> * {CL_INVALID_COMMAND_QUEUE} if _command_queue_ is not `NULL`.
OK>
OK> {CL_INVALID_CONTEXT} is replaced with:
OK>
OK> * {CL_INVALID_CONTEXT} if the context associated with _command_queue_,
OK>   _command_buffer_, _src_image_, and _dst_buffer_ are not the same.
OK>
OK> {CL_INVALID_EVENT_WAIT_LIST} is replaced with:
OK>
OK> * {CL_INVALID_SYNC_POINT_WAIT_LIST_KHR} if _sync_point_wait_list_ is `NULL` and
OK>   _num_sync_points_in_wait_list_ is > 0, or _sync_point_wait_list_ is not
OK>   `NULL` and _num_sync_points_in_wait_list_ is 0, or if
OK>   synchronization-point objects in _sync_point_wait_list_ are not valid
OK>   synchronization-points.
OK>
OK> New errors:
OK>
OK> * {CL_INVALID_COMMAND_BUFFER_KHR} if _command_buffer_ is not a valid
OK>   command-buffer.
OK>
OK> * {CL_INVALID_OPERATION} if _command_buffer_ has been finalized.
OK>
OK> * {CL_INVALID_VALUE} if _mutable_handle_ is not `NULL`.
OK>
OK> The function
OK>
OK> include::{generated}/api/protos/clCommandFillBufferKHR.txt[]
OK>
OK> Records a command to fill a buffer object with a pattern of a given pattern
OK> size.
OK>
OK> [NOTE]
OK> ====
OK> The usage information which indicates whether the memory object can be read or
OK> written by a kernel and/or the host and is given by the {cl_mem_flags_TYPE} argument
OK> value specified when _buffer_ is created is ignored by
OK> {clCommandFillBufferKHR}.
OK> ====
OK>
OK> _command_buffer_ Refers to a valid command-buffer object.
OK>
OK> _command_queue_ Specifies the command-queue the command will be recorded to.
OK> Parameter is unused by this extension as only a single command-queue is
OK> supported and **must** be `NULL`.
OK>
OK> _buffer_, _pattern_, _pattern_size_, _offset_, _size_ Refer to
OK> {clEnqueueFillBuffer}.
OK>
OK> _sync_point_wait_list_, _num_sync_points_in_wait_list_ Specify
OK> synchronization-points that need to complete before this
OK> particular command can be executed.
OK>
OK> If _sync_point_wait_list_ is `NULL`, _num_sync_points_in_wait_list_
OK> must be 0. If _sync_point_wait_list_ is not `NULL`, the list of
OK> synchronization-points pointed to by _sync_point_wait_list_ must be
OK> valid and _num_sync_points_in_wait_list_ must be greater than 0.
OK> The synchronization-points specified in _sync_point_wait_list_ are
OK> *device-side* synchronization-points. The command-buffer associated
OK> with synchronization-points in _sync_point_wait_list_ must be the same
OK> as _command_buffer_. The memory associated with _sync_point_wait_list_
OK> can be reused or freed after the function returns.
OK>
OK> _sync_point_ Returns a synchronization-point ID that identifies this particular
OK> command. Synchronization-point objects are unique and can be used to
OK> identify this command later on. _sync_point_ can be `NULL` in which case it
OK> will not be possible for the application to record a wait for this command to
OK> complete. If the _sync_point_wait_list_ and the _sync_point_ arguments are not
OK> `NULL`, the _sync_point_ argument should not refer to an element of the
OK> _sync_point_wait_list_ array.
OK>
OK> _mutable_handle_ Returns a handle to the command. Handle is unused by
OK> this extension and must be passed as `NULL`.
OK>
OK> {clCommandFillBufferKHR} returns {CL_SUCCESS} if the function is executed
OK> successfully. Otherwise, it returns the errors defined by
OK> {clEnqueueFillBuffer} except:
OK>
OK> {CL_INVALID_COMMAND_QUEUE} is replaced with:
OK>
OK> * {CL_INVALID_COMMAND_QUEUE} if _command_queue_ is not `NULL`.
OK>
OK> {CL_INVALID_CONTEXT} is replaced with:
OK>
OK> * {CL_INVALID_CONTEXT} if the context associated with _command_queue_,
OK>   _command_buffer_, and _buffer_ are not the same.
OK>
OK> {CL_INVALID_EVENT_WAIT_LIST} is replaced with:
OK>
OK> * {CL_INVALID_SYNC_POINT_WAIT_LIST_KHR} if _sync_point_wait_list_ is `NULL` and
OK>   _num_sync_points_in_wait_list_ is > 0, or _sync_point_wait_list_ is not
OK>   `NULL` and _num_sync_points_in_wait_list_ is 0, or if
OK>   synchronization-point objects in _sync_point_wait_list_ are not valid
OK>   synchronization-points.
OK>
OK> New errors:
OK>
OK> * {CL_INVALID_COMMAND_BUFFER_KHR} if _command_buffer_ is not a valid
OK>   command-buffer.
OK>
OK> * {CL_INVALID_OPERATION} if _command_buffer_ has been finalized.
OK>
OK> * {CL_INVALID_VALUE} if _mutable_handle_ is not `NULL`.
OK>
OK> The function
OK>
OK> include::{generated}/api/protos/clCommandFillImageKHR.txt[]
OK>
OK> Records a command to fill an image object with a specified color.
OK>
OK> [NOTE]
OK> ====
OK> The usage information which indicates whether the memory object can be read or
OK> written by a kernel and/or the host and is given by the {cl_mem_flags_TYPE} argument
OK> value specified when image is created is ignored by {clCommandFillImageKHR}.
OK> ====
OK>
OK> _command_buffer_ Refers to a valid command-buffer object.
OK>
OK> _command_queue_ Specifies the command-queue the command will be recorded to.
OK> Parameter is unused by this extension as only a single command-queue is
OK> supported and **must** be `NULL`.
OK>
OK> _image_, _fill_color_, _origin_, _region_ Refer to {clEnqueueFillImage}.
OK>
OK> _sync_point_wait_list_, _num_sync_points_in_wait_list_ Specify
OK> synchronization-points that need to complete before this
OK> particular command can be executed.
OK>
OK> If _sync_point_wait_list_ is `NULL`, _num_sync_points_in_wait_list_
OK> must be 0. If _sync_point_wait_list_ is not `NULL`, the list of
OK> synchronization-points pointed to by _sync_point_wait_list_ must be
OK> valid and _num_sync_points_in_wait_list_ must be greater than 0.
OK> The synchronization-points specified in _sync_point_wait_list_ are
OK> *device-side* synchronization-points. The command-buffer associated
OK> with synchronization-points in _sync_point_wait_list_ must be the same
OK> as _command_buffer_. The memory associated with _sync_point_wait_list_
OK> can be reused or freed after the function returns.
OK>
OK> _sync_point_ Returns a synchronization-point ID that identifies this particular
OK> command. Synchronization-point objects are unique and can be used to
OK> identify this command later on. _sync_point_ can be `NULL` in which case it
OK> will not be possible for the application to record a wait for this command to
OK> complete. If the _sync_point_wait_list_ and the _sync_point_ arguments are not
OK> `NULL`, the _sync_point_ argument should not refer to an element of the
OK> _sync_point_wait_list_ array.
OK>
OK> _mutable_handle_ Returns a handle to the command. Handle is unused by
OK> this extension and must be passed as `NULL`.
OK>
OK> {clCommandFillImageKHR} returns {CL_SUCCESS} if the function is executed
OK> successfully. Otherwise, it returns the errors defined by
OK> {clEnqueueFillImage} except:
OK>
OK> {CL_INVALID_COMMAND_QUEUE} is replaced with:
OK>
OK> * {CL_INVALID_COMMAND_QUEUE} if _command_queue_ is not `NULL`.
OK>
OK> {CL_INVALID_CONTEXT} is replaced with:
OK>
OK> * {CL_INVALID_CONTEXT} if the context associated with _command_queue_,
OK>   _command_buffer_, and _image_ are not the same.
OK>
OK> {CL_INVALID_EVENT_WAIT_LIST} is replaced with:
OK>
OK> * {CL_INVALID_SYNC_POINT_WAIT_LIST_KHR} if _sync_point_wait_list_ is `NULL` and
OK>   _num_sync_points_in_wait_list_ is > 0, or _sync_point_wait_list_ is not
OK>   `NULL` and _num_sync_points_in_wait_list_ is 0, or if
OK>   synchronization-point objects in _sync_point_wait_list_ are not valid
OK>   synchronization-points.
OK>
OK> New errors:
OK>
OK> * {CL_INVALID_COMMAND_BUFFER_KHR} if _command_buffer_ is not a valid
OK>   command-buffer.
OK>
OK> * {CL_INVALID_OPERATION} if _command_buffer_ has been finalized.
OK>
OK> * {CL_INVALID_VALUE} if _mutable_handle_ is not `NULL`.
OK>
OK> The function
OK>
OK> include::{generated}/api/protos/clCommandNDRangeKernelKHR.txt[]
OK>
OK> Records a command to execute a kernel on a device.
OK>
OK> [NOTE]
OK> ====
OK> The work-group size to be used for _kernel_ can also be specified in the
OK> program source using the
OK> `+__attribute__((reqd_work_group_size(X, Y, Z)))+` qualifier. In this case the
OK> size of work-group specified by _local_work_size_ must match the value
OK> specified by the `reqd_work_group_size` `+__attribute__+` qualifier.
OK>
OK> These work-group instances are executed in parallel across multiple compute
OK> units or concurrently on the same compute unit.
OK>
OK> Each work-item is uniquely identified by a global identifier. The global ID,
OK> which can be read inside the kernel, is computed using the value given by
OK> _global_work_size_ and _global_work_offset_. In addition, a work-item is
OK> also identified within a work-group by a unique local ID. The local ID,
OK> which can also be read by the kernel, is computed using the value given by
OK> _local_work_size_. The starting local ID is always (0, 0, ... 0).
OK> ====
OK>
OK> _command_buffer_ Refers to a valid command-buffer object.
OK>
OK> _command_queue_ Specifies the command-queue the command will be recorded to.
OK> Parameter is unused by this extension as only a single command-queue is
OK> supported and **must** be `NULL`.
OK>
OK> _properties_ Specifies a list of properties for the kernel command and their
OK> corresponding values. Each property name is immediately followed by the
OK> corresponding desired value. The list is terminated with 0. If no properties are
OK> required, _properties_ may be `NULL`. This extension does not define any
OK> properties.
OK>
OK> _kernel_ A valid kernel object which **must** have its arguments set. Any
OK> changes to _kernel_ after calling {clCommandNDRangeKernelKHR}, such as with
OK> {clSetKernelArg} or {clSetKernelExecInfo}, have no effect on the recorded
OK> command. If _kernel_ is recorded to a following {clCommandNDRangeKernelKHR}
OK> command however, then that command will capture the updated state of _kernel_.
OK>
OK> _work_dim_, _global_work_offset_, _global_work_size_, _local_work_size_ Refer
OK> to {clEnqueueNDRangeKernel}.
OK>
OK> _sync_point_wait_list_, _num_sync_points_in_wait_list_ Specify
OK> synchronization-points that need to complete before this
OK> particular command can be executed.
OK>
OK> If _sync_point_wait_list_ is `NULL`, _num_sync_points_in_wait_list_
OK> must be 0. If _sync_point_wait_list_ is not `NULL`, the list of
OK> synchronization-points pointed to by _sync_point_wait_list_ must be
OK> valid and _num_sync_points_in_wait_list_ must be greater than 0.
OK> The synchronization-points specified in _sync_point_wait_list_ are
OK> *device-side* synchronization-points. The command-buffer associated
OK> with synchronization-points in _sync_point_wait_list_ must be the same
OK> as _command_buffer_. The memory associated with _sync_point_wait_list_
OK> can be reused or freed after the function returns.
OK>
OK> _sync_point_ Returns a synchronization-point ID that identifies this particular
OK> command. Synchronization-point objects are unique and can be used to
OK> identify this command later on. _sync_point_ can be `NULL` in which case it
OK> will not be possible for the application to record a wait for this command to
OK> complete. If the _sync_point_wait_list_ and the _sync_point_ arguments are not
OK> `NULL`, the _sync_point_ argument should not refer to an element of the
OK> _sync_point_wait_list_ array.
OK>
OK> _mutable_handle_ Returns a handle to the command. Handle is unused by
OK> this extension and must be passed as `NULL`.
OK>
OK> {clCommandNDRangeKernelKHR} returns {CL_SUCCESS} if the function is executed
OK> successfully. Otherwise, it returns the errors defined by
OK> {clEnqueueNDRangeKernel} except:
OK>
OK> {CL_INVALID_COMMAND_QUEUE} is replaced with:
OK>
OK> * {CL_INVALID_COMMAND_QUEUE} if _command_queue_ is not `NULL`.
OK>
OK> {CL_INVALID_CONTEXT} is replaced with:
OK>
OK> * {CL_INVALID_CONTEXT} if the context associated with _command_queue_,
OK>   _command_buffer_, and _kernel_ are not the same.
OK>
OK> {CL_INVALID_EVENT_WAIT_LIST} is replaced with:
OK>
OK> * {CL_INVALID_SYNC_POINT_WAIT_LIST_KHR} if _sync_point_wait_list_ is `NULL` and
OK>   _num_sync_points_in_wait_list_ is > 0, or _sync_point_wait_list_ is not
OK>   `NULL` and _num_sync_points_in_wait_list_ is 0, or if
OK>   synchronization-point objects in _sync_point_wait_list_ are not valid
OK>   synchronization-points.
OK>
OK> New errors:
OK>
OK> * {CL_INVALID_COMMAND_BUFFER_KHR} if _command_buffer_ is not a valid
OK>   command-buffer.
OK>
OK> * {CL_INVALID_VALUE} if values specified in _properties_ are not valid
OK>
OK> * {CL_INVALID_OPERATION} if _command_buffer_ has been finalized.
OK>
OK> * {CL_INVALID_VALUE} if _mutable_handle_ is not `NULL`.
OK>
OK> * {CL_INVALID_OPERATION} if the device associated with _command_queue_ does not
OK>   support {CL_COMMAND_BUFFER_CAPABILITY_KERNEL_PRINTF_KHR} and _kernel_ contains
OK>   a printf call.
OK>
OK> * {CL_INVALID_OPERATION} if the device associated with _command_queue_ does not
OK>   support {CL_COMMAND_BUFFER_CAPABILITY_DEVICE_SIDE_ENQUEUE_KHR} and _kernel_
OK>   contains a kernel-enqueue call.
OK>
OK> The function
OK>
OK> include::{generated}/api/protos/clCommandSVMMemcpyKHR.txt[]
OK>
OK> Records a command to do an SVM memcpy operation.
OK>
OK> _command_buffer_ Refers to a valid command-buffer object.
OK>
OK> _command_queue_ Specifies the command-queue the command will be recorded to.
OK> Parameter is unused by this extension as only a single command-queue is
OK> supported and **must** be `NULL`.
OK>
OK> _dst_ptr_ is the pointer to a host (if the device supports system SVM)
OK> or SVM memory allocation where data is copied to.
OK>
OK> _src_ptr_ is the pointer to a host (if the device supports system SVM)
OK> or SVM memory allocation where data is copied from.
OK>
OK> _size_ is the size in bytes of data being copied.
OK>
OK> _sync_point_wait_list_, _num_sync_points_in_wait_list_ Specify
OK> synchronization-points that need to complete before this
OK> particular command can be executed.
OK>
OK> If _sync_point_wait_list_ is `NULL`, _num_sync_points_in_wait_list_
OK> must be 0. If _sync_point_wait_list_ is not `NULL`, the list of
OK> synchronization-points pointed to by _sync_point_wait_list_ must be
OK> valid and _num_sync_points_in_wait_list_ must be greater than 0.
OK> The synchronization-points specified in _sync_point_wait_list_ are
OK> *device-side* synchronization-points. The command-buffer associated
OK> with synchronization-points in _sync_point_wait_list_ must be the same
OK> as _command_buffer_. The memory associated with _sync_point_wait_list_
OK> can be reused or freed after the function returns.
OK>
OK> _sync_point_ Returns a synchronization-point ID that identifies this particular
OK> command. Synchronization-point objects are unique and can be used to
OK> identify this command later on. _sync_point_ can be `NULL` in which case it
OK> will not be possible for the application to record a wait for this command to
OK> complete. If the _sync_point_wait_list_ and the _sync_point_ arguments are not
OK> `NULL`, the _sync_point_ argument should not refer to an element of the
OK> _sync_point_wait_list_ array.
OK>
OK> _mutable_handle_ Returns a handle to the command. Handle is unused by
OK> this extension and must be passed as `NULL`.
OK>
OK> {clCommandSVMMemcpyKHR} returns {CL_SUCCESS} if the function is executed
OK> successfully. Otherwise, it returns the errors defined by
OK> {clEnqueueSVMMemcpy} except:
OK>
OK> {CL_INVALID_COMMAND_QUEUE} is replaced with:
OK>
OK> * {CL_INVALID_COMMAND_QUEUE} if _command_queue_ is not `NULL`.
OK>
OK> {CL_INVALID_CONTEXT} is replaced with:
OK>
OK> * {CL_INVALID_CONTEXT} if the context associated with _command_queue_,
OK>   _command_buffer_, and _kernel_ are not the same.
OK>
OK> {CL_INVALID_EVENT_WAIT_LIST} is replaced with:
OK>
OK> * {CL_INVALID_SYNC_POINT_WAIT_LIST_KHR} if _sync_point_wait_list_ is `NULL` and
OK>   _num_sync_points_in_wait_list_ is > 0, or _sync_point_wait_list_ is not
OK>   `NULL` and _num_sync_points_in_wait_list_ is 0, or if
OK>   synchronization-point objects in _sync_point_wait_list_ are not valid
OK>   synchronization-points.
OK>
OK> New errors:
OK>
OK> * {CL_INVALID_COMMAND_BUFFER_KHR} if _command_buffer_ is not a valid
OK>   command-buffer.
OK>
OK> * {CL_INVALID_OPERATION} if _command_buffer_ has been finalized.
OK>
OK> * {CL_INVALID_VALUE} if _mutable_handle_ is not `NULL`.
OK>
OK>
OK> The function
OK>
OK> include::{generated}/api/protos/clCommandSVMMemFillKHR.txt[]
OK>
OK> Records a command to fill a region in SVM with a pattern of a given pattern size.
OK>
OK> _command_buffer_ Refers to a valid command-buffer object.
OK>
OK> _command_queue_ Specifies the command-queue the command will be recorded to.
OK> Parameter is unused by this extension as only a single command-queue is
OK> supported and **must** be `NULL`.
OK>
OK> _svm_ptr_ is a pointer to a (if the device supports system SVM)
OK> or SVM memory region that will be filled with _pattern_. It must be
OK> aligned to _pattern_size_ bytes.
OK> If _svm_ptr_ is allocated using {clSVMAlloc} then it must be allocated from
OK> the same context from which _command_queue_ was created.
OK> Otherwise the behavior is undefined.
OK>
OK> _pattern_ is a pointer to the data pattern of size _pattern_size_ in bytes.
OK> _pattern_ will be used to fill a region in _buffer_ starting at _svm_ptr_
OK> and is _size_ bytes in size.
OK> The data pattern must be a scalar or vector integer or floating-point data
OK> type supported by OpenCL.
OK> For example, if region pointed to by _svm_ptr_ is to be filled with a
OK> pattern of float4 values, then _pattern_ will be a pointer to a cl_float4
OK> value and _pattern_size_ will be `sizeof(cl_float4)`.
OK> The maximum value of _pattern_size_ is the size of the largest integer or
OK> floating-point vector data type supported by the OpenCL device.
OK> The memory associated with _pattern_ can be reused or freed after the
OK> function returns.
OK>
OK> _size_ is the size in bytes of region being filled starting with _svm_ptr_
OK> and must be a multiple of _pattern_size_.
OK>
OK> _sync_point_wait_list_, _num_sync_points_in_wait_list_ Specify
OK> synchronization-points that need to complete before this
OK> particular command can be executed.
OK>
OK> If _sync_point_wait_list_ is `NULL`, _num_sync_points_in_wait_list_
OK> must be 0. If _sync_point_wait_list_ is not `NULL`, the list of
OK> synchronization-points pointed to by _sync_point_wait_list_ must be
OK> valid and _num_sync_points_in_wait_list_ must be greater than 0.
OK> The synchronization-points specified in _sync_point_wait_list_ are
OK> *device-side* synchronization-points. The command-buffer associated
OK> with synchronization-points in _sync_point_wait_list_ must be the same
OK> as _command_buffer_. The memory associated with _sync_point_wait_list_
OK> can be reused or freed after the function returns.
OK>
OK> _sync_point_ Returns a synchronization-point ID that identifies this particular
OK> command. Synchronization-point objects are unique and can be used to
OK> identify this command later on. _sync_point_ can be `NULL` in which case it
OK> will not be possible for the application to record a wait for this command to
OK> complete. If the _sync_point_wait_list_ and the _sync_point_ arguments are not
OK> `NULL`, the _sync_point_ argument should not refer to an element of the
OK> _sync_point_wait_list_ array.
OK>
OK> _mutable_handle_ Returns a handle to the command. Handle is unused by
OK> this extension and must be passed as `NULL`.
OK>
OK> {clCommandSVMMemFillKHR} returns {CL_SUCCESS} if the function is executed
OK> successfully. Otherwise, it returns the errors defined by
OK> {clEnqueueSVMMemFill} except:
OK>
OK> {CL_INVALID_COMMAND_QUEUE} is replaced with:
OK>
OK> * {CL_INVALID_COMMAND_QUEUE} if _command_queue_ is not `NULL`.
OK>
OK> {CL_INVALID_CONTEXT} is replaced with:
OK>
OK> * {CL_INVALID_CONTEXT} if the context associated with _command_queue_,
OK>   _command_buffer_, and _kernel_ are not the same.
OK>
OK> {CL_INVALID_EVENT_WAIT_LIST} is replaced with:
OK>
OK> * {CL_INVALID_SYNC_POINT_WAIT_LIST_KHR} if _sync_point_wait_list_ is `NULL` and
OK>   _num_sync_points_in_wait_list_ is > 0, or _sync_point_wait_list_ is not
OK>   `NULL` and _num_sync_points_in_wait_list_ is 0, or if
OK>   synchronization-point objects in _sync_point_wait_list_ are not valid
OK>   synchronization-points.
OK>
OK> New errors:
OK>
OK> * {CL_INVALID_COMMAND_BUFFER_KHR} if _command_buffer_ is not a valid
OK>   command-buffer.
OK>
OK> * {CL_INVALID_OPERATION} if _command_buffer_ has been finalized.
OK>
OK> * {CL_INVALID_VALUE} if _mutable_handle_ is not `NULL`.
OK>
OK> ==== Add new section "Section 5.X.4 - Command Buffer Queries"
OK>
OK> The function
OK>
OK> include::{generated}/api/protos/clGetCommandBufferInfoKHR.txt[]
OK>
OK> Queries information about a command-buffer.
OK>
OK> _command_buffer_ Specifies the command-buffer being queried.
OK>
OK> _param_name_ Specifies the information to query.
OK>
OK> _param_value_size_ Specifies the size in bytes of memory pointed to by
OK> _param_value_. This size must be        size of return type as described in the table
OK> below. If _param_value_ is `NULL`, it is ignored.
OK>
OK> _param_value_ A pointer to memory where the appropriate result being queried is
OK> returned. If _param_value_ is `NULL`, it is ignored.
OK>
OK> _param_value_size_ret_ Returns the actual size in bytes of data being queried by
OK> _param_value_. If _param_value_size_ret_ is `NULL`, it is ignored.
OK>
OK> The list of supported _param_name_ values and the information returned in
OK> _param_value_ by {clGetCommandBufferInfoKHR} is described in the table below.
OK>
OK> .{clGetCommandBufferInfoKHR} values
OK> [cols=",,",options="header",]
OK> |====
OK> | Command Buffer Info
OK> | Return Type
OK> | Description
OK>
OK> | {CL_COMMAND_BUFFER_NUM_QUEUES_KHR}
OK> | {cl_uint_TYPE}
OK> | The number of command-queues specified when _command_buffer_ was created.
OK>
OK> | {CL_COMMAND_BUFFER_QUEUES_KHR}
OK> | {cl_command_queue_TYPE}[]
OK> | Return the list of command-queues specified when the _command_buffer_ was
OK>   created.
OK>
OK> | {CL_COMMAND_BUFFER_REFERENCE_COUNT_KHR} footnote:[{fn-reference-count-usage}]
OK> | {cl_uint_TYPE}
OK> | Return the _command_buffer_ reference count.
OK>
OK> | {CL_COMMAND_BUFFER_STATE_KHR}
OK> | {cl_command_buffer_state_khr_TYPE}
OK> | Return the state of _command_buffer_.
OK>
OK>   {CL_COMMAND_BUFFER_STATE_RECORDING_KHR} is returned when _command_buffer_ has
OK>   not been finalized.
OK>
OK>   {CL_COMMAND_BUFFER_STATE_EXECUTABLE_KHR} is returned when _command_buffer_
OK>   has been finalized and there is not a <<pending, Pending>> instance of
OK>   _command_buffer_ awaiting completion on a command_queue.
OK>
OK>   {CL_COMMAND_BUFFER_STATE_PENDING_KHR} is returned when an instance of
OK>   _command_buffer_ has been enqueued for execution but not yet completed.
OK>
OK> | {CL_COMMAND_BUFFER_PROPERTIES_ARRAY_KHR}
OK> | {cl_command_buffer_properties_khr_TYPE}[]
OK> | Return the _properties_ argument specified in {clCreateCommandBufferKHR}.
OK>
OK>   If the _properties_ argument specified in {clCreateCommandBufferKHR} used to
OK>   create _command_buffer_ was not `NULL`, the implementation must return the
OK>   values specified in the properties argument.
OK>
OK>   If the _properties_ argument specified in {clCreateCommandBufferKHR} used to
OK>   create _command_buffer_ was `NULL`, the implementation may return either a
OK>   _param_value_size_ret_ of 0 (i.e. there is are no properties to be returned),
OK>   or the implementation may return a property value of 0 (where 0 is used to
OK>   terminate the properties list).
OK>
OK> | {CL_COMMAND_BUFFER_CONTEXT_KHR}
OK> | {cl_context_TYPE}
OK> | Return the context associated with _command_buffer_.
OK>
OK> |====
OK>
OK> {clGetCommandBufferInfoKHR} returns {CL_SUCCESS} if the function is executed
OK> successfully. Otherwise, it returns one of the following errors:
OK>
OK> * {CL_INVALID_COMMAND_BUFFER_KHR} if _command_buffer_ is not a valid
OK>   command-buffer.
OK>
OK> * {CL_INVALID_VALUE} if _param_name_ is not one of the supported values
OK>   or if size in bytes specified by _param_value_size_ is less than size of
OK>   return type and _param_value_ is not a `NULL` value.
OK>
OK> * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources required by
OK>   the OpenCL implementation on the device.
OK>
OK> * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources required by
OK>   the OpenCL implementation on the host.

OK> === Modifications to section 5.11 of the OpenCL API Specification
OK>
OK> In the opening paragraph add {clEnqueueCommandBufferKHR} to list of commands that
OK> can return an event object.
OK>
OK> Add to Table 37, _Event Command Types_:
OK> [cols=",",options="header"]
OK> |====
OK> | Events Created By
OK> | Event Command Type
OK>
OK> | {clEnqueueCommandBufferKHR}
OK> | {CL_COMMAND_COMMAND_BUFFER_KHR}
OK> |====

OK> === Sample Code
OK>
OK> [source]
OK> ----
OK>   #define CL_CHECK(ERROR)                             \
OK>     if (ERROR) {                                      \
OK>       std::cerr << "OpenCL error: " << ERROR << "\n"; \
OK>       return ERROR;                                   \
OK>     }
OK>
OK>   int main() {
OK>     cl_platform_id platform;
OK>     CL_CHECK(clGetPlatformIDs(1, &platform, nullptr));
OK>     cl_device_id device;
OK>     CL_CHECK(clGetDeviceIDs(platform, CL_DEVICE_TYPE_ALL, 1, &device, nullptr));
OK>
OK>     cl_int error;
OK>     cl_context context =
OK>         clCreateContext(nullptr, 1, &device, nullptr, nullptr, &error);
OK>     CL_CHECK(error);
OK>
OK>     const char* code = R"OpenCLC(
OK>   kernel void vector_addition(global int* tile1, global int* tile2,
OK>                               global int* res) {
OK>     size_t index = get_global_id(0);
OK>     res[index] = tile1[index] + tile2[index];
OK>   }
OK>   )OpenCLC";
OK>     const size_t length = std::strlen(code);
OK>
OK>     cl_program program =
OK>         clCreateProgramWithSource(context, 1, &code, &length, &error);
OK>     CL_CHECK(error);
OK>
OK>     CL_CHECK(clBuildProgram(program, 1, &device, nullptr, nullptr, nullptr));
OK>
OK>     cl_kernel kernel = clCreateKernel(program, "vector_addition", &error);
OK>     CL_CHECK(error);
OK>
OK>     constexpr size_t frame_count = 60;
OK>     constexpr size_t frame_elements = 1024;
OK>     constexpr size_t frame_size = frame_elements * sizeof(cl_int);
OK>
OK>     constexpr size_t tile_count = 16;
OK>     constexpr size_t tile_elements = frame_elements / tile_count;
OK>     constexpr size_t tile_size = tile_elements * sizeof(cl_int);
OK>
OK>     cl_mem buffer_tile1 =
OK>         clCreateBuffer(context, CL_MEM_READ_ONLY, tile_size, nullptr, &error);
OK>     CL_CHECK(error);
OK>     cl_mem buffer_tile2 =
OK>         clCreateBuffer(context, CL_MEM_READ_ONLY, tile_size, nullptr, &error);
OK>     CL_CHECK(error);
OK>     cl_mem buffer_res =
OK>         clCreateBuffer(context, CL_MEM_WRITE_ONLY, tile_size, nullptr, &error);
OK>     CL_CHECK(error);
OK>
OK>     CL_CHECK(clSetKernelArg(kernel, 0, sizeof(buffer_tile1), &buffer_tile1));
OK>     CL_CHECK(clSetKernelArg(kernel, 1, sizeof(buffer_tile2), &buffer_tile2));
OK>     CL_CHECK(clSetKernelArg(kernel, 2, sizeof(buffer_res), &buffer_res));
OK>
OK>     cl_command_queue command_queue =
OK>       clCreateCommandQueue(context, device,
OK>                            CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE, &error);
OK>     CL_CHECK(error);
OK>
OK>     cl_command_buffer_khr command_buffer =
OK>         clCreateCommandBufferKHR(1, &command_queue, nullptr, &error);
OK>     CL_CHECK(error);
OK>
OK>     cl_mem buffer_src1 =
OK>         clCreateBuffer(context, CL_MEM_READ_ONLY, frame_size, nullptr, &error);
OK>     CL_CHECK(error);
OK>     cl_mem buffer_src2 =
OK>         clCreateBuffer(context, CL_MEM_READ_ONLY, frame_size, nullptr, &error);
OK>     CL_CHECK(error);
OK>     cl_mem buffer_dst =
OK>         clCreateBuffer(context, CL_MEM_WRITE_ONLY, frame_size, nullptr, &error);
OK>     CL_CHECK(error);
OK>
OK>     cl_sync_point_khr tile_sync_point = 0;
OK>     for (size_t tile_index = 0; tile_index < tile_count; tile_index++) {
OK>       std::array<cl_sync_point_khr, 2> copy_sync_points;
OK>       CL_CHECK(clCommandCopyBufferKHR(command_buffer,
OK>           command_queue, buffer_src1, buffer_tile1, tile_index * tile_size, 0,
OK>           tile_size, tile_sync_point ? 1 : 0,
OK>           tile_sync_point ? &tile_sync_point : nullptr, &copy_sync_points[0]),
OK>           nullptr);
OK>       CL_CHECK(clCommandCopyBufferKHR(command_buffer,
OK>           command_queue, buffer_src2, buffer_tile2, tile_index * tile_size, 0,
OK>           tile_size, tile_sync_point ? 1 : 0,
OK>           tile_sync_point ? &tile_sync_point : nullptr, &copy_sync_points[1]),
OK>           nullptr);
OK>
OK>       cl_sync_point_khr nd_sync_point;
OK>       CL_CHECK(clCommandNDRangeKernelKHR(command_buffer,
OK>           command_queue, nullptr, kernel, 1, nullptr, &tile_elements, nullptr,
OK>           copy_sync_points.size(), copy_sync_points.data(), &nd_sync_point,
OK>           nullptr));
OK>
OK>       CL_CHECK(clCommandCopyBufferKHR(command_buffer,
OK>           command_queue, buffer_res, buffer_dst, 0, tile_index * tile_size,
OK>           tile_size, 1, &nd_sync_point, &tile_sync_point, nullptr));
OK>     }
OK>
OK>     CL_CHECK(clFinalizeCommandBufferKHR(command_buffer));
OK>
OK>     std::random_device random_device;
OK>     std::mt19937 random_engine{random_device()};
OK>     std::uniform_int_distribution<cl_int> random_distribution{
OK>         0, std::numeric_limits<cl_int>::max() / 2};
OK>     auto random_generator = [&]() { return random_distribution(random_engine); };
OK>
OK>     for (size_t frame_index = 0; frame_index < frame_count; frame_index++) {
OK>       std::array<cl_event, 2> write_src_events;
OK>       std::vector<cl_int> src1(frame_elements);
OK>       std::generate(src1.begin(), src1.end(), random_generator);
OK>       CL_CHECK(clEnqueueWriteBuffer(command_queue, buffer_src1, CL_FALSE, 0,
OK>                                     frame_size, src1.data(), 0, nullptr,
OK>                                     &write_src_events[0]));
OK>       std::vector<cl_int> src2(frame_elements);
OK>       std::generate(src2.begin(), src2.end(), random_generator);
OK>       CL_CHECK(clEnqueueWriteBuffer(command_queue, buffer_src2, CL_FALSE, 0,
OK>                                     frame_size, src2.data(), 0, nullptr,
OK>                                     &write_src_events[1]));
OK>
OK>       CL_CHECK(clEnqueueCommandBufferKHR(0, NULL, command_buffer, 2,
OK>                                          write_src_events.data(), nullptr));
OK>
OK>       CL_CHECK(clFinish(command_queue));
OK>
OK>       CL_CHECK(clReleaseEvent(write_src_event[0]));
OK>       CL_CHECK(clReleaseEvent(write_src_event[1]));
OK>     }
OK>
OK>     CL_CHECK(clReleaseCommandBufferKHR(command_buffer));
OK>     CL_CHECK(clReleaseCommandQueue(command_queue));
OK>
OK>     CL_CHECK(clReleaseMemObject(buffer_src1));
OK>     CL_CHECK(clReleaseMemObject(buffer_src2));
OK>     CL_CHECK(clReleaseMemObject(buffer_dst));
OK>
OK>     CL_CHECK(clReleaseMemObject(buffer_tile1));
OK>     CL_CHECK(clReleaseMemObject(buffer_tile2));
OK>     CL_CHECK(clReleaseMemObject(buffer_res));
OK>
OK>     CL_CHECK(clReleaseKernel(kernel));
OK>     CL_CHECK(clReleaseProgram(program));
OK>     CL_CHECK(clReleaseContext(context));
OK>
OK>     return 0;
OK>   }
OK> ----
OK>
OK> === Issues
OK>
OK> . Introduce a `clCloneCommandBufferKHR` entry-point for cloning a
OK>   command-buffer.
OK> +
OK> --
OK> *UNRESOLVED*
OK> --
OK> . Enable detached command-buffer execution, where command-buffers are executed
OK>   on their own internal queue to prevent locking user created queues for the
OK>   duration of their execution.
OK> +
OK> --
OK> *UNRESOLVED*
OK> --
OK>
OK> NOTE: This is a preview of an OpenCL provisional extension specification that has been Ratified under the Khronos Intellectual Property Framework. It is being made publicly available prior to being uploaded to the Khronos registry to enable review and feedback from the community. If you have feedback please create an issue on https://github.com/KhronosGroup/OpenCL-Docs/
