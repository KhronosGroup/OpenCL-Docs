ifdef::cl_khr_command_buffer_multi_device[]
endif::cl_khr_command_buffer_multi_device[]

=== Modifications to Section 4.1 of the OpenCL API Specification

Add to *Table 3*, _Platform Queries_,

[[multi-device-platform-queries]]
[cols="1,1,4",options="header"]
|====
| *Platform Info* | *Return Type* | *Description*
| {CL_PLATFORM_COMMAND_BUFFER_CAPABILITIES_KHR}
  | {cl_platform_command_buffer_capabilities_khr_TYPE}
    | Describes platform command-buffer capabilities, encoded as bits in a
      bitfield.
      Supported capabilities are:

      {CL_COMMAND_BUFFER_PLATFORM_UNIVERSAL_SYNC_KHR} - Platform supports
      the ability to synchronize all commands in a command-buffer using
      sync-points, irrespective of the queue the individual commands are
      recorded to.

      {CL_COMMAND_BUFFER_PLATFORM_REMAP_QUEUES_KHR} - Platform supports the
      ability to create a deep copy of an existing command-buffer with the
      commands explicitly remapped to different, potentially <<compatible,
      incompatible>>, queues.

      {CL_COMMAND_BUFFER_PLATFORM_AUTOMATIC_REMAP_KHR} - Platform supports
      the ability to create a remapped command-buffer where the mapping of
      commands to queues is done by the OpenCL runtime in a way it
      determines as optimal.
      If {CL_COMMAND_BUFFER_PLATFORM_AUTOMATIC_REMAP_KHR} is reported,
      {CL_COMMAND_BUFFER_PLATFORM_REMAP_QUEUES_KHR} must also be reported.
|====


=== Modifications to Section 4.2 of the OpenCL API Specification

Add {CL_DEVICE_COMMAND_BUFFER_NUM_SYNC_DEVICES_KHR} and
{CL_DEVICE_COMMAND_BUFFER_SYNC_DEVICES_KHR} rows to *Table 5*, _Device
Queries_, of section 4.2.
Also, add additional text to the {CL_DEVICE_COMMAND_BUFFER_CAPABILITIES_KHR}
row:

[[multi-device-queries]]
[cols="1,1,4",options="header"]
|====
| {cl_device_info_TYPE}* | *Return Type* | *Description*
| {CL_DEVICE_COMMAND_BUFFER_CAPABILITIES_KHR}
  | {cl_device_command_buffer_capabilities_khr_TYPE}
    | Describes device command-buffer capabilities, encoded as bits in a
      bitfield.
      Supported capabilities are:

      {CL_COMMAND_BUFFER_CAPABILITY_MULTIPLE_QUEUE_KHR} Device supports the
      ability to record commands to more than one command-queue associated
      with _device_ in a single command-buffer.

| {CL_DEVICE_COMMAND_BUFFER_NUM_SYNC_DEVICES_KHR}
  | {cl_uint_TYPE}
    | Return the number of root devices listed in
      {CL_DEVICE_COMMAND_BUFFER_SYNC_DEVICES_KHR} that _device_ can use
      device-side synchronization with.

| {CL_DEVICE_COMMAND_BUFFER_SYNC_DEVICES_KHR}
  | {cl_device_id_TYPE}[]
    | Return the list of root devices _device_ can use device-side
      synchronization with.
      A device should list itself only if it has native support for
      synchronizing commands.
      Sub-devices are not listed to avoid non-deterministic results as
      sub-devices are created.
      Instead if a root device is listed, then any of its partitioned
      sub-devices can also be natively synchronized with.
|====


=== Modifications to Section 5.11 of the OpenCL API Specification

Add additional wording to the description column of *Table 36*, _Event
Object Queries_:

{CL_EVENT_COMMAND_QUEUE} - For events returned by a command-buffer enqueue
operation to multiple command-queues, `NULL` is returned.

{CL_EVENT_COMMAND_EXECUTION_STATUS} - For events returned by a
command-buffer enqueue operation to multiple command-queues the semantics of
execution status is as follows:

  * {CL_QUEUED} - Command-buffer has been enqueued across the
    command-queues.
  * {CL_SUBMITTED} - Commands from the command-buffer have been submitted by
    the host to any device associated with one of the command-queues.
  * {CL_RUNNING} - Any command from the command-buffer has started execution
    on a device.
  * {CL_COMPLETE} - All commands have completed on all devices.


=== Modifications to Section 5.14 of the OpenCL API Specification


==== Query Updates

Add additional wording to description column of *Table 38*, _Event Profiling
Queries_:

  * {CL_PROFILING_COMMAND_QUEUED} - For events returned by a command-buffer
    enqueue operation to multiple command-queues, the host time when the
    command-buffer has been enqueued across the command-queues is used.
  * {CL_PROFILING_COMMAND_SUBMIT} - For events returned by a command-buffer
    enqueue operation to multiple command-queues, the host time is used when
    command-buffer commands have been submitted to any command-queue.
  * {CL_PROFILING_COMMAND_START} - For events returned by a command-buffer
    enqueue operation to multiple command-queues, the host time is used when
    any device starts executing a command-buffer command.
  * {CL_PROFILING_COMMAND_END} - For events returned by a command-buffer
    enqueue operation to multiple command-queues, the host time is used when
    the last command-buffer command finishes execution on any device.
  * {CL_PROFILING_COMMAND_COMPLETE} - For events returned by a
    command-buffer enqueue operation to multiple command-queues, the host
    time is used when the command-buffer has completed execution across all
    command-queues.

[NOTE]
====
If no reliable device timer sources are available to inform the host side,
or parallel runtime scheduling makes it impossible to identify a first/last
command, then an implementation may fallback to reporting
{CL_PROFILING_COMMAND_SUBMIT} and {CL_PROFILING_COMMAND_COMPLETE} for
{CL_PROFILING_COMMAND_START} and {CL_PROFILING_COMMAND_END} respectively.
====


==== Error Updates

Extend the wording defining the {CL_PROFILING_INFO_NOT_AVAILABLE} error
return code from {clGetEventProfilingInfo} to append the following sentence:

  * If _event_ was created from a call to {clEnqueueCommandBufferKHR},
    {CL_PROFILING_INFO_NOT_AVAILABLE} is returned if all the queues passed
    do not have {CL_QUEUE_PROFILING_ENABLE} set.


=== Modifications to Section 5.X - Command Buffers of the OpenCL API Specification


==== Additional Section 5.X Introduction Text

A command-buffer can contain commands recorded to the queues of different
devices if a vendor provides support for inter-device
{cl_sync_point_khr_TYPE} synchronization.
This feature is reported either through
{CL_DEVICE_COMMAND_BUFFER_SYNC_DEVICES_KHR}, which informs the user what
devices can synchronize with each other natively on the device-side, or
through {CL_COMMAND_BUFFER_PLATFORM_UNIVERSAL_SYNC_KHR}, which allows
synchronization between all devices in a platform, falling back to host-side
synchronization when device-side synchronization isn't available.
These two mechanisms are referred to as **device-side sync** and **universal
sync** respectively.

If these mechanisms don't report that more than one device can be used in a
command-buffer, it will still be possible to perform multiple queue
recording in a command-buffer if the
{CL_COMMAND_BUFFER_CAPABILITY_MULTIPLE_QUEUE_KHR} capability is reported for
a device.
However, with this capability all the queues commands are recorded to must
target the same device.

Commands recorded to different command-queues in the same command-buffer may
be executed concurrently to each other unless synchronized explicitly with
sync-points.
Ordering of other commands submitted to the same command-queues as used to
enqueue a command-buffer is the responsibility of the programmer.
A command-buffer enqueue spanning multiple queues can return an event to use
for synchronization, which will complete once all commands in the
command-buffer have completed.
If ordering restrictions are required, this event (or command-queue
barriers) may be used by the user to synchronize the command-buffer enqueue
with regular commands, or another command-buffer enqueue.


==== Add New Section "Section 5.X.Y - Remapping Command Buffers"

Platforms reporting the {CL_COMMAND_BUFFER_PLATFORM_REMAP_QUEUES_KHR}
capability support generating a deep copy of a command-buffer with its
commands remapped to a list of command-queues that are potentially
<<compatible, incompatible>> with the queues used to create the
command-buffer.
That is, the remapped command-buffer can execute on queues that differ in
terms of properties and/or associated device from the original
command-buffer queues.

This functionality is invoked through a new synchronous entry-point
{clRemapCommandBufferKHR} which takes a list of queues to which the commands
should now target.
It then returns a command-buffer containing the same commands as the
original, with the same command dependencies, but targeting different
queues.
A list of command handles may also be passed to the entry-point, which
allows handles to the equivalent commands in the remapped command-buffer to
be returned by an output parameter.

Device properties restrict remapping possibilities, as existing commands can
have a configuration which is not supported by another device, and so
remapping may fail with an error relating to this incompatibility.
Examples of command configurations which can introduce incompatibilities
when trying to map to a new device are:

  * Program language features used in a kernel not supported by the new
    device.
  * ND-Range configuration, e.g exceeds new the device max work-group size.
  * Misalignment of sub-buffers based on minimum alignment of new device.

In additional to this functionality, platforms reporting
{CL_COMMAND_BUFFER_PLATFORM_AUTOMATIC_REMAP_KHR} allow the user to create a
remapped command-buffer where the mapping of queues to commands is
determined by the OpenCL runtime in a way it determines as optimal.
This is particularly useful in hot plugging environments where devices may
appear and disappear during runtime.

[open,refpage='clRemapCommandBufferKHR',desc='Create copy of a command buffer remapped to specified command-queues',type='protos']
--
To create a deep copy of the input command-buffer with the copied commands
remapped to target the passed command-queues, call the function

include::{generated}/api/protos/clRemapCommandBufferKHR.txt[]

  * _command_buffer_ specifies the command-buffer to create a remapped deep
    copy of.
  * _automatic_ indicates if the remapping is done explicitly by the user,
    or automatically by the OpenCL runtime.
    If _automatic_ is {CL_FALSE}, then each element of _queues_ will replace
    the queue used on _command_buffer_ creation at the same index.
    If {CL_TRUE} and {CL_COMMAND_BUFFER_PLATFORM_AUTOMATIC_REMAP_KHR} is
    supported, then the OpenCL runtime will decide in a way it determines
    optimal which of the elements in _queues_ each command in the returned
    command-buffer will be associated with.
  * _num_queues_ is the number of command-queues listed in _queues_, must
    not be 0.
  * _queues_ is a pointer to an ordered list of command-queues for the
    returned command-buffer to target, must be a non-`NULL` value.
  * _num_handles_ is the number of command handles passed in both _handles_
    and _handles_ret_ lists, may be 0.
  * _handles_ is an ordered list of handles belonging to _command_buffer_ to
    create remapped copies of, may be `NULL`.
  * _handles_ret_ returns an ordered list of handles where each handle is
    equivalent to the handle at the same index in _handles_, but belonging
    to the returned command-buffer.
  * _errcode_ret_ returns an appropriate error code.
    If _errcode_ret_ is `NULL`, no error code is returned.

The returned command-buffer has the same state as the input command-buffer,
unless the input command-buffer is in the <<pending, Pending>> state, in
which case the returned command-buffer has state <<executable, Executable>>.

// refError

{clRemapCommandBufferKHR} returns a valid command-buffer with _errcode_ret_
set to {CL_SUCCESS} if the command-buffer is created successfully.
Otherwise, it returns a `NULL` value without setting _handles_ret_, and with
one of the following error values returned in _errcode_ret_:

  * {CL_INVALID_COMMAND_BUFFER_KHR} if _command_buffer_ is not a valid
    command-buffer.
  * {CL_INVALID_VALUE} if _num_queues_ is 0, or if _queues_ is `NULL`.
  * {CL_INVALID_VALUE} if _automatic_ is {CL_FALSE} and _num_queues_ is not
    equal to the number of queues used on creation of _command_buffer_.
  * {CL_INVALID_VALUE} if _handles_ or _handles_ret_ is `NULL` and
    _num_handles_ is > 0, or either _handles_ or _handles_ret_ is not `NULL`
    and _num_handles_ is 0.
  * {CL_INVALID_VALUE} if any handle in _handles_ is not a valid command
    handle belonging to _command_buffer_.
  * {CL_INVALID_COMMAND_QUEUE} if any command-queue in _queues_ is not a
    valid command-queue.
  * {CL_INVALID_CONTEXT} if _command_buffer_ and all the command-queues in
    _queues_ do not have the same OpenCL context.
  * {CL_INVALID_OPERATION} if the platform does not support the
    {CL_COMMAND_BUFFER_PLATFORM_REMAP_QUEUES_KHR} flag.
  * {CL_INVALID_OPERATION} if the platform does not support the
    {CL_COMMAND_BUFFER_PLATFORM_AUTOMATIC_REMAP_KHR} flag and _automatic_ is
    {CL_TRUE}.
  * {CL_INCOMPATIBLE_COMMAND_QUEUE_KHR} if such an error would be returned
    by passing _queues_ to {clCreateCommandBufferKHR}.
  * Any error relating to device support that can be returned by a command
    recording entry-point may also be returned.
    As a command in _command_buffer_ can have a configuration that is not
    supported by a device that is associated with the queue in _queues_ the
    command is being remapped to.
  * {CL_OUT_OF_RESOURCES} if there is a failure to allocate resources
    required by the OpenCL implementation on the device.
  * {CL_OUT_OF_HOST_MEMORY} if there is a failure to allocate resources
    required by the OpenCL implementation on the host.
--


==== Modifications to clCreateCommandBufferKHR

Modify the {CL_COMMAND_BUFFER_FLAGS_KHR} property in the
{clCreateCommandBufferKHR} properties table to introduce a new flag to the
bitfield.
The following text is now included in the description of property values.

[cols=",,",options="header",]
|====
| *Recording Properties* | *Property Value* | *Description*

| {CL_COMMAND_BUFFER_FLAGS_KHR}
  | {cl_command_buffer_flags_khr_TYPE}
    | {CL_COMMAND_BUFFER_DEVICE_SIDE_SYNC_KHR} - All commands in the
      command-buffer must use native synchronization, as reported by
      {CL_DEVICE_COMMAND_BUFFER_SYNC_DEVICES_KHR}.
      This can be used as a safeguard for performant applications that don't
      want to accidentally fallback to host synchronization when passing
      multiple queues.
|====


==== Add to clCreateCommandBufferKHR Description

.Summary of command-buffer creation configurations
[width="100%",options="header"]
|====
| *All Devices Associated With `Queues` can Device-side Sync* | *Platform Supports Universal Sync* | *Condition* | *Result*
.3+| Yes
.3+| Yes or No
| Any device does not support the multi-queue capability, and has more than
  one queue targeting it
| Error - {CL_INCOMPATIBLE_COMMAND_QUEUE_KHR}
| User sets {CL_COMMAND_BUFFER_DEVICE_SIDE_SYNC_KHR} flag
| OK
| Otherwise
| OK

.3+| No
.3+| Yes
| Any device does not support the multi-queue capability, and has more than
  one queue targeting it
| Error - {CL_INCOMPATIBLE_COMMAND_QUEUE_KHR}
| User sets {CL_COMMAND_BUFFER_DEVICE_SIDE_SYNC_KHR} flag
| Error - {CL_INCOMPATIBLE_COMMAND_QUEUE_KHR}
| Otherwise
| OK - May be performance implications when synchronizing commands between
  devices without device-side sync support.

| No
| No
| Always
| Error - {CL_INCOMPATIBLE_COMMAND_QUEUE_KHR}
|====


===== Parameter Updates

Parameter descriptions changed to:

_num_queues_ is the number of command-queues listed in _queues_.

_queues_ is a pointer to a list of command-queues that the command-buffer
may be executed on.
_queues_ must be a non-`NULL` value and length of the list equal to
_num_queues_.


===== Error Updates

The returned error:

  * {CL_INVALID_VALUE} if _num_queues_ is not one.

Is changed to:

  * {CL_INVALID_VALUE} if _num_queues_ is zero.

Additional errors:

  * {CL_INCOMPATIBLE_COMMAND_QUEUE_KHR} if _queues_ includes more than one
    command-queue associated with a device that does not support capability
    {CL_COMMAND_BUFFER_CAPABILITY_MULTIPLE_QUEUE_KHR}.
  * {CL_INCOMPATIBLE_COMMAND_QUEUE_KHR} if the
    {CL_COMMAND_BUFFER_DEVICE_SIDE_SYNC_KHR} flag is set, and any device
    associated with a command-queue in _queues_ cannot natively synchronize
    with the other devices associated with _queues_ as reported by
    {CL_DEVICE_COMMAND_BUFFER_SYNC_DEVICES_KHR}.
  * {CL_INCOMPATIBLE_COMMAND_QUEUE_KHR} if the platform doesn't support the
    {CL_COMMAND_BUFFER_PLATFORM_UNIVERSAL_SYNC_KHR} capability, and any
    device associated with a command-queue in _queues_ cannot natively
    synchronize with the other devices associated with _queues_ as reported
    by {CL_DEVICE_COMMAND_BUFFER_SYNC_DEVICES_KHR}.


==== Command Recording Entry Points

The descriptions of command recording entry-points are modified as described
in this section.
These changes apply to all of {clCommandCopyBufferKHR},
{clCommandCopyBufferRectKHR}, {clCommandCopyBufferToImageKHR},
{clCommandCopyImageKHR}, {clCommandCopyImageToBufferKHR},
{clCommandFillBufferKHR}, {clCommandFillImageKHR},
{clCommandNDRangeKernelKHR}, {clCommandSVMMemcpyKHR} and
{clCommandSVMMemFillKHR}.


===== Parameter Update

Parameter description of _command_queue_ is changed to:

_command_queue_ specifies the command-queue the command will be recorded to.
If _command_queue_ is `NULL` then only one command-queue must have been set
on _command_buffer_ creation, otherwise _command_queue_ must be a non-`NULL`
value.


===== Error Update

The error condition:

  * {CL_INVALID_COMMAND_QUEUE} if _command_queue_ is not `NULL`.

Is changed to :

  * {CL_INVALID_COMMAND_QUEUE} if _command_queue_ is `NULL` and
    _command_buffer_ was created with more than one queue, or if
    _command_queue_ is non-`NULL` and not a command-queue listed on
    _command_buffer_ creation.


