// Copyright 2023-2026 The Khronos Group Inc.
// SPDX-License-Identifier: CC-BY-4.0

[appendix]

[[extensions]]
= OpenCL Extensions (Informative)

Extensions to the OpenCL API can be defined by authors, groups of authors,
and the Khronos OpenCL Working Group.
The online Registry of extensions is available at URL

https://registry.khronos.org/OpenCL

It is possible to generate versions of the API Specification incorporating
different extensions.
At present only a subset of defined extensions can be incorporated in this
fashion.

The remainder of this appendix documents a set of extensions chosen when
this document was built.

Extensions are grouped as Khronos `khr`, multivendor `ext`, and then
alphabetically by author ID.
Within each group, extensions are listed in alphabetical order by their
names.


[[naming-convention-for-optional-extensions]]
== Naming Convention for Optional Extensions

OpenCL extensions approved by the OpenCL working group use the following
naming convention:

  * A unique _name string_ of the form `*cl_khr_<__name__>*` or
    `*cl_ext_<__name__>*` is associated with each extension.
    If the extension is supported by an implementation, this string will be
    present in the implementation's {CL_PLATFORM_EXTENSIONS} string or
    {CL_DEVICE_EXTENSIONS} string.
  * All enumerants defined by the extension will have names of the form
    *CL_<__enum_name__>_KHR* or *CL_<__enum_name__>_EXT*.
  * All types defined by the extension will have names of the form
    *cl_<__type_name__>_khr* or *cl_<__type_name__>_ext*.
  * All API functions defined by the extension will have names of the form
    *cl<__function_name__>KHR* or *cl<__function_name__>EXT*.

Functions and enumerants defined by extensions that are promoted to
core features will have their *KHR* or *EXT* affix removed.
OpenCL implementations of such later revisions must also export the name
strings of promoted extensions in the {CL_PLATFORM_EXTENSIONS} or
{CL_DEVICE_EXTENSIONS} string, and support the *KHR*- or *EXT*-affixed versions
of functions and enumerants as a transition aid.

Vendor extensions are strongly encouraged to follow a similar naming
convention:

  * A unique _name string_ of the form `*cl_<__vendor_tag__>_<__name>__*`
    is associated with each extension.
    If the extension is supported by an implementation, this string will be
    present in the implementation's {CL_PLATFORM_EXTENSIONS} string or
    {CL_DEVICE_EXTENSIONS} string.
  * All enumerants defined by the vendor extension should have names of the
    form *CL_<__enum_name__>_<__VENDOR_TAG__>.*
  * All types defined by the vendor extension should have names of the
    form *cl_<__type_name__>_<__vendor_tag__>.*
  * All API functions defined by the vendor extension should have names of the
    form *cl<__function_name__><__VENDOR_TAG__>*.


[[header-conventions-for-optional-extensions]]
== Header Conventions for Optional Extensions

Function pointer typedefs should be declared for all extensions that add API
entrypoints.
These typedefs are a required part of the extension interface, and should be
provided in an appropriate header, such as `cl_ext.h`.

The following convention should be followed for all extensions affecting the
host API:

[source,opencl]
----
#define cl_extension_name 1
#define CL_EXTENSION_NAME_NAME "cl_extension_name"

#define CL_EXTENSION_NAME_VERSION CL_MAKE_VERSION(major, minor, patch)

// all data typedefs and token #defines for this extension
#define CL_EXTENSION_ENUM_NAME_TAG    0xXXXX

// function types for extension functions
typedef return_type
clExtensionFunctionNameTAG_t(...);

// function pointer typedefs for extension functions
typedef clExtensionFunctionNameTAG_t *
clExtensionFunctionNameTAG_fn;

// extension function prototypes (optional)
extern return_type
clExtensionFunctionTAG(...);
----

where `TAG` can be `KHR`, `EXT` or `vendor-specific`.

Consider, for example, the {cl_khr_create_command_queue_EXT} extension.
This extension adds the following to `cl_ext.h`:

[source,opencl]
----
#define cl_khr_create_command_queue 1
#define CL_KHR_CREATE_COMMAND_QUEUE_EXTENSION_NAME \
    "cl_khr_create_command_queue"

#define CL_KHR_CREATE_COMMAND_QUEUE_EXTENSION_VERSION CL_MAKE_VERSION(1, 0, 0)

typedef cl_properties       cl_queue_properties_khr;

typedef cl_command_queue CL_API_CALL
clCreateCommandQueueWithPropertiesKHR_t(
    cl_context context,
    cl_device_id device,
    const cl_queue_properties_khr* properties,
    cl_int* errcode_ret);

typedef clCreateCommandQueueWithPropertiesKHR_t *
clCreateCommandQueueWithPropertiesKHR_fn CL_API_SUFFIX__VERSION_1_2;

#if !defined(CL_NO_NON_ICD_DISPATCH_EXTENSION_PROTOTYPES)

extern CL_API_ENTRY cl_command_queue CL_API_CALL
clCreateCommandQueueWithPropertiesKHR(
    cl_context context,
    cl_device_id device,
    const cl_queue_properties_khr* properties,
    cl_int* errcode_ret) CL_API_SUFFIX__VERSION_1_2;

#endif /* !defined(CL_NO_NON_ICD_DISPATCH_EXTENSION_PROTOTYPES) */
----


[[boilerplate-experimental-header]]
== Experimental Extensions

_Experimental_ OpenCL extensions described in this appendix are being made
publicly available to enable review and feedback
from the community. While an extension is experimental, features may be
added, removed, or changed in non-backward compatible ways.

[NOTE]
====
Previous revisions of this specification used the term _provisional_ to denote
ratified extensions with an experimental status.
====

If you have feedback on an experimental extension, please create an issue on
the link:https://github.com/KhronosGroup/OpenCL-Docs/[OpenCL-Docs
repository].

== Extension Dependencies

Extensions which have dependencies on specific core versions or on other
extensions will list such dependencies.

All extensions implicitly require support for OpenCL 1.0.

include::{generated}/meta/current_extensions_appendix.txt[]
include::{generated}/meta/experimental_extensions_appendix.txt[]
include::{generated}/meta/deprecated_extensions_appendix.txt[]
